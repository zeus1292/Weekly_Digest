var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs2(_arg) {
      }
      util2.assertIs = assertIs2;
      function assertNever4(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever4;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
        const keys = [];
        for (const key in object2) {
          if (Object.prototype.hasOwnProperty.call(object2, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr3, checker) => {
        for (const item of arr3) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues2(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues2;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_util();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue2) {
          return issue2.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error40) => {
          for (const issue2 of error40.issues) {
            if (issue2.code === "invalid_union") {
              issue2.unionErrors.map(processError);
            } else if (issue2.code === "invalid_return_type") {
              processError(issue2.returnTypeError);
            } else if (issue2.code === "invalid_arguments") {
              processError(issue2.argumentsError);
            } else if (issue2.path.length === 0) {
              fieldErrors._errors.push(mapper(issue2));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue2.path.length) {
                const el = issue2.path[i];
                const terminal = i === issue2.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue2));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue2) => issue2.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error40 = new ZodError(issues);
      return error40;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_ZodError();
    init_util();
    errorMap = (issue2, _ctx) => {
      let message;
      switch (issue2.code) {
        case ZodIssueCode.invalid_type:
          if (issue2.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue2.expected}, received ${issue2.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue2.validation === "object") {
            if ("includes" in issue2.validation) {
              message = `Invalid input: must include "${issue2.validation.includes}"`;
              if (typeof issue2.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
              }
            } else if ("startsWith" in issue2.validation) {
              message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
            } else if ("endsWith" in issue2.validation) {
              message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
            } else {
              util.assertNever(issue2.validation);
            }
          } else if (issue2.validation !== "regex") {
            message = `Invalid ${issue2.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue2.type === "array")
            message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
          else if (issue2.type === "string")
            message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
          else if (issue2.type === "number")
            message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
          else if (issue2.type === "bigint")
            message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
          else if (issue2.type === "date")
            message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue2.type === "array")
            message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
          else if (issue2.type === "string")
            message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
          else if (issue2.type === "number")
            message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
          else if (issue2.type === "bigint")
            message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
          else if (issue2.type === "date")
            message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue2.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue2);
      }
      return { message };
    };
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_en();
    overrideErrorMap = en_default;
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_errors();
    init_en();
    makeIssue = (params) => {
      const { data, path: path3, errorMaps, issueData } = params;
      const fullPath = [...path3, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map2 of maps) {
        errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x) => x.status === "aborted";
    isDirty = (x) => x.status === "dirty";
    isValid = (x) => x.status === "valid";
    isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    if (!header)
      return false;
    const base644 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base644));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check2(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types = __esm({
  "node_modules/zod/v3/types.js"() {
    init_ZodError();
    init_errors();
    init_errorUtil();
    init_parseUtil();
    init_util();
    ParseInputLazyPath = class {
      constructor(parent, value, path3, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path3;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error40 = new ZodError(ctx.common.issues);
            this._error = error40;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform2) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform2 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = class _ZodString2 extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex2 = datetimeRegex(check2);
            if (!regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "date") {
            const regex2 = dateRegex;
            if (!regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "time") {
            const regex2 = timeRegex(check2);
            if (!regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "jwt") {
            if (!isValidJWT(input.data, check2.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cidr") {
            if (!isValidCidr(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex2, validation, message) {
        return this.refinement((data) => regex2.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check2) {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex2, message) {
        return this._addCheck({
          kind: "regex",
          regex: regex2,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue2, ctx) => {
              const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
              if (issue2.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index2) {
        return new _ZodObject({
          ...this._def,
          catchall: index2
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error40) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error40
            }
          });
        }
        function makeReturnsIssue(returns, error40) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error40
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error40 = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error40.addIssue(makeArgsIssue(args, e));
              throw error40;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error40.addIssue(makeReturnsIssue(result, e));
              throw error40;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess2 },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType4 = this._getType(input);
        if (parsedType4 !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_errors();
    init_parseUtil();
    init_typeAliases();
    init_util();
    init_types();
    init_ZodError();
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/@langchain/core/dist/_virtual/rolldown_runtime.js
var __defProp2, __export2;
var init_rolldown_runtime = __esm({
  "node_modules/@langchain/core/dist/_virtual/rolldown_runtime.js"() {
    __defProp2 = Object.defineProperty;
    __export2 = (target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    };
  }
});

// node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js
var TRACING_ALS_KEY, _CONTEXT_VARIABLES_KEY, setGlobalAsyncLocalStorageInstance, getGlobalAsyncLocalStorageInstance;
var init_globals = __esm({
  "node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js"() {
    TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
    _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
    setGlobalAsyncLocalStorageInstance = (instance) => {
      globalThis[TRACING_ALS_KEY] = instance;
    };
    getGlobalAsyncLocalStorageInstance = () => {
      return globalThis[TRACING_ALS_KEY];
    };
  }
});

// node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "node_modules/decamelize/index.js"(exports2, module) {
    "use strict";
    module.exports = function(str2, sep) {
      if (typeof str2 !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str2.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string4, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string4.length; i++) {
        const character = string4[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string4 = string4.slice(0, i) + "-" + string4.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string4 = string4.slice(0, i - 1) + "-" + string4.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string4;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string4) => string4.toLowerCase() : (string4) => string4.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string4) => string4.toUpperCase() : (string4) => string4.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module.exports = camelCase2;
    module.exports.default = camelCase2;
  }
});

// node_modules/@langchain/core/dist/load/map_keys.js
function keyToJson(key, map2) {
  return map2?.[key] || (0, import_decamelize.default)(key);
}
function keyFromJson(key, map2) {
  return map2?.[key] || (0, import_camelcase.default)(key);
}
function mapKeys(fields, mapper, map2) {
  const mapped = {};
  for (const key in fields) if (Object.hasOwn(fields, key)) mapped[mapper(key, map2)] = fields[key];
  return mapped;
}
var import_decamelize, import_camelcase;
var init_map_keys = __esm({
  "node_modules/@langchain/core/dist/load/map_keys.js"() {
    import_decamelize = __toESM(require_decamelize(), 1);
    import_camelcase = __toESM(require_camelcase(), 1);
  }
});

// node_modules/@langchain/core/dist/load/validation.js
function needsEscaping(obj) {
  return "lc" in obj || Object.keys(obj).length === 1 && LC_ESCAPED_KEY in obj;
}
function escapeObject(obj) {
  return { [LC_ESCAPED_KEY]: obj };
}
function isEscapedObject(obj) {
  return Object.keys(obj).length === 1 && LC_ESCAPED_KEY in obj;
}
function isSerializableLike(obj) {
  return obj !== null && typeof obj === "object" && "lc_serializable" in obj && typeof obj.toJSON === "function";
}
function createNotImplemented(obj) {
  let id;
  if (obj !== null && typeof obj === "object") if ("lc_id" in obj && Array.isArray(obj.lc_id)) id = obj.lc_id;
  else id = [obj.constructor?.name ?? "Object"];
  else id = [typeof obj];
  return {
    lc: 1,
    type: "not_implemented",
    id
  };
}
function escapeIfNeeded(value, pathSet = /* @__PURE__ */ new WeakSet()) {
  if (value !== null && typeof value === "object" && !Array.isArray(value)) {
    if (pathSet.has(value)) return createNotImplemented(value);
    if (isSerializableLike(value)) return value;
    pathSet.add(value);
    const record2 = value;
    if (needsEscaping(record2)) {
      pathSet.delete(value);
      return escapeObject(record2);
    }
    const result = {};
    for (const [key, val] of Object.entries(record2)) result[key] = escapeIfNeeded(val, pathSet);
    pathSet.delete(value);
    return result;
  }
  if (Array.isArray(value)) return value.map((item) => escapeIfNeeded(item, pathSet));
  return value;
}
function unescapeValue(obj) {
  if (obj !== null && typeof obj === "object" && !Array.isArray(obj)) {
    const record2 = obj;
    if (isEscapedObject(record2)) return record2[LC_ESCAPED_KEY];
    const result = {};
    for (const [key, value] of Object.entries(record2)) result[key] = unescapeValue(value);
    return result;
  }
  if (Array.isArray(obj)) return obj.map((item) => unescapeValue(item));
  return obj;
}
var LC_ESCAPED_KEY;
var init_validation = __esm({
  "node_modules/@langchain/core/dist/load/validation.js"() {
    LC_ESCAPED_KEY = "__lc_escaped__";
  }
});

// node_modules/@langchain/core/dist/load/serializable.js
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root, secretsMap) {
  const result = shallowCopy(root);
  for (const [path3, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path3.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === void 0) break;
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== void 0) current[last] = {
      lc: 1,
      type: "secret",
      id: [secretId]
    };
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) return serializableClass.lc_name();
  else return serializableClass.name;
}
var serializable_exports, Serializable;
var init_serializable = __esm({
  "node_modules/@langchain/core/dist/load/serializable.js"() {
    init_rolldown_runtime();
    init_map_keys();
    init_validation();
    serializable_exports = {};
    __export2(serializable_exports, {
      Serializable: () => Serializable,
      get_lc_unique_name: () => get_lc_unique_name
    });
    Serializable = class Serializable2 {
      lc_serializable = false;
      lc_kwargs;
      /**
      * The name of the serializable. Override to provide an alias or
      * to preserve the serialized module name in minified environments.
      *
      * Implemented as a static method to support loading logic.
      */
      static lc_name() {
        return this.name;
      }
      /**
      * The final serialized identifier for the module.
      */
      get lc_id() {
        return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
      }
      /**
      * A map of secrets, which will be omitted from serialization.
      * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
      * Values are the secret ids, which will be used when deserializing.
      */
      get lc_secrets() {
        return void 0;
      }
      /**
      * A map of additional attributes to merge with constructor args.
      * Keys are the attribute names, e.g. "foo".
      * Values are the attribute values, which will be serialized.
      * These attributes need to be accepted by the constructor as arguments.
      */
      get lc_attributes() {
        return void 0;
      }
      /**
      * A map of aliases for constructor args.
      * Keys are the attribute names, e.g. "foo".
      * Values are the alias that will replace the key in serialization.
      * This is used to eg. make argument names match Python.
      */
      get lc_aliases() {
        return void 0;
      }
      /**
      * A manual list of keys that should be serialized.
      * If not overridden, all fields passed into the constructor will be serialized.
      */
      get lc_serializable_keys() {
        return void 0;
      }
      constructor(kwargs, ..._args) {
        if (this.lc_serializable_keys !== void 0) this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));
        else this.lc_kwargs = kwargs ?? {};
      }
      toJSON() {
        if (!this.lc_serializable) return this.toJSONNotImplemented();
        if (this.lc_kwargs instanceof Serializable2 || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
        const aliases = {};
        const secrets = {};
        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
          acc[key] = key in this ? this[key] : this.lc_kwargs[key];
          return acc;
        }, {});
        for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
          Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
          Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
          Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
        }
        Object.keys(secrets).forEach((keyPath) => {
          let read = this;
          let write = kwargs;
          const [last, ...partsReverse] = keyPath.split(".").reverse();
          for (const key of partsReverse.reverse()) {
            if (!(key in read) || read[key] === void 0) return;
            if (!(key in write) || write[key] === void 0) {
              if (typeof read[key] === "object" && read[key] != null) write[key] = {};
              else if (Array.isArray(read[key])) write[key] = [];
            }
            read = read[key];
            write = write[key];
          }
          if (last in read && read[last] !== void 0) write[last] = write[last] || read[last];
        });
        const escapedKwargs = {};
        const pathSet = /* @__PURE__ */ new WeakSet();
        pathSet.add(this);
        for (const [key, value] of Object.entries(kwargs)) escapedKwargs[key] = escapeIfNeeded(value, pathSet);
        const kwargsWithSecrets = Object.keys(secrets).length ? replaceSecrets(escapedKwargs, secrets) : escapedKwargs;
        const processedKwargs = mapKeys(kwargsWithSecrets, keyToJson, aliases);
        return {
          lc: 1,
          type: "constructor",
          id: this.lc_id,
          kwargs: processedKwargs
        };
      }
      toJSONNotImplemented() {
        return {
          lc: 1,
          type: "not_implemented",
          id: this.lc_id
        };
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/content/data.js
function isDataContentBlock(content_block) {
  return typeof content_block === "object" && content_block !== null && "type" in content_block && typeof content_block.type === "string" && "source_type" in content_block && (content_block.source_type === "url" || content_block.source_type === "base64" || content_block.source_type === "text" || content_block.source_type === "id");
}
function isURLContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "url" && "url" in content_block && typeof content_block.url === "string";
}
function isBase64ContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "base64" && "data" in content_block && typeof content_block.data === "string";
}
function isPlainTextContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "text" && "text" in content_block && typeof content_block.text === "string";
}
function isIDContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "id" && "id" in content_block && typeof content_block.id === "string";
}
function convertToOpenAIImageBlock(content_block) {
  if (isDataContentBlock(content_block)) {
    if (content_block.source_type === "url") return {
      type: "image_url",
      image_url: { url: content_block.url }
    };
    if (content_block.source_type === "base64") {
      if (!content_block.mime_type) throw new Error("mime_type key is required for base64 data.");
      const mime_type = content_block.mime_type;
      return {
        type: "image_url",
        image_url: { url: `data:${mime_type};base64,${content_block.data}` }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}
function parseMimeType(mime_type) {
  const parts = mime_type.split(";")[0].split("/");
  if (parts.length !== 2) throw new Error(`Invalid mime type: "${mime_type}" - does not match type/subtype format.`);
  const type = parts[0].trim();
  const subtype = parts[1].trim();
  if (type === "" || subtype === "") throw new Error(`Invalid mime type: "${mime_type}" - type or subtype is empty.`);
  const parameters = {};
  for (const parameterKvp of mime_type.split(";").slice(1)) {
    const parameterParts = parameterKvp.split("=");
    if (parameterParts.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${mime_type}".`);
    const key = parameterParts[0].trim();
    const value = parameterParts[1].trim();
    if (key === "") throw new Error(`Invalid parameter syntax in mime type: "${mime_type}".`);
    parameters[key] = value;
  }
  return {
    type,
    subtype,
    parameters
  };
}
function parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false }) {
  const formatMatch = data_url.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let mime_type;
  if (formatMatch) {
    mime_type = formatMatch[1].toLowerCase();
    const data = asTypedArray ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0)) : formatMatch[2];
    return {
      mime_type,
      data
    };
  }
  return void 0;
}
function convertToProviderContentBlock(block, converter) {
  if (block.type === "text") {
    if (!converter.fromStandardTextBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardTextBlock\` method.`);
    return converter.fromStandardTextBlock(block);
  }
  if (block.type === "image") {
    if (!converter.fromStandardImageBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardImageBlock\` method.`);
    return converter.fromStandardImageBlock(block);
  }
  if (block.type === "audio") {
    if (!converter.fromStandardAudioBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardAudioBlock\` method.`);
    return converter.fromStandardAudioBlock(block);
  }
  if (block.type === "file") {
    if (!converter.fromStandardFileBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardFileBlock\` method.`);
    return converter.fromStandardFileBlock(block);
  }
  throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);
}
var init_data = __esm({
  "node_modules/@langchain/core/dist/messages/content/data.js"() {
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/utils.js
function _isContentBlock(block, type) {
  return _isObject(block) && block.type === type;
}
function _isObject(value) {
  return typeof value === "object" && value !== null;
}
function _isArray(value) {
  return Array.isArray(value);
}
function _isString(value) {
  return typeof value === "string";
}
function _isNumber(value) {
  return typeof value === "number";
}
function _isBytesArray(value) {
  return value instanceof Uint8Array;
}
function safeParseJson(value) {
  try {
    return JSON.parse(value);
  } catch {
    return void 0;
  }
}
var iife;
var init_utils = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/utils.js"() {
    iife = (fn) => fn();
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/anthropic.js
function convertAnthropicAnnotation(citation) {
  if (citation.type === "char_location" && _isString(citation.document_title) && _isNumber(citation.start_char_index) && _isNumber(citation.end_char_index) && _isString(citation.cited_text)) {
    const { document_title, start_char_index, end_char_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "char",
      title: document_title ?? void 0,
      startIndex: start_char_index,
      endIndex: end_char_index,
      citedText: cited_text
    };
  }
  if (citation.type === "page_location" && _isString(citation.document_title) && _isNumber(citation.start_page_number) && _isNumber(citation.end_page_number) && _isString(citation.cited_text)) {
    const { document_title, start_page_number, end_page_number, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "page",
      title: document_title ?? void 0,
      startIndex: start_page_number,
      endIndex: end_page_number,
      citedText: cited_text
    };
  }
  if (citation.type === "content_block_location" && _isString(citation.document_title) && _isNumber(citation.start_block_index) && _isNumber(citation.end_block_index) && _isString(citation.cited_text)) {
    const { document_title, start_block_index, end_block_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "block",
      title: document_title ?? void 0,
      startIndex: start_block_index,
      endIndex: end_block_index,
      citedText: cited_text
    };
  }
  if (citation.type === "web_search_result_location" && _isString(citation.url) && _isString(citation.title) && _isString(citation.encrypted_index) && _isString(citation.cited_text)) {
    const { url: url2, title, encrypted_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "url",
      url: url2,
      title,
      startIndex: Number(encrypted_index),
      endIndex: Number(encrypted_index),
      citedText: cited_text
    };
  }
  if (citation.type === "search_result_location" && _isString(citation.source) && _isString(citation.title) && _isNumber(citation.start_block_index) && _isNumber(citation.end_block_index) && _isString(citation.cited_text)) {
    const { source, title, start_block_index, end_block_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "search",
      url: source,
      title: title ?? void 0,
      startIndex: start_block_index,
      endIndex: end_block_index,
      citedText: cited_text
    };
  }
  return void 0;
}
function convertToV1FromAnthropicContentBlock(block) {
  if (_isContentBlock(block, "document") && _isObject(block.source) && "type" in block.source) {
    if (block.source.type === "base64" && _isString(block.source.media_type) && _isString(block.source.data)) return {
      type: "file",
      mimeType: block.source.media_type,
      data: block.source.data
    };
    else if (block.source.type === "url" && _isString(block.source.url)) return {
      type: "file",
      url: block.source.url
    };
    else if (block.source.type === "file" && _isString(block.source.file_id)) return {
      type: "file",
      fileId: block.source.file_id
    };
    else if (block.source.type === "text" && _isString(block.source.data)) return {
      type: "file",
      mimeType: String(block.source.media_type ?? "text/plain"),
      data: block.source.data
    };
  } else if (_isContentBlock(block, "image") && _isObject(block.source) && "type" in block.source) {
    if (block.source.type === "base64" && _isString(block.source.media_type) && _isString(block.source.data)) return {
      type: "image",
      mimeType: block.source.media_type,
      data: block.source.data
    };
    else if (block.source.type === "url" && _isString(block.source.url)) return {
      type: "image",
      url: block.source.url
    };
    else if (block.source.type === "file" && _isString(block.source.file_id)) return {
      type: "image",
      fileId: block.source.file_id
    };
  }
  return void 0;
}
function convertToV1FromAnthropicInput(content) {
  function* iterateContent() {
    for (const block of content) {
      const stdBlock = convertToV1FromAnthropicContentBlock(block);
      if (stdBlock) yield stdBlock;
      else yield block;
    }
  }
  return Array.from(iterateContent());
}
function convertToV1FromAnthropicMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "text") && _isString(block.text)) {
        const { text: text2, citations, ...rest } = block;
        if (_isArray(citations) && citations.length) {
          const _citations = citations.reduce((acc, item) => {
            const citation = convertAnthropicAnnotation(item);
            if (citation) return [...acc, citation];
            return acc;
          }, []);
          yield {
            ...rest,
            type: "text",
            text: text2,
            annotations: _citations
          };
          continue;
        } else {
          yield {
            ...rest,
            type: "text",
            text: text2
          };
          continue;
        }
      } else if (_isContentBlock(block, "thinking") && _isString(block.thinking)) {
        const { thinking, signature, ...rest } = block;
        yield {
          ...rest,
          type: "reasoning",
          reasoning: thinking,
          signature
        };
        continue;
      } else if (_isContentBlock(block, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_use") && _isString(block.name) && _isString(block.id)) {
        yield {
          type: "tool_call",
          id: block.id,
          name: block.name,
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "input_json_delta")) {
        if (_isAIMessageChunk(message) && message.tool_call_chunks?.length) {
          const tool_call_chunk = message.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: tool_call_chunk.id,
            name: tool_call_chunk.name,
            args: tool_call_chunk.args,
            index: tool_call_chunk.index
          };
          continue;
        }
      } else if (_isContentBlock(block, "server_tool_use") && _isString(block.name) && _isString(block.id)) {
        const { name, id } = block;
        if (name === "web_search") {
          const query = iife(() => {
            if (typeof block.input === "string") return block.input;
            else if (_isObject(block.input) && _isString(block.input.query)) return block.input.query;
            else if (_isString(block.partial_json)) {
              const json2 = safeParseJson(block.partial_json);
              if (json2?.query) return json2.query;
            }
            return "";
          });
          yield {
            id,
            type: "server_tool_call",
            name: "web_search",
            args: { query }
          };
          continue;
        } else if (block.name === "code_execution") {
          const code = iife(() => {
            if (typeof block.input === "string") return block.input;
            else if (_isObject(block.input) && _isString(block.input.code)) return block.input.code;
            else if (_isString(block.partial_json)) {
              const json2 = safeParseJson(block.partial_json);
              if (json2?.code) return json2.code;
            }
            return "";
          });
          yield {
            id,
            type: "server_tool_call",
            name: "code_execution",
            args: { code }
          };
          continue;
        }
      } else if (_isContentBlock(block, "web_search_tool_result") && _isString(block.tool_use_id) && _isArray(block.content)) {
        const { content: content$1, tool_use_id } = block;
        const urls = content$1.reduce((acc, content$2) => {
          if (_isContentBlock(content$2, "web_search_result")) return [...acc, content$2.url];
          return acc;
        }, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: tool_use_id,
          status: "success",
          output: { urls }
        };
        continue;
      } else if (_isContentBlock(block, "code_execution_tool_result") && _isString(block.tool_use_id) && _isObject(block.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: block.tool_use_id,
          status: "success",
          output: block.content
        };
        continue;
      } else if (_isContentBlock(block, "mcp_tool_use")) {
        yield {
          id: block.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "mcp_tool_result") && _isString(block.tool_use_id) && _isObject(block.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: block.tool_use_id,
          status: "success",
          output: block.content
        };
        continue;
      } else if (_isContentBlock(block, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "search_result")) {
        yield {
          id: block.id,
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_result")) {
        yield {
          id: block.id,
          type: "non_standard",
          value: block
        };
        continue;
      } else {
        const stdBlock = convertToV1FromAnthropicContentBlock(block);
        if (stdBlock) {
          yield stdBlock;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
function _isAIMessageChunk(message) {
  return typeof message?._getType === "function" && typeof message.concat === "function" && message._getType() === "ai";
}
var ChatAnthropicTranslator;
var init_anthropic = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/anthropic.js"() {
    init_utils();
    ChatAnthropicTranslator = {
      translateContent: convertToV1FromAnthropicMessage,
      translateContentChunk: convertToV1FromAnthropicMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/data.js
function convertToV1FromDataContentBlock(block) {
  if (isURLContentBlock(block)) return {
    type: block.type,
    mimeType: block.mime_type,
    url: block.url,
    metadata: block.metadata
  };
  if (isBase64ContentBlock(block)) return {
    type: block.type,
    mimeType: block.mime_type ?? "application/octet-stream",
    data: block.data,
    metadata: block.metadata
  };
  if (isIDContentBlock(block)) return {
    type: block.type,
    mimeType: block.mime_type,
    fileId: block.id,
    metadata: block.metadata
  };
  return block;
}
function convertToV1FromDataContent(content) {
  return content.map(convertToV1FromDataContentBlock);
}
function isOpenAIDataBlock(block) {
  if (_isContentBlock(block, "image_url") && _isObject(block.image_url)) return true;
  if (_isContentBlock(block, "input_audio") && _isObject(block.input_audio)) return true;
  if (_isContentBlock(block, "file") && _isObject(block.file)) return true;
  return false;
}
function convertToV1FromOpenAIDataBlock(block) {
  if (_isContentBlock(block, "image_url") && _isObject(block.image_url) && _isString(block.image_url.url)) {
    const parsed = parseBase64DataUrl({ dataUrl: block.image_url.url });
    if (parsed) return {
      type: "image",
      mimeType: parsed.mime_type,
      data: parsed.data
    };
    else return {
      type: "image",
      url: block.image_url.url
    };
  } else if (_isContentBlock(block, "input_audio") && _isObject(block.input_audio) && _isString(block.input_audio.data) && _isString(block.input_audio.format)) return {
    type: "audio",
    data: block.input_audio.data,
    mimeType: `audio/${block.input_audio.format}`
  };
  else if (_isContentBlock(block, "file") && _isObject(block.file) && _isString(block.file.data)) {
    const parsed = parseBase64DataUrl({ dataUrl: block.file.data });
    if (parsed) return {
      type: "file",
      data: parsed.data,
      mimeType: parsed.mime_type
    };
    else if (_isString(block.file.file_id)) return {
      type: "file",
      fileId: block.file.file_id
    };
  }
  return block;
}
var init_data2 = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/data.js"() {
    init_data();
    init_utils();
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/openai.js
function convertToV1FromChatCompletions(message) {
  const blocks2 = [];
  if (typeof message.content === "string") blocks2.push({
    type: "text",
    text: message.content
  });
  else blocks2.push(...convertToV1FromChatCompletionsInput(message.content));
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
function convertToV1FromChatCompletionsChunk(message) {
  const blocks2 = [];
  if (typeof message.content === "string") blocks2.push({
    type: "text",
    text: message.content
  });
  else blocks2.push(...convertToV1FromChatCompletionsInput(message.content));
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
function convertToV1FromChatCompletionsInput(blocks2) {
  const convertedBlocks = [];
  for (const block of blocks2) if (isOpenAIDataBlock(block)) convertedBlocks.push(convertToV1FromOpenAIDataBlock(block));
  else convertedBlocks.push(block);
  return convertedBlocks;
}
function convertResponsesAnnotation(annotation) {
  if (annotation.type === "url_citation") {
    const { url: url2, title, start_index, end_index } = annotation;
    return {
      type: "citation",
      url: url2,
      title,
      startIndex: start_index,
      endIndex: end_index
    };
  }
  if (annotation.type === "file_citation") {
    const { file_id, filename, index: index2 } = annotation;
    return {
      type: "citation",
      title: filename,
      startIndex: index2,
      endIndex: index2,
      fileId: file_id
    };
  }
  return annotation;
}
function convertToV1FromResponses(message) {
  function* iterateContent() {
    if (_isObject(message.additional_kwargs?.reasoning) && _isArray(message.additional_kwargs.reasoning.summary)) {
      const summary = message.additional_kwargs.reasoning.summary.reduce((acc, item) => {
        if (_isObject(item) && _isString(item.text)) return `${acc}${item.text}`;
        return acc;
      }, "");
      yield {
        type: "reasoning",
        reasoning: summary
      };
    }
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) if (_isContentBlock(block, "text")) {
      const { text: text2, annotations, ...rest } = block;
      if (Array.isArray(annotations)) yield {
        ...rest,
        type: "text",
        text: String(text2),
        annotations: annotations.map(convertResponsesAnnotation)
      };
      else yield {
        ...rest,
        type: "text",
        text: String(text2)
      };
    }
    for (const toolCall of message.tool_calls ?? []) yield {
      type: "tool_call",
      id: toolCall.id,
      name: toolCall.name,
      args: toolCall.args
    };
    if (_isObject(message.additional_kwargs) && _isArray(message.additional_kwargs.tool_outputs)) for (const toolOutput of message.additional_kwargs.tool_outputs) {
      if (_isContentBlock(toolOutput, "web_search_call")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "web_search",
          args: { query: toolOutput.query }
        };
        continue;
      } else if (_isContentBlock(toolOutput, "file_search_call")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "file_search",
          args: { query: toolOutput.query }
        };
        continue;
      } else if (_isContentBlock(toolOutput, "computer_call")) {
        yield {
          type: "non_standard",
          value: toolOutput
        };
        continue;
      } else if (_isContentBlock(toolOutput, "code_interpreter_call")) {
        if (_isString(toolOutput.code)) yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "code_interpreter",
          args: { code: toolOutput.code }
        };
        if (_isArray(toolOutput.outputs)) {
          const returnCode = iife(() => {
            if (toolOutput.status === "in_progress") return void 0;
            if (toolOutput.status === "completed") return 0;
            if (toolOutput.status === "incomplete") return 127;
            if (toolOutput.status === "interpreting") return void 0;
            if (toolOutput.status === "failed") return 1;
            return void 0;
          });
          for (const output of toolOutput.outputs) if (_isContentBlock(output, "logs")) {
            yield {
              type: "server_tool_call_result",
              toolCallId: toolOutput.id ?? "",
              status: "success",
              output: {
                type: "code_interpreter_output",
                returnCode: returnCode ?? 0,
                stderr: [0, void 0].includes(returnCode) ? void 0 : String(output.logs),
                stdout: [0, void 0].includes(returnCode) ? String(output.logs) : void 0
              }
            };
            continue;
          }
        }
        continue;
      } else if (_isContentBlock(toolOutput, "mcp_call")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "mcp_call",
          args: toolOutput.input
        };
        continue;
      } else if (_isContentBlock(toolOutput, "mcp_list_tools")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "mcp_list_tools",
          args: toolOutput.input
        };
        continue;
      } else if (_isContentBlock(toolOutput, "mcp_approval_request")) {
        yield {
          type: "non_standard",
          value: toolOutput
        };
        continue;
      } else if (_isContentBlock(toolOutput, "image_generation_call")) {
        if (_isString(toolOutput.result)) yield {
          type: "image",
          mimeType: "image/png",
          data: toolOutput.result,
          id: _isString(toolOutput.id) ? toolOutput.id : void 0,
          metadata: { status: _isString(toolOutput.status) ? toolOutput.status : void 0 }
        };
        yield {
          type: "non_standard",
          value: toolOutput
        };
        continue;
      }
      if (_isObject(toolOutput)) yield {
        type: "non_standard",
        value: toolOutput
      };
    }
  }
  return Array.from(iterateContent());
}
function convertToV1FromResponsesChunk(message) {
  function* iterateContent() {
    yield* convertToV1FromResponses(message);
    for (const toolCallChunk of message.tool_call_chunks ?? []) yield {
      type: "tool_call_chunk",
      id: toolCallChunk.id,
      name: toolCallChunk.name,
      args: toolCallChunk.args
    };
  }
  return Array.from(iterateContent());
}
var ChatOpenAITranslator;
var init_openai = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/openai.js"() {
    init_utils();
    init_data2();
    ChatOpenAITranslator = {
      translateContent: (message) => {
        if (typeof message.content === "string") return convertToV1FromChatCompletions(message);
        return convertToV1FromResponses(message);
      },
      translateContentChunk: (message) => {
        if (typeof message.content === "string") return convertToV1FromChatCompletionsChunk(message);
        return convertToV1FromResponsesChunk(message);
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/message.js
function isMessage(message) {
  return typeof message === "object" && message !== null && "type" in message && "content" in message && (typeof message.content === "string" || Array.isArray(message.content));
}
var init_message = __esm({
  "node_modules/@langchain/core/dist/messages/message.js"() {
  }
});

// node_modules/@langchain/core/dist/messages/format.js
function convertToFormattedString(message, format2 = "pretty") {
  if (format2 === "pretty") return convertToPrettyString(message);
  return JSON.stringify(message);
}
function convertToPrettyString(message) {
  const lines = [];
  const title = ` ${message.type.charAt(0).toUpperCase() + message.type.slice(1)} Message `;
  const sepLen = Math.floor((80 - title.length) / 2);
  const sep = "=".repeat(sepLen);
  const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;
  lines.push(`${sep}${title}${secondSep}`);
  if (message.type === "ai") {
    const aiMessage = message;
    if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {
      lines.push("Tool Calls:");
      for (const tc of aiMessage.tool_calls) {
        lines.push(`  ${tc.name} (${tc.id})`);
        lines.push(` Call ID: ${tc.id}`);
        lines.push("  Args:");
        for (const [key, value] of Object.entries(tc.args)) lines.push(`    ${key}: ${typeof value === "object" ? JSON.stringify(value) : value}`);
      }
    }
  }
  if (message.type === "tool") {
    const toolMessage = message;
    if (toolMessage.name) lines.push(`Name: ${toolMessage.name}`);
  }
  if (typeof message.content === "string" && message.content.trim()) {
    if (lines.length > 1) lines.push("");
    lines.push(message.content);
  }
  return lines.join("\n");
}
var init_format = __esm({
  "node_modules/@langchain/core/dist/messages/format.js"() {
  }
});

// node_modules/@langchain/core/dist/messages/base.js
function mergeContent(firstContent, secondContent) {
  if (typeof firstContent === "string") {
    if (firstContent === "") return secondContent;
    if (typeof secondContent === "string") return firstContent + secondContent;
    else if (Array.isArray(secondContent) && secondContent.length === 0) return firstContent;
    else if (Array.isArray(secondContent) && secondContent.some((c) => isDataContentBlock(c))) return [{
      type: "text",
      source_type: "text",
      text: firstContent
    }, ...secondContent];
    else return [{
      type: "text",
      text: firstContent
    }, ...secondContent];
  } else if (Array.isArray(secondContent)) return _mergeLists(firstContent, secondContent) ?? [...firstContent, ...secondContent];
  else if (secondContent === "") return firstContent;
  else if (Array.isArray(firstContent) && firstContent.some((c) => isDataContentBlock(c))) return [...firstContent, {
    type: "file",
    source_type: "text",
    text: secondContent
  }];
  else return [...firstContent, {
    type: "text",
    text: secondContent
  }];
}
function _mergeStatus(left, right) {
  if (left === "error" || right === "error") return "error";
  return "success";
}
function stringifyWithDepthLimit(obj, depthLimit) {
  function helper(obj$1, currentDepth) {
    if (typeof obj$1 !== "object" || obj$1 === null || obj$1 === void 0) return obj$1;
    if (currentDepth >= depthLimit) {
      if (Array.isArray(obj$1)) return "[Array]";
      return "[Object]";
    }
    if (Array.isArray(obj$1)) return obj$1.map((item) => helper(item, currentDepth + 1));
    const result = {};
    for (const key of Object.keys(obj$1)) result[key] = helper(obj$1[key], currentDepth + 1);
    return result;
  }
  return JSON.stringify(helper(obj, 0), null, 2);
}
function isOpenAIToolCallArray(value) {
  return Array.isArray(value) && value.every((v) => typeof v.index === "number");
}
function _mergeDicts(left, right, options) {
  const ignoreKeys = options?.ignoreKeys ?? DEFAULT_MERGE_IGNORE_KEYS;
  if (left == null && right == null) return void 0;
  if (left == null || right == null) return left ?? right;
  const merged = { ...left };
  for (const [key, value] of Object.entries(right)) if (merged[key] == null) merged[key] = value;
  else if (value == null) continue;
  else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
  else if (typeof merged[key] === "string") if (key === "type") continue;
  else if ([
    "id",
    "name",
    "output_version",
    "model_provider"
  ].includes(key)) {
    if (value) merged[key] = value;
  } else if (ignoreKeys.includes(key)) continue;
  else merged[key] += value;
  else if (typeof merged[key] === "number") {
    if (ignoreKeys.includes(key)) continue;
    merged[key] = merged[key] + value;
  } else if (typeof merged[key] === "object" && !Array.isArray(merged[key])) merged[key] = _mergeDicts(merged[key], value, options);
  else if (Array.isArray(merged[key])) merged[key] = _mergeLists(merged[key], value, options);
  else if (merged[key] === value) continue;
  else console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
  return merged;
}
function _mergeLists(left, right, options) {
  if (left == null && right == null) return void 0;
  else if (left == null || right == null) return left || right;
  else {
    const merged = [...left];
    for (const item of right) if (typeof item === "object" && item !== null && "index" in item && typeof item.index === "number") {
      const toMerge = merged.findIndex((leftItem) => {
        const isObject4 = typeof leftItem === "object";
        const indiciesMatch = "index" in leftItem && leftItem.index === item.index;
        const idsMatch = "id" in leftItem && "id" in item && leftItem?.id === item?.id;
        const eitherItemMissingID = !("id" in leftItem) || !leftItem?.id || !("id" in item) || !item?.id;
        return isObject4 && indiciesMatch && (idsMatch || eitherItemMissingID);
      });
      if (toMerge !== -1 && typeof merged[toMerge] === "object" && merged[toMerge] !== null) merged[toMerge] = _mergeDicts(merged[toMerge], item, options);
      else merged.push(item);
    } else if (typeof item === "object" && item !== null && "text" in item && item.text === "") continue;
    else merged.push(item);
    return merged;
  }
}
function _mergeObj(left, right, options) {
  if (left == null && right == null) return void 0;
  if (left == null || right == null) return left ?? right;
  else if (typeof left !== typeof right) throw new Error(`Cannot merge objects of different types.
Left ${typeof left}
Right ${typeof right}`);
  else if (typeof left === "string" && typeof right === "string") return left + right;
  else if (Array.isArray(left) && Array.isArray(right)) return _mergeLists(left, right, options);
  else if (typeof left === "object" && typeof right === "object") return _mergeDicts(left, right, options);
  else if (left === right) return left;
  else throw new Error(`Can not merge objects of different types.
Left ${left}
Right ${right}`);
}
function _isMessageFieldWithRole(x) {
  return typeof x.role === "string";
}
function isBaseMessage(messageLike) {
  return typeof messageLike?._getType === "function";
}
function isBaseMessageChunk(messageLike) {
  return BaseMessageChunk.isInstance(messageLike);
}
var MESSAGE_SYMBOL, BaseMessage, DEFAULT_MERGE_IGNORE_KEYS, BaseMessageChunk;
var init_base = __esm({
  "node_modules/@langchain/core/dist/messages/base.js"() {
    init_serializable();
    init_data();
    init_anthropic();
    init_data2();
    init_openai();
    init_message();
    init_format();
    MESSAGE_SYMBOL = Symbol.for("langchain.message");
    BaseMessage = class extends Serializable {
      lc_namespace = ["langchain_core", "messages"];
      lc_serializable = true;
      get lc_aliases() {
        return {
          additional_kwargs: "additional_kwargs",
          response_metadata: "response_metadata"
        };
      }
      [MESSAGE_SYMBOL] = true;
      id;
      /** @inheritdoc */
      name;
      content;
      additional_kwargs;
      response_metadata;
      /**
      * @deprecated Use .getType() instead or import the proper typeguard.
      * For example:
      *
      * ```ts
      * import { isAIMessage } from "@langchain/core/messages";
      *
      * const message = new AIMessage("Hello!");
      * isAIMessage(message); // true
      * ```
      */
      _getType() {
        return this.type;
      }
      /**
      * @deprecated Use .type instead
      * The type of the message.
      */
      getType() {
        return this._getType();
      }
      constructor(arg) {
        const fields = typeof arg === "string" || Array.isArray(arg) ? { content: arg } : arg;
        if (!fields.additional_kwargs) fields.additional_kwargs = {};
        if (!fields.response_metadata) fields.response_metadata = {};
        super(fields);
        this.name = fields.name;
        if (fields.content === void 0 && fields.contentBlocks !== void 0) {
          this.content = fields.contentBlocks;
          this.response_metadata = {
            output_version: "v1",
            ...fields.response_metadata
          };
        } else if (fields.content !== void 0) {
          this.content = fields.content ?? [];
          this.response_metadata = fields.response_metadata;
        } else {
          this.content = [];
          this.response_metadata = fields.response_metadata;
        }
        this.additional_kwargs = fields.additional_kwargs;
        this.id = fields.id;
      }
      /** Get text content of the message. */
      get text() {
        if (typeof this.content === "string") return this.content;
        if (!Array.isArray(this.content)) return "";
        return this.content.map((c) => {
          if (typeof c === "string") return c;
          if (c.type === "text") return c.text;
          return "";
        }).join("");
      }
      get contentBlocks() {
        const blocks2 = typeof this.content === "string" ? [{
          type: "text",
          text: this.content
        }] : this.content;
        const parsingSteps = [
          convertToV1FromDataContent,
          convertToV1FromChatCompletionsInput,
          convertToV1FromAnthropicInput
        ];
        const parsedBlocks = parsingSteps.reduce((blocks$1, step) => step(blocks$1), blocks2);
        return parsedBlocks;
      }
      toDict() {
        return {
          type: this.getType(),
          data: this.toJSON().kwargs
        };
      }
      static lc_name() {
        return "BaseMessage";
      }
      get _printableFields() {
        return {
          id: this.id,
          content: this.content,
          name: this.name,
          additional_kwargs: this.additional_kwargs,
          response_metadata: this.response_metadata
        };
      }
      static isInstance(obj) {
        return typeof obj === "object" && obj !== null && MESSAGE_SYMBOL in obj && obj[MESSAGE_SYMBOL] === true && isMessage(obj);
      }
      _updateId(value) {
        this.id = value;
        this.lc_kwargs.id = value;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.lc_name();
      }
      [Symbol.for("nodejs.util.inspect.custom")](depth) {
        if (depth === null) return this;
        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
        return `${this.constructor.lc_name()} ${printable}`;
      }
      toFormattedString(format2 = "pretty") {
        return convertToFormattedString(this, format2);
      }
    };
    DEFAULT_MERGE_IGNORE_KEYS = [
      "index",
      "created",
      "timestamp"
    ];
    BaseMessageChunk = class BaseMessageChunk2 extends BaseMessage {
      static isInstance(obj) {
        if (!super.isInstance(obj)) return false;
        let proto = Object.getPrototypeOf(obj);
        while (proto !== null) {
          if (proto === BaseMessageChunk2.prototype) return true;
          proto = Object.getPrototypeOf(proto);
        }
        return false;
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/tool.js
function isDirectToolOutput(x) {
  return x != null && typeof x === "object" && "lc_direct_tool_output" in x && x.lc_direct_tool_output === true;
}
function defaultToolCallParser(rawToolCalls) {
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const toolCall of rawToolCalls) if (!toolCall.function) continue;
  else {
    const functionName = toolCall.function.name;
    try {
      const functionArgs = JSON.parse(toolCall.function.arguments);
      toolCalls.push({
        name: functionName || "",
        args: functionArgs || {},
        id: toolCall.id
      });
    } catch {
      invalidToolCalls.push({
        name: functionName,
        args: toolCall.function.arguments,
        id: toolCall.id,
        error: "Malformed args."
      });
    }
  }
  return [toolCalls, invalidToolCalls];
}
function isToolMessage(x) {
  return typeof x === "object" && x !== null && "getType" in x && typeof x.getType === "function" && x.getType() === "tool";
}
function isToolMessageChunk(x) {
  return x._getType() === "tool";
}
var tool_exports, ToolMessage, ToolMessageChunk;
var init_tool = __esm({
  "node_modules/@langchain/core/dist/messages/tool.js"() {
    init_rolldown_runtime();
    init_base();
    tool_exports = {};
    __export2(tool_exports, {
      ToolMessage: () => ToolMessage,
      ToolMessageChunk: () => ToolMessageChunk,
      defaultToolCallParser: () => defaultToolCallParser,
      isDirectToolOutput: () => isDirectToolOutput,
      isToolMessage: () => isToolMessage,
      isToolMessageChunk: () => isToolMessageChunk
    });
    ToolMessage = class extends BaseMessage {
      static lc_name() {
        return "ToolMessage";
      }
      get lc_aliases() {
        return { tool_call_id: "tool_call_id" };
      }
      lc_direct_tool_output = true;
      type = "tool";
      /**
      * Status of the tool invocation.
      * @version 0.2.19
      */
      status;
      tool_call_id;
      metadata;
      /**
      * Artifact of the Tool execution which is not meant to be sent to the model.
      *
      * Should only be specified if it is different from the message content, e.g. if only
      * a subset of the full tool output is being passed as message content but the full
      * output is needed in other parts of the code.
      */
      artifact;
      constructor(fields, tool_call_id, name) {
        const toolMessageFields = typeof fields === "string" || Array.isArray(fields) ? {
          content: fields,
          name,
          tool_call_id
        } : fields;
        super(toolMessageFields);
        this.tool_call_id = toolMessageFields.tool_call_id;
        this.artifact = toolMessageFields.artifact;
        this.status = toolMessageFields.status;
        this.metadata = toolMessageFields.metadata;
      }
      static isInstance(message) {
        return super.isInstance(message) && message.type === "tool";
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_call_id: this.tool_call_id,
          artifact: this.artifact
        };
      }
    };
    ToolMessageChunk = class extends BaseMessageChunk {
      type = "tool";
      tool_call_id;
      /**
      * Status of the tool invocation.
      * @version 0.2.19
      */
      status;
      /**
      * Artifact of the Tool execution which is not meant to be sent to the model.
      *
      * Should only be specified if it is different from the message content, e.g. if only
      * a subset of the full tool output is being passed as message content but the full
      * output is needed in other parts of the code.
      */
      artifact;
      constructor(fields) {
        super(fields);
        this.tool_call_id = fields.tool_call_id;
        this.artifact = fields.artifact;
        this.status = fields.status;
      }
      static lc_name() {
        return "ToolMessageChunk";
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: mergeContent(this.content, chunk.content),
          additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
          artifact: _mergeObj(this.artifact, chunk.artifact),
          tool_call_id: this.tool_call_id,
          id: this.id ?? chunk.id,
          status: _mergeStatus(this.status, chunk.status)
        });
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_call_id: this.tool_call_id,
          artifact: this.artifact
        };
      }
    };
  }
});

// node_modules/@langchain/core/dist/errors/index.js
function addLangChainErrorFields(error40, lc_error_code) {
  error40.lc_error_code = lc_error_code;
  error40.message = `${error40.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/
`;
  return error40;
}
var init_errors2 = __esm({
  "node_modules/@langchain/core/dist/errors/index.js"() {
  }
});

// node_modules/@langchain/core/dist/tools/utils.js
function _isToolCall(toolCall) {
  return !!(toolCall && typeof toolCall === "object" && "type" in toolCall && toolCall.type === "tool_call");
}
function _configHasToolCallId(config2) {
  return !!(config2 && typeof config2 === "object" && "toolCall" in config2 && config2.toolCall != null && typeof config2.toolCall === "object" && "id" in config2.toolCall && typeof config2.toolCall.id === "string");
}
var ToolInputParsingException;
var init_utils2 = __esm({
  "node_modules/@langchain/core/dist/tools/utils.js"() {
    ToolInputParsingException = class extends Error {
      output;
      constructor(message, output) {
        super(message);
        this.output = output;
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/json.js
function parseJsonMarkdown(s, parser = parsePartialJson) {
  s = s.trim();
  const firstFenceIndex = s.indexOf("```");
  if (firstFenceIndex === -1) return parser(s);
  let contentAfterFence = s.substring(firstFenceIndex + 3);
  if (contentAfterFence.startsWith("json\n")) contentAfterFence = contentAfterFence.substring(5);
  else if (contentAfterFence.startsWith("json")) contentAfterFence = contentAfterFence.substring(4);
  else if (contentAfterFence.startsWith("\n")) contentAfterFence = contentAfterFence.substring(1);
  const closingFenceIndex = contentAfterFence.indexOf("```");
  let finalContent = contentAfterFence;
  if (closingFenceIndex !== -1) finalContent = contentAfterFence.substring(0, closingFenceIndex);
  return parser(finalContent.trim());
}
function strictParsePartialJson(s) {
  try {
    return JSON.parse(s);
  } catch {
  }
  const buffer = s.trim();
  if (buffer.length === 0) throw new Error("Unexpected end of JSON input");
  let pos = 0;
  function skipWhitespace2() {
    while (pos < buffer.length && /\s/.test(buffer[pos])) pos += 1;
  }
  function parseString() {
    if (buffer[pos] !== '"') throw new Error(`Expected '"' at position ${pos}, got '${buffer[pos]}'`);
    pos += 1;
    let result = "";
    let escaped = false;
    while (pos < buffer.length) {
      const char = buffer[pos];
      if (escaped) {
        if (char === "n") result += "\n";
        else if (char === "t") result += "	";
        else if (char === "r") result += "\r";
        else if (char === "\\") result += "\\";
        else if (char === '"') result += '"';
        else if (char === "b") result += "\b";
        else if (char === "f") result += "\f";
        else if (char === "/") result += "/";
        else if (char === "u") {
          const hex = buffer.substring(pos + 1, pos + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(hex)) {
            if (hex.length === 4) result += String.fromCharCode(Number.parseInt(hex, 16));
            else result += `u${hex}`;
            pos += hex.length;
          } else throw new Error(`Invalid unicode escape sequence '\\u${hex}' at position ${pos}`);
        } else throw new Error(`Invalid escape sequence '\\${char}' at position ${pos}`);
        escaped = false;
      } else if (char === "\\") escaped = true;
      else if (char === '"') {
        pos += 1;
        return result;
      } else result += char;
      pos += 1;
    }
    if (escaped) result += "\\";
    return result;
  }
  function parseNumber() {
    const start = pos;
    let numStr = "";
    if (buffer[pos] === "-") {
      numStr += "-";
      pos += 1;
    }
    if (pos < buffer.length && buffer[pos] === "0") {
      numStr += "0";
      pos += 1;
      if (buffer[pos] >= "0" && buffer[pos] <= "9") throw new Error(`Invalid number at position ${start}`);
    }
    if (pos < buffer.length && buffer[pos] >= "1" && buffer[pos] <= "9") while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
      numStr += buffer[pos];
      pos += 1;
    }
    if (pos < buffer.length && buffer[pos] === ".") {
      numStr += ".";
      pos += 1;
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    }
    if (pos < buffer.length && (buffer[pos] === "e" || buffer[pos] === "E")) {
      numStr += buffer[pos];
      pos += 1;
      if (pos < buffer.length && (buffer[pos] === "+" || buffer[pos] === "-")) {
        numStr += buffer[pos];
        pos += 1;
      }
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    }
    if (numStr === "-") return -0;
    const num = Number.parseFloat(numStr);
    if (Number.isNaN(num)) {
      pos = start;
      throw new Error(`Invalid number '${numStr}' at position ${start}`);
    }
    return num;
  }
  function parseValue2() {
    skipWhitespace2();
    if (pos >= buffer.length) throw new Error(`Unexpected end of input at position ${pos}`);
    const char = buffer[pos];
    if (char === "{") return parseObject();
    if (char === "[") return parseArray();
    if (char === '"') return parseString();
    if ("null".startsWith(buffer.substring(pos, pos + 4))) {
      pos += Math.min(4, buffer.length - pos);
      return null;
    }
    if ("true".startsWith(buffer.substring(pos, pos + 4))) {
      pos += Math.min(4, buffer.length - pos);
      return true;
    }
    if ("false".startsWith(buffer.substring(pos, pos + 5))) {
      pos += Math.min(5, buffer.length - pos);
      return false;
    }
    if (char === "-" || char >= "0" && char <= "9") return parseNumber();
    throw new Error(`Unexpected character '${char}' at position ${pos}`);
  }
  function parseArray() {
    if (buffer[pos] !== "[") throw new Error(`Expected '[' at position ${pos}, got '${buffer[pos]}'`);
    const arr3 = [];
    pos += 1;
    skipWhitespace2();
    if (pos >= buffer.length) return arr3;
    if (buffer[pos] === "]") {
      pos += 1;
      return arr3;
    }
    while (pos < buffer.length) {
      skipWhitespace2();
      if (pos >= buffer.length) return arr3;
      arr3.push(parseValue2());
      skipWhitespace2();
      if (pos >= buffer.length) return arr3;
      if (buffer[pos] === "]") {
        pos += 1;
        return arr3;
      } else if (buffer[pos] === ",") {
        pos += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${pos}, got '${buffer[pos]}'`);
    }
    return arr3;
  }
  function parseObject() {
    if (buffer[pos] !== "{") throw new Error(`Expected '{' at position ${pos}, got '${buffer[pos]}'`);
    const obj = {};
    pos += 1;
    skipWhitespace2();
    if (pos >= buffer.length) return obj;
    if (buffer[pos] === "}") {
      pos += 1;
      return obj;
    }
    while (pos < buffer.length) {
      skipWhitespace2();
      if (pos >= buffer.length) return obj;
      const key = parseString();
      skipWhitespace2();
      if (pos >= buffer.length) return obj;
      if (buffer[pos] !== ":") throw new Error(`Expected ':' at position ${pos}, got '${buffer[pos]}'`);
      pos += 1;
      skipWhitespace2();
      if (pos >= buffer.length) return obj;
      obj[key] = parseValue2();
      skipWhitespace2();
      if (pos >= buffer.length) return obj;
      if (buffer[pos] === "}") {
        pos += 1;
        return obj;
      } else if (buffer[pos] === ",") {
        pos += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${pos}, got '${buffer[pos]}'`);
    }
    return obj;
  }
  const value = parseValue2();
  skipWhitespace2();
  if (pos < buffer.length) throw new Error(`Unexpected character '${buffer[pos]}' at position ${pos}`);
  return value;
}
function parsePartialJson(s) {
  try {
    if (typeof s === "undefined") return null;
    return strictParsePartialJson(s);
  } catch {
    return null;
  }
}
var init_json = __esm({
  "node_modules/@langchain/core/dist/utils/json.js"() {
  }
});

// node_modules/@langchain/core/dist/messages/chat.js
function isChatMessage(x) {
  return x._getType() === "generic";
}
function isChatMessageChunk(x) {
  return x._getType() === "generic";
}
var ChatMessage, ChatMessageChunk;
var init_chat = __esm({
  "node_modules/@langchain/core/dist/messages/chat.js"() {
    init_base();
    ChatMessage = class ChatMessage2 extends BaseMessage {
      static lc_name() {
        return "ChatMessage";
      }
      type = "generic";
      role;
      static _chatMessageClass() {
        return ChatMessage2;
      }
      constructor(fields, role) {
        if (typeof fields === "string" || Array.isArray(fields)) fields = {
          content: fields,
          role
        };
        super(fields);
        this.role = fields.role;
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "generic";
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          role: this.role
        };
      }
    };
    ChatMessageChunk = class extends BaseMessageChunk {
      static lc_name() {
        return "ChatMessageChunk";
      }
      type = "generic";
      role;
      constructor(fields, role) {
        if (typeof fields === "string" || Array.isArray(fields)) fields = {
          content: fields,
          role
        };
        super(fields);
        this.role = fields.role;
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: mergeContent(this.content, chunk.content),
          additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
          role: this.role,
          id: this.id ?? chunk.id
        });
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "generic";
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          role: this.role
        };
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/function.js
function isFunctionMessage(x) {
  return x._getType() === "function";
}
function isFunctionMessageChunk(x) {
  return x._getType() === "function";
}
var FunctionMessage, FunctionMessageChunk;
var init_function = __esm({
  "node_modules/@langchain/core/dist/messages/function.js"() {
    init_base();
    FunctionMessage = class extends BaseMessage {
      static lc_name() {
        return "FunctionMessage";
      }
      type = "function";
      name;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
      }
    };
    FunctionMessageChunk = class extends BaseMessageChunk {
      static lc_name() {
        return "FunctionMessageChunk";
      }
      type = "function";
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: mergeContent(this.content, chunk.content),
          additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
          name: this.name ?? "",
          id: this.id ?? chunk.id
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/human.js
function isHumanMessage(x) {
  return x.getType() === "human";
}
function isHumanMessageChunk(x) {
  return x.getType() === "human";
}
var HumanMessage, HumanMessageChunk;
var init_human = __esm({
  "node_modules/@langchain/core/dist/messages/human.js"() {
    init_base();
    HumanMessage = class extends BaseMessage {
      static lc_name() {
        return "HumanMessage";
      }
      type = "human";
      constructor(fields) {
        super(fields);
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "human";
      }
    };
    HumanMessageChunk = class extends BaseMessageChunk {
      static lc_name() {
        return "HumanMessageChunk";
      }
      type = "human";
      constructor(fields) {
        super(fields);
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: mergeContent(this.content, chunk.content),
          additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
          id: this.id ?? chunk.id
        });
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "human";
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/modifier.js
var RemoveMessage;
var init_modifier = __esm({
  "node_modules/@langchain/core/dist/messages/modifier.js"() {
    init_base();
    RemoveMessage = class extends BaseMessage {
      type = "remove";
      /**
      * The ID of the message to remove.
      */
      id;
      constructor(fields) {
        super({
          ...fields,
          content: []
        });
        this.id = fields.id;
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          id: this.id
        };
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "remove";
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/system.js
function isSystemMessage(x) {
  return x._getType() === "system";
}
function isSystemMessageChunk(x) {
  return x._getType() === "system";
}
var SystemMessage, SystemMessageChunk;
var init_system = __esm({
  "node_modules/@langchain/core/dist/messages/system.js"() {
    init_base();
    SystemMessage = class SystemMessage2 extends BaseMessage {
      static lc_name() {
        return "SystemMessage";
      }
      type = "system";
      constructor(fields) {
        super(fields);
      }
      /**
      * Concatenates a string or another system message with the current system message.
      * @param chunk - The chunk to concatenate with the system message.
      * @returns A new system message with the concatenated content.
      */
      concat(chunk) {
        if (typeof chunk === "string") return new SystemMessage2({
          ...this,
          content: mergeContent(this.content, chunk)
        });
        if (SystemMessage2.isInstance(chunk)) return new SystemMessage2({
          ...this,
          additional_kwargs: {
            ...this.additional_kwargs,
            ...chunk.additional_kwargs
          },
          response_metadata: {
            ...this.response_metadata,
            ...chunk.response_metadata
          },
          content: mergeContent(this.content, chunk.content)
        });
        throw new Error("Unexpected chunk type for system message");
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "system";
      }
    };
    SystemMessageChunk = class extends BaseMessageChunk {
      static lc_name() {
        return "SystemMessageChunk";
      }
      type = "system";
      constructor(fields) {
        super(fields);
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: mergeContent(this.content, chunk.content),
          additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
          id: this.id ?? chunk.id
        });
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "system";
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.js
function convertFileFormatToMimeType(format2) {
  switch (format2) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function convertConverseDocumentBlock(block) {
  if (_isObject(block.document) && _isObject(block.document.source)) {
    const format2 = _isObject(block.document) && _isString(block.document.format) ? block.document.format : "";
    const mimeType = convertFileFormatToMimeType(format2);
    if (_isObject(block.document.source)) {
      if (_isObject(block.document.source.s3Location) && _isString(block.document.source.s3Location.uri)) return {
        type: "file",
        mimeType,
        fileId: block.document.source.s3Location.uri
      };
      if (_isBytesArray(block.document.source.bytes)) return {
        type: "file",
        mimeType,
        data: block.document.source.bytes
      };
      if (_isString(block.document.source.text)) return {
        type: "file",
        mimeType,
        data: Buffer.from(block.document.source.text).toString("base64")
      };
      if (_isArray(block.document.source.content)) {
        const data = block.document.source.content.reduce((acc, item) => {
          if (_isObject(item) && _isString(item.text)) return acc + item.text;
          return acc;
        }, "");
        return {
          type: "file",
          mimeType,
          data
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertConverseImageBlock(block) {
  if (_isContentBlock(block, "image") && _isObject(block.image)) {
    const format2 = _isObject(block.image) && _isString(block.image.format) ? block.image.format : "";
    const mimeType = convertFileFormatToMimeType(format2);
    if (_isObject(block.image.source)) {
      if (_isObject(block.image.source.s3Location) && _isString(block.image.source.s3Location.uri)) return {
        type: "image",
        mimeType,
        fileId: block.image.source.s3Location.uri
      };
      if (_isBytesArray(block.image.source.bytes)) return {
        type: "image",
        mimeType,
        data: block.image.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertConverseVideoBlock(block) {
  if (_isContentBlock(block, "video") && _isObject(block.video)) {
    const format2 = _isObject(block.video) && _isString(block.video.format) ? block.video.format : "";
    const mimeType = convertFileFormatToMimeType(format2);
    if (_isObject(block.video.source)) {
      if (_isObject(block.video.source.s3Location) && _isString(block.video.source.s3Location.uri)) return {
        type: "video",
        mimeType,
        fileId: block.video.source.s3Location.uri
      };
      if (_isBytesArray(block.video.source.bytes)) return {
        type: "video",
        mimeType,
        data: block.video.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertToV1FromChatBedrockConverseMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "cache_point")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "citations_content") && _isObject(block.citationsContent)) {
        const text2 = _isArray(block.citationsContent.content) ? block.citationsContent.content.reduce((acc, item) => {
          if (_isObject(item) && _isString(item.text)) return acc + item.text;
          return acc;
        }, "") : "";
        const annotations = _isArray(block.citationsContent.citations) ? block.citationsContent.citations.reduce((acc, item) => {
          if (_isObject(item)) {
            const citedText = _isArray(item.sourceContent) ? item.sourceContent.reduce((acc$1, item$1) => {
              if (_isObject(item$1) && _isString(item$1.text)) return acc$1 + item$1.text;
              return acc$1;
            }, "") : "";
            const properties = iife(() => {
              if (_isObject(item.location)) {
                const location2 = item.location.documentChar || item.location.documentPage || item.location.documentChunk;
                if (_isObject(location2)) return {
                  source: _isNumber(location2.documentIndex) ? location2.documentIndex.toString() : void 0,
                  startIndex: _isNumber(location2.start) ? location2.start : void 0,
                  endIndex: _isNumber(location2.end) ? location2.end : void 0
                };
              }
              return {};
            });
            acc.push({
              type: "citation",
              citedText,
              ...properties
            });
          }
          return acc;
        }, []) : [];
        yield {
          type: "text",
          text: text2,
          annotations
        };
        continue;
      } else if (_isContentBlock(block, "document") && _isObject(block.document)) {
        yield convertConverseDocumentBlock(block);
        continue;
      } else if (_isContentBlock(block, "guard_content")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "image") && _isObject(block.image)) {
        yield convertConverseImageBlock(block);
        continue;
      } else if (_isContentBlock(block, "reasoning_content") && _isString(block.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: block.reasoningText
        };
        continue;
      } else if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "tool_result")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_call")) continue;
      else if (_isContentBlock(block, "video") && _isObject(block.video)) {
        yield convertConverseVideoBlock(block);
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatBedrockConverseTranslator;
var init_bedrock_converse = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.js"() {
    init_utils();
    ChatBedrockConverseTranslator = {
      translateContent: convertToV1FromChatBedrockConverseMessage,
      translateContentChunk: convertToV1FromChatBedrockConverseMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/deepseek.js
function convertToV1FromDeepSeekMessage(message) {
  const blocks2 = [];
  const reasoningContent = message.additional_kwargs?.reasoning_content;
  if (_isString(reasoningContent) && reasoningContent.length > 0) blocks2.push({
    type: "reasoning",
    reasoning: reasoningContent
  });
  if (typeof message.content === "string") {
    if (message.content.length > 0) blocks2.push({
      type: "text",
      text: message.content
    });
  } else for (const block of message.content) if (typeof block === "object" && "type" in block && block.type === "text" && "text" in block && _isString(block.text)) blocks2.push({
    type: "text",
    text: block.text
  });
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
var ChatDeepSeekTranslator;
var init_deepseek = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/deepseek.js"() {
    init_utils();
    ChatDeepSeekTranslator = {
      translateContent: convertToV1FromDeepSeekMessage,
      translateContentChunk: convertToV1FromDeepSeekMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/google_genai.js
function convertToV1FromChatGoogleMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "thinking") && _isString(block.thinking)) {
        yield {
          type: "reasoning",
          reasoning: block.thinking,
          ...block.signature ? { signature: block.signature } : {}
        };
        continue;
      } else if (_isContentBlock(block, "inlineData") && _isObject(block.inlineData) && _isString(block.inlineData.mimeType) && _isString(block.inlineData.data)) {
        yield {
          type: "file",
          mimeType: block.inlineData.mimeType,
          data: block.inlineData.data
        };
        continue;
      } else if (_isContentBlock(block, "functionCall") && _isObject(block.functionCall) && _isString(block.functionCall.name) && _isObject(block.functionCall.args)) {
        yield {
          type: "tool_call",
          id: message.id,
          name: block.functionCall.name,
          args: block.functionCall.args
        };
        continue;
      } else if (_isContentBlock(block, "functionResponse")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "fileData") && _isObject(block.fileData) && _isString(block.fileData.mimeType) && _isString(block.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: block.fileData.mimeType,
          fileId: block.fileData.fileUri
        };
        continue;
      } else if (_isContentBlock(block, "executableCode")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatGoogleGenAITranslator;
var init_google_genai = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/google_genai.js"() {
    init_utils();
    ChatGoogleGenAITranslator = {
      translateContent: convertToV1FromChatGoogleMessage,
      translateContentChunk: convertToV1FromChatGoogleMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.js
function convertToV1FromChatVertexMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "reasoning") && _isString(block.reasoning)) {
        const signature = iife(() => {
          const reasoningIndex = content.indexOf(block);
          if (_isArray(message.additional_kwargs?.signatures) && reasoningIndex >= 0) return message.additional_kwargs.signatures.at(reasoningIndex);
          return void 0;
        });
        if (_isString(signature)) yield {
          type: "reasoning",
          reasoning: block.reasoning,
          signature
        };
        else yield {
          type: "reasoning",
          reasoning: block.reasoning
        };
        continue;
      } else if (_isContentBlock(block, "thinking") && _isString(block.thinking)) {
        yield {
          type: "reasoning",
          reasoning: block.thinking,
          ...block.signature ? { signature: block.signature } : {}
        };
        continue;
      } else if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "image_url")) {
        if (_isString(block.image_url)) if (block.image_url.startsWith("data:")) {
          const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;
          const match = block.image_url.match(dataUrlRegex);
          if (match) yield {
            type: "image",
            data: match[2],
            mimeType: match[1]
          };
          else yield {
            type: "image",
            url: block.image_url
          };
        } else yield {
          type: "image",
          url: block.image_url
        };
        continue;
      } else if (_isContentBlock(block, "media") && _isString(block.mimeType) && _isString(block.data)) {
        yield {
          type: "file",
          mimeType: block.mimeType,
          data: block.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatVertexTranslator;
var init_google_vertexai = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.js"() {
    init_utils();
    ChatVertexTranslator = {
      translateContent: convertToV1FromChatVertexMessage,
      translateContentChunk: convertToV1FromChatVertexMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/groq.js
function convertToV1FromGroqMessage(message) {
  const blocks2 = [];
  const parsedReasoning = message.additional_kwargs?.reasoning;
  if (_isString(parsedReasoning) && parsedReasoning.length > 0) blocks2.push({
    type: "reasoning",
    reasoning: parsedReasoning
  });
  if (typeof message.content === "string") {
    let textContent = message.content;
    const thinkMatch = textContent.match(/<think>([\s\S]*?)<\/think>/);
    if (thinkMatch) {
      const thinkingContent = thinkMatch[1].trim();
      if (thinkingContent.length > 0) blocks2.push({
        type: "reasoning",
        reasoning: thinkingContent
      });
      textContent = textContent.replace(/<think>[\s\S]*?<\/think>/, "").trim();
    }
    if (textContent.length > 0) blocks2.push({
      type: "text",
      text: textContent
    });
  } else for (const block of message.content) if (typeof block === "object" && "type" in block && block.type === "text" && "text" in block && _isString(block.text)) {
    let textContent = block.text;
    const thinkMatch = textContent.match(/<think>([\s\S]*?)<\/think>/);
    if (thinkMatch) {
      const thinkingContent = thinkMatch[1].trim();
      if (thinkingContent.length > 0) blocks2.push({
        type: "reasoning",
        reasoning: thinkingContent
      });
      textContent = textContent.replace(/<think>[\s\S]*?<\/think>/, "").trim();
    }
    if (textContent.length > 0) blocks2.push({
      type: "text",
      text: textContent
    });
  }
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
var ChatGroqTranslator;
var init_groq = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/groq.js"() {
    init_utils();
    ChatGroqTranslator = {
      translateContent: convertToV1FromGroqMessage,
      translateContentChunk: convertToV1FromGroqMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/ollama.js
function convertToV1FromOllamaMessage(message) {
  const blocks2 = [];
  const reasoningContent = message.additional_kwargs?.reasoning_content;
  if (_isString(reasoningContent) && reasoningContent.length > 0) blocks2.push({
    type: "reasoning",
    reasoning: reasoningContent
  });
  if (typeof message.content === "string") {
    if (message.content.length > 0) blocks2.push({
      type: "text",
      text: message.content
    });
  } else for (const block of message.content) if (typeof block === "object" && "type" in block && block.type === "text" && "text" in block && _isString(block.text)) blocks2.push({
    type: "text",
    text: block.text
  });
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
var ChatOllamaTranslator;
var init_ollama = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/ollama.js"() {
    init_utils();
    ChatOllamaTranslator = {
      translateContent: convertToV1FromOllamaMessage,
      translateContentChunk: convertToV1FromOllamaMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/xai.js
function convertToV1FromXAIMessage(message) {
  const blocks2 = [];
  if (_isObject(message.additional_kwargs?.reasoning)) {
    const reasoning = message.additional_kwargs.reasoning;
    if (_isArray(reasoning.summary)) {
      const summaryText = reasoning.summary.reduce((acc, item) => {
        if (_isObject(item) && _isString(item.text)) return `${acc}${item.text}`;
        return acc;
      }, "");
      if (summaryText.length > 0) blocks2.push({
        type: "reasoning",
        reasoning: summaryText
      });
    }
  }
  const reasoningContent = message.additional_kwargs?.reasoning_content;
  if (_isString(reasoningContent) && reasoningContent.length > 0) blocks2.push({
    type: "reasoning",
    reasoning: reasoningContent
  });
  if (typeof message.content === "string") {
    if (message.content.length > 0) blocks2.push({
      type: "text",
      text: message.content
    });
  } else for (const block of message.content) if (typeof block === "object" && "type" in block && block.type === "text" && "text" in block && _isString(block.text)) blocks2.push({
    type: "text",
    text: block.text
  });
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
var ChatXAITranslator;
var init_xai = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/xai.js"() {
    init_utils();
    ChatXAITranslator = {
      translateContent: convertToV1FromXAIMessage,
      translateContentChunk: convertToV1FromXAIMessage
    };
  }
});

// node_modules/@langchain/core/dist/messages/block_translators/index.js
function getTranslator(modelProvider) {
  return globalThis.lc_block_translators_registry.get(modelProvider);
}
var init_block_translators = __esm({
  "node_modules/@langchain/core/dist/messages/block_translators/index.js"() {
    init_anthropic();
    init_openai();
    init_bedrock_converse();
    init_deepseek();
    init_google_genai();
    init_google_vertexai();
    init_groq();
    init_ollama();
    init_xai();
    globalThis.lc_block_translators_registry ??= /* @__PURE__ */ new Map([
      ["anthropic", ChatAnthropicTranslator],
      ["bedrock-converse", ChatBedrockConverseTranslator],
      ["deepseek", ChatDeepSeekTranslator],
      ["google-genai", ChatGoogleGenAITranslator],
      ["google-vertexai", ChatVertexTranslator],
      ["groq", ChatGroqTranslator],
      ["ollama", ChatOllamaTranslator],
      ["openai", ChatOpenAITranslator],
      ["xai", ChatXAITranslator]
    ]);
  }
});

// node_modules/@langchain/core/dist/messages/metadata.js
function mergeResponseMetadata(a, b) {
  const output = _mergeDicts(a, b) ?? {};
  return output;
}
function mergeModalitiesTokenDetails(a, b) {
  const output = {};
  if (a?.audio !== void 0 || b?.audio !== void 0) output.audio = (a?.audio ?? 0) + (b?.audio ?? 0);
  if (a?.image !== void 0 || b?.image !== void 0) output.image = (a?.image ?? 0) + (b?.image ?? 0);
  if (a?.video !== void 0 || b?.video !== void 0) output.video = (a?.video ?? 0) + (b?.video ?? 0);
  if (a?.document !== void 0 || b?.document !== void 0) output.document = (a?.document ?? 0) + (b?.document ?? 0);
  if (a?.text !== void 0 || b?.text !== void 0) output.text = (a?.text ?? 0) + (b?.text ?? 0);
  return output;
}
function mergeInputTokenDetails(a, b) {
  const output = { ...mergeModalitiesTokenDetails(a, b) };
  if (a?.cache_read !== void 0 || b?.cache_read !== void 0) output.cache_read = (a?.cache_read ?? 0) + (b?.cache_read ?? 0);
  if (a?.cache_creation !== void 0 || b?.cache_creation !== void 0) output.cache_creation = (a?.cache_creation ?? 0) + (b?.cache_creation ?? 0);
  return output;
}
function mergeOutputTokenDetails(a, b) {
  const output = { ...mergeModalitiesTokenDetails(a, b) };
  if (a?.reasoning !== void 0 || b?.reasoning !== void 0) output.reasoning = (a?.reasoning ?? 0) + (b?.reasoning ?? 0);
  return output;
}
function mergeUsageMetadata(a, b) {
  return {
    input_tokens: (a?.input_tokens ?? 0) + (b?.input_tokens ?? 0),
    output_tokens: (a?.output_tokens ?? 0) + (b?.output_tokens ?? 0),
    total_tokens: (a?.total_tokens ?? 0) + (b?.total_tokens ?? 0),
    input_token_details: mergeInputTokenDetails(a?.input_token_details, b?.input_token_details),
    output_token_details: mergeOutputTokenDetails(a?.output_token_details, b?.output_token_details)
  };
}
var init_metadata = __esm({
  "node_modules/@langchain/core/dist/messages/metadata.js"() {
    init_base();
  }
});

// node_modules/@langchain/core/dist/messages/ai.js
function isAIMessage(x) {
  return x._getType() === "ai";
}
function isAIMessageChunk(x) {
  return x._getType() === "ai";
}
var AIMessage, AIMessageChunk;
var init_ai = __esm({
  "node_modules/@langchain/core/dist/messages/ai.js"() {
    init_base();
    init_block_translators();
    init_metadata();
    init_tool();
    init_utils3();
    AIMessage = class extends BaseMessage {
      type = "ai";
      tool_calls = [];
      invalid_tool_calls = [];
      usage_metadata;
      get lc_aliases() {
        return {
          ...super.lc_aliases,
          tool_calls: "tool_calls",
          invalid_tool_calls: "invalid_tool_calls"
        };
      }
      constructor(fields) {
        let initParams;
        if (typeof fields === "string" || Array.isArray(fields)) initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          additional_kwargs: {}
        };
        else {
          initParams = fields;
          const rawToolCalls = initParams.additional_kwargs?.tool_calls;
          const toolCalls = initParams.tool_calls;
          if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === void 0 || toolCalls.length === 0)) console.warn([
            "New LangChain packages are available that more efficiently handle",
            "tool calling.\n\nPlease upgrade your packages to versions that set",
            "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
            "pnpm install @langchain/openai`, etc."
          ].join(" "));
          try {
            if (!(rawToolCalls == null) && toolCalls === void 0) {
              const [parsedToolCalls, invalidToolCalls] = defaultToolCallParser(rawToolCalls);
              initParams.tool_calls = parsedToolCalls ?? [];
              initParams.invalid_tool_calls = invalidToolCalls ?? [];
            } else {
              initParams.tool_calls = initParams.tool_calls ?? [];
              initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];
            }
          } catch {
            initParams.tool_calls = [];
            initParams.invalid_tool_calls = [];
          }
          if (initParams.response_metadata !== void 0 && "output_version" in initParams.response_metadata && initParams.response_metadata.output_version === "v1") {
            initParams.contentBlocks = initParams.content;
            initParams.content = void 0;
          }
          if (initParams.contentBlocks !== void 0) {
            if (initParams.tool_calls) initParams.contentBlocks.push(...initParams.tool_calls.map((toolCall) => ({
              type: "tool_call",
              id: toolCall.id,
              name: toolCall.name,
              args: toolCall.args
            })));
            const missingToolCalls = initParams.contentBlocks.filter((block) => block.type === "tool_call").filter((block) => !initParams.tool_calls?.some((toolCall) => toolCall.id === block.id && toolCall.name === block.name));
            if (missingToolCalls.length > 0) initParams.tool_calls = missingToolCalls.map((block) => ({
              type: "tool_call",
              id: block.id,
              name: block.name,
              args: block.args
            }));
          }
        }
        super(initParams);
        if (typeof initParams !== "string") {
          this.tool_calls = initParams.tool_calls ?? this.tool_calls;
          this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
        }
        this.usage_metadata = initParams.usage_metadata;
      }
      static lc_name() {
        return "AIMessage";
      }
      get contentBlocks() {
        if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
        if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
          const translator = getTranslator(this.response_metadata.model_provider);
          if (translator) return translator.translateContent(this);
        }
        const blocks2 = super.contentBlocks;
        if (this.tool_calls) {
          const missingToolCalls = this.tool_calls.filter((block) => !blocks2.some((b) => b.id === block.id && b.name === block.name));
          blocks2.push(...missingToolCalls.map((block) => ({
            type: "tool_call",
            id: block.id,
            name: block.name,
            args: block.args
          })));
        }
        return blocks2;
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_calls: this.tool_calls,
          invalid_tool_calls: this.invalid_tool_calls,
          usage_metadata: this.usage_metadata
        };
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "ai";
      }
    };
    AIMessageChunk = class extends BaseMessageChunk {
      type = "ai";
      tool_calls = [];
      invalid_tool_calls = [];
      tool_call_chunks = [];
      usage_metadata;
      constructor(fields) {
        let initParams;
        if (typeof fields === "string" || Array.isArray(fields)) initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          tool_call_chunks: []
        };
        else if (fields.tool_call_chunks === void 0 || fields.tool_call_chunks.length === 0) initParams = {
          ...fields,
          tool_calls: fields.tool_calls ?? [],
          invalid_tool_calls: [],
          tool_call_chunks: [],
          usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
        };
        else {
          const collapsed = collapseToolCallChunks(fields.tool_call_chunks ?? []);
          initParams = {
            ...fields,
            tool_call_chunks: collapsed.tool_call_chunks,
            tool_calls: collapsed.tool_calls,
            invalid_tool_calls: collapsed.invalid_tool_calls,
            usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
          };
        }
        super(initParams);
        this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
        this.tool_calls = initParams.tool_calls ?? this.tool_calls;
        this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
        this.usage_metadata = initParams.usage_metadata;
      }
      get lc_aliases() {
        return {
          ...super.lc_aliases,
          tool_calls: "tool_calls",
          invalid_tool_calls: "invalid_tool_calls",
          tool_call_chunks: "tool_call_chunks"
        };
      }
      static lc_name() {
        return "AIMessageChunk";
      }
      get contentBlocks() {
        if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
        if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
          const translator = getTranslator(this.response_metadata.model_provider);
          if (translator) return translator.translateContent(this);
        }
        const blocks2 = super.contentBlocks;
        if (this.tool_calls) {
          if (typeof this.content !== "string") {
            const contentToolCalls = this.content.filter((block) => block.type === "tool_call").map((block) => block.id);
            for (const toolCall of this.tool_calls) if (toolCall.id && !contentToolCalls.includes(toolCall.id)) blocks2.push({
              ...toolCall,
              type: "tool_call",
              id: toolCall.id,
              name: toolCall.name,
              args: toolCall.args
            });
          }
        }
        return blocks2;
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_calls: this.tool_calls,
          tool_call_chunks: this.tool_call_chunks,
          invalid_tool_calls: this.invalid_tool_calls,
          usage_metadata: this.usage_metadata
        };
      }
      concat(chunk) {
        const combinedFields = {
          content: mergeContent(this.content, chunk.content),
          additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: mergeResponseMetadata(this.response_metadata, chunk.response_metadata),
          tool_call_chunks: [],
          id: this.id ?? chunk.id
        };
        if (this.tool_call_chunks !== void 0 || chunk.tool_call_chunks !== void 0) {
          const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
          if (rawToolCalls !== void 0 && rawToolCalls.length > 0) combinedFields.tool_call_chunks = rawToolCalls;
        }
        if (this.usage_metadata !== void 0 || chunk.usage_metadata !== void 0) combinedFields.usage_metadata = mergeUsageMetadata(this.usage_metadata, chunk.usage_metadata);
        const Cls = this.constructor;
        return new Cls(combinedFields);
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "ai";
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/utils.js
function _coerceToolCall(toolCall) {
  if (_isToolCall(toolCall)) return toolCall;
  else if (typeof toolCall.id === "string" && toolCall.type === "function" && typeof toolCall.function === "object" && toolCall.function !== null && "arguments" in toolCall.function && typeof toolCall.function.arguments === "string" && "name" in toolCall.function && typeof toolCall.function.name === "string") return {
    id: toolCall.id,
    args: JSON.parse(toolCall.function.arguments),
    name: toolCall.function.name,
    type: "tool_call"
  };
  else return toolCall;
}
function isSerializedConstructor(x) {
  return typeof x === "object" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && typeof x.kwargs === "object";
}
function _constructMessageFromParams(params) {
  let type;
  let rest;
  if (isSerializedConstructor(params)) {
    const className = params.id.at(-1);
    if (className === "HumanMessage" || className === "HumanMessageChunk") type = "user";
    else if (className === "AIMessage" || className === "AIMessageChunk") type = "assistant";
    else if (className === "SystemMessage" || className === "SystemMessageChunk") type = "system";
    else if (className === "FunctionMessage" || className === "FunctionMessageChunk") type = "function";
    else if (className === "ToolMessage" || className === "ToolMessageChunk") type = "tool";
    else type = "unknown";
    rest = params.kwargs;
  } else {
    const { type: extractedType, ...otherParams } = params;
    type = extractedType;
    rest = otherParams;
  }
  if (type === "human" || type === "user") return new HumanMessage(rest);
  else if (type === "ai" || type === "assistant") {
    const { tool_calls: rawToolCalls, ...other } = rest;
    if (!Array.isArray(rawToolCalls)) return new AIMessage(rest);
    const tool_calls = rawToolCalls.map(_coerceToolCall);
    return new AIMessage({
      ...other,
      tool_calls
    });
  } else if (type === "system") return new SystemMessage(rest);
  else if (type === "developer") return new SystemMessage({
    ...rest,
    additional_kwargs: {
      ...rest.additional_kwargs,
      __openai_role__: "developer"
    }
  });
  else if (type === "tool" && "tool_call_id" in rest) return new ToolMessage({
    ...rest,
    content: rest.content,
    tool_call_id: rest.tool_call_id,
    name: rest.name
  });
  else if (type === "remove" && "id" in rest && typeof rest.id === "string") return new RemoveMessage({
    ...rest,
    id: rest.id
  });
  else {
    const error40 = addLangChainErrorFields(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(params, null, 2)}`), "MESSAGE_COERCION_FAILURE");
    throw error40;
  }
}
function coerceMessageLikeToMessage(messageLike) {
  if (typeof messageLike === "string") return new HumanMessage(messageLike);
  else if (isBaseMessage(messageLike)) return messageLike;
  if (Array.isArray(messageLike)) {
    const [type, content] = messageLike;
    return _constructMessageFromParams({
      type,
      content
    });
  } else if (_isMessageFieldWithRole(messageLike)) {
    const { role: type, ...rest } = messageLike;
    return _constructMessageFromParams({
      ...rest,
      type
    });
  } else return _constructMessageFromParams(messageLike);
}
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m.type === "human") role = humanPrefix;
    else if (m.type === "ai") role = aiPrefix;
    else if (m.type === "system") role = "System";
    else if (m.type === "tool") role = "Tool";
    else if (m.type === "generic") role = m.role;
    else throw new Error(`Got unsupported message type: ${m.type}`);
    const nameStr = m.name ? `${m.name}, ` : "";
    const readableContent = m.text;
    let message = `${role}: ${nameStr}${readableContent}`;
    if (m.type === "ai") {
      const aiMessage = m;
      if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) message += JSON.stringify(aiMessage.tool_calls);
      else if (aiMessage.additional_kwargs && "function_call" in aiMessage.additional_kwargs) message += JSON.stringify(aiMessage.additional_kwargs.function_call);
    }
    string_messages.push(message);
  }
  return string_messages.join("\n");
}
function mapV1MessageToStoredMessage(message) {
  if (message.data !== void 0) return message;
  else {
    const v1Message = message;
    return {
      type: v1Message.type,
      data: {
        content: v1Message.text,
        role: v1Message.role,
        name: void 0,
        tool_call_id: void 0
      }
    };
  }
}
function mapStoredMessageToChatMessage(message) {
  const storedMessage = mapV1MessageToStoredMessage(message);
  switch (storedMessage.type) {
    case "human":
      return new HumanMessage(storedMessage.data);
    case "ai":
      return new AIMessage(storedMessage.data);
    case "system":
      return new SystemMessage(storedMessage.data);
    case "function":
      if (storedMessage.data.name === void 0) throw new Error("Name must be defined for function messages");
      return new FunctionMessage(storedMessage.data);
    case "tool":
      if (storedMessage.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
      return new ToolMessage(storedMessage.data);
    case "generic":
      if (storedMessage.data.role === void 0) throw new Error("Role must be defined for chat messages");
      return new ChatMessage(storedMessage.data);
    default:
      throw new Error(`Got unexpected type: ${storedMessage.type}`);
  }
}
function mapStoredMessagesToChatMessages(messages) {
  return messages.map(mapStoredMessageToChatMessage);
}
function mapChatMessagesToStoredMessages(messages) {
  return messages.map((message) => message.toDict());
}
function convertToChunk(message) {
  const type = message._getType();
  if (type === "human") return new HumanMessageChunk({ ...message });
  else if (type === "ai") {
    let aiChunkFields = { ...message };
    if ("tool_calls" in aiChunkFields) aiChunkFields = {
      ...aiChunkFields,
      tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({
        ...tc,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(tc.args)
      }))
    };
    return new AIMessageChunk({ ...aiChunkFields });
  } else if (type === "system") return new SystemMessageChunk({ ...message });
  else if (type === "function") return new FunctionMessageChunk({ ...message });
  else if (ChatMessage.isInstance(message)) return new ChatMessageChunk({ ...message });
  else throw new Error("Unknown message type.");
}
function collapseToolCallChunks(chunks) {
  const groupedToolCallChunks = chunks.reduce((acc, chunk) => {
    const matchedChunkIndex = acc.findIndex(([match]) => {
      if ("id" in chunk && chunk.id && "index" in chunk && chunk.index !== void 0) return chunk.id === match.id && chunk.index === match.index;
      if ("id" in chunk && chunk.id) return chunk.id === match.id;
      if ("index" in chunk && chunk.index !== void 0) return chunk.index === match.index;
      return false;
    });
    if (matchedChunkIndex !== -1) acc[matchedChunkIndex].push(chunk);
    else acc.push([chunk]);
    return acc;
  }, []);
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const chunks$1 of groupedToolCallChunks) {
    let parsedArgs = null;
    const name = chunks$1[0]?.name ?? "";
    const joinedArgs = chunks$1.map((c) => c.args || "").join("").trim();
    const argsStr = joinedArgs.length ? joinedArgs : "{}";
    const id = chunks$1[0]?.id;
    try {
      parsedArgs = parsePartialJson(argsStr);
      if (!id || parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs)) throw new Error("Malformed tool call chunk args.");
      toolCalls.push({
        name,
        args: parsedArgs,
        id,
        type: "tool_call"
      });
    } catch {
      invalidToolCalls.push({
        name,
        args: argsStr,
        id,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: chunks,
    tool_calls: toolCalls,
    invalid_tool_calls: invalidToolCalls
  };
}
var iife2;
var init_utils3 = __esm({
  "node_modules/@langchain/core/dist/messages/utils.js"() {
    init_base();
    init_tool();
    init_errors2();
    init_utils2();
    init_json();
    init_chat();
    init_function();
    init_human();
    init_modifier();
    init_system();
    init_ai();
    iife2 = (fn) => fn();
  }
});

// node_modules/@langchain/core/dist/utils/env.js
function getRuntimeEnvironment() {
  if (runtimeEnvironment === void 0) {
    const env = getEnv();
    runtimeEnvironment = {
      library: "langchain-js",
      runtime: env
    };
  }
  return runtimeEnvironment;
}
function getEnvironmentVariable(name) {
  try {
    if (typeof process !== "undefined") return process.env?.[name];
    else if (isDeno()) return Deno?.env.get(name);
    else return void 0;
  } catch {
    return void 0;
  }
}
var env_exports, isBrowser, isWebWorker, isJsDom, isDeno, isNode, getEnv, runtimeEnvironment;
var init_env = __esm({
  "node_modules/@langchain/core/dist/utils/env.js"() {
    init_rolldown_runtime();
    env_exports = {};
    __export2(env_exports, {
      getEnv: () => getEnv,
      getEnvironmentVariable: () => getEnvironmentVariable,
      getRuntimeEnvironment: () => getRuntimeEnvironment,
      isBrowser: () => isBrowser,
      isDeno: () => isDeno,
      isJsDom: () => isJsDom,
      isNode: () => isNode,
      isWebWorker: () => isWebWorker
    });
    isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
    isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
    isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
    isDeno = () => typeof Deno !== "undefined";
    isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
    getEnv = () => {
      let env;
      if (isBrowser()) env = "browser";
      else if (isNode()) env = "node";
      else if (isWebWorker()) env = "webworker";
      else if (isJsDom()) env = "jsdom";
      else if (isDeno()) env = "deno";
      else env = "other";
      return env;
    };
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid8) {
  return typeof uuid8 === "string" && regex_default.test(uuid8);
}
var validate_default;
var init_validate = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid8) {
  if (!validate_default(uuid8)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr3 = new Uint8Array(16);
  arr3[0] = (v = parseInt(uuid8.slice(0, 8), 16)) >>> 24;
  arr3[1] = v >>> 16 & 255;
  arr3[2] = v >>> 8 & 255;
  arr3[3] = v & 255;
  arr3[4] = (v = parseInt(uuid8.slice(9, 13), 16)) >>> 8;
  arr3[5] = v & 255;
  arr3[6] = (v = parseInt(uuid8.slice(14, 18), 16)) >>> 8;
  arr3[7] = v & 255;
  arr3[8] = (v = parseInt(uuid8.slice(19, 23), 16)) >>> 8;
  arr3[9] = v & 255;
  arr3[10] = (v = parseInt(uuid8.slice(24, 36), 16)) / 1099511627776 & 255;
  arr3[11] = v / 4294967296 & 255;
  arr3[12] = v >>> 24 & 255;
  arr3[13] = v >>> 16 & 255;
  arr3[14] = v >>> 8 & 255;
  arr3[15] = v & 255;
  return arr3;
}
var parse_default;
var init_parse = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr3, offset = 0) {
  return (byteToHex[arr3[offset + 0]] + byteToHex[arr3[offset + 1]] + byteToHex[arr3[offset + 2]] + byteToHex[arr3[offset + 3]] + "-" + byteToHex[arr3[offset + 4]] + byteToHex[arr3[offset + 5]] + "-" + byteToHex[arr3[offset + 6]] + byteToHex[arr3[offset + 7]] + "-" + byteToHex[arr3[offset + 8]] + byteToHex[arr3[offset + 9]] + "-" + byteToHex[arr3[offset + 10]] + byteToHex[arr3[offset + 11]] + byteToHex[arr3[offset + 12]] + byteToHex[arr3[offset + 13]] + byteToHex[arr3[offset + 14]] + byteToHex[arr3[offset + 15]]).toLowerCase();
}
var byteToHex;
var init_stringify = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js"() {
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js
import crypto2 from "node:crypto";
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str2) {
  str2 = unescape(encodeURIComponent(str2));
  const bytes = [];
  for (let i = 0; i < str2.length; ++i) {
    bytes.push(str2.charCodeAt(i));
  }
  return bytes;
}
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js
import crypto3 from "node:crypto";
var native_default;
var init_native = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js"() {
    native_default = {
      randomUUID: crypto3.randomUUID
    };
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js
import crypto4 from "node:crypto";
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto4.createHash("sha1").update(bytes).digest();
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js
function v7(options, buf, offset) {
  options = options || {};
  let i = buf && offset || 0;
  const b = buf || new Uint8Array(16);
  const rnds = options.random || (options.rng || rng)();
  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let seq = options.seq !== void 0 ? options.seq : null;
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;
  if (msecs > _msecs && options.msecs === void 0) {
    _msecs = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs++;
      }
    }
  } else {
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;
  b[i++] = _msecs / 1099511627776 & 255;
  b[i++] = _msecs / 4294967296 & 255;
  b[i++] = _msecs / 16777216 & 255;
  b[i++] = _msecs / 65536 & 255;
  b[i++] = _msecs / 256 & 255;
  b[i++] = _msecs & 255;
  b[i++] = seqHigh >>> 4 & 15 | 112;
  b[i++] = seqHigh & 255;
  b[i++] = seqLow >>> 13 & 63 | 128;
  b[i++] = seqLow >>> 5 & 255;
  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i++] = rnds[11];
  b[i++] = rnds[12];
  b[i++] = rnds[13];
  b[i++] = rnds[14];
  b[i++] = rnds[15];
  return buf || unsafeStringify(b);
}
var _seqLow, _seqHigh, _msecs, v7_default;
var init_v7 = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js"() {
    init_rng();
    init_stringify();
    _seqLow = null;
    _seqHigh = null;
    _msecs = 0;
    v7_default = v7;
  }
});

// node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js"() {
    init_v4();
    init_v5();
    init_v7();
    init_validate();
  }
});

// node_modules/@langchain/core/dist/callbacks/base.js
function callbackHandlerPrefersStreaming(x) {
  return "lc_prefer_streaming" in x && x.lc_prefer_streaming;
}
var base_exports, BaseCallbackHandlerMethodsClass, BaseCallbackHandler, isBaseCallbackHandler;
var init_base2 = __esm({
  "node_modules/@langchain/core/dist/callbacks/base.js"() {
    init_rolldown_runtime();
    init_serializable();
    init_env();
    init_esm_node();
    base_exports = {};
    __export2(base_exports, {
      BaseCallbackHandler: () => BaseCallbackHandler,
      callbackHandlerPrefersStreaming: () => callbackHandlerPrefersStreaming,
      isBaseCallbackHandler: () => isBaseCallbackHandler
    });
    BaseCallbackHandlerMethodsClass = class {
    };
    BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
      lc_serializable = false;
      get lc_namespace() {
        return [
          "langchain_core",
          "callbacks",
          this.name
        ];
      }
      get lc_secrets() {
        return void 0;
      }
      get lc_attributes() {
        return void 0;
      }
      get lc_aliases() {
        return void 0;
      }
      get lc_serializable_keys() {
        return void 0;
      }
      /**
      * The name of the serializable. Override to provide an alias or
      * to preserve the serialized module name in minified environments.
      *
      * Implemented as a static method to support loading logic.
      */
      static lc_name() {
        return this.name;
      }
      /**
      * The final serialized identifier for the module.
      */
      get lc_id() {
        return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
      }
      lc_kwargs;
      ignoreLLM = false;
      ignoreChain = false;
      ignoreAgent = false;
      ignoreRetriever = false;
      ignoreCustomEvent = false;
      raiseError = false;
      awaitHandlers = getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false";
      constructor(input) {
        super();
        this.lc_kwargs = input || {};
        if (input) {
          this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
          this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
          this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
          this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
          this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
          this.raiseError = input.raiseError ?? this.raiseError;
          this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
        }
      }
      copy() {
        return new this.constructor(this);
      }
      toJSON() {
        return Serializable.prototype.toJSON.call(this);
      }
      toJSONNotImplemented() {
        return Serializable.prototype.toJSONNotImplemented.call(this);
      }
      static fromMethods(methods) {
        class Handler extends BaseCallbackHandler {
          name = v7_default();
          constructor() {
            super();
            Object.assign(this, methods);
          }
        }
        return new Handler();
      }
    };
    isBaseCallbackHandler = (x) => {
      const callbackHandler = x;
      return callbackHandler !== void 0 && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
    };
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js
var regex_default2;
var init_regex2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js
function validate2(uuid8) {
  return typeof uuid8 === "string" && regex_default2.test(uuid8);
}
var validate_default2;
var init_validate2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex2();
    validate_default2 = validate2;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js
function parse2(uuid8) {
  if (!validate_default2(uuid8)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr3 = new Uint8Array(16);
  arr3[0] = (v = parseInt(uuid8.slice(0, 8), 16)) >>> 24;
  arr3[1] = v >>> 16 & 255;
  arr3[2] = v >>> 8 & 255;
  arr3[3] = v & 255;
  arr3[4] = (v = parseInt(uuid8.slice(9, 13), 16)) >>> 8;
  arr3[5] = v & 255;
  arr3[6] = (v = parseInt(uuid8.slice(14, 18), 16)) >>> 8;
  arr3[7] = v & 255;
  arr3[8] = (v = parseInt(uuid8.slice(19, 23), 16)) >>> 8;
  arr3[9] = v & 255;
  arr3[10] = (v = parseInt(uuid8.slice(24, 36), 16)) / 1099511627776 & 255;
  arr3[11] = v / 4294967296 & 255;
  arr3[12] = v >>> 24 & 255;
  arr3[13] = v >>> 16 & 255;
  arr3[14] = v >>> 8 & 255;
  arr3[15] = v & 255;
  return arr3;
}
var parse_default2;
var init_parse2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate2();
    parse_default2 = parse2;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify2(arr3, offset = 0) {
  return (byteToHex2[arr3[offset + 0]] + byteToHex2[arr3[offset + 1]] + byteToHex2[arr3[offset + 2]] + byteToHex2[arr3[offset + 3]] + "-" + byteToHex2[arr3[offset + 4]] + byteToHex2[arr3[offset + 5]] + "-" + byteToHex2[arr3[offset + 6]] + byteToHex2[arr3[offset + 7]] + "-" + byteToHex2[arr3[offset + 8]] + byteToHex2[arr3[offset + 9]] + "-" + byteToHex2[arr3[offset + 10]] + byteToHex2[arr3[offset + 11]] + byteToHex2[arr3[offset + 12]] + byteToHex2[arr3[offset + 13]] + byteToHex2[arr3[offset + 14]] + byteToHex2[arr3[offset + 15]]).toLowerCase();
}
var byteToHex2;
var init_stringify2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js"() {
    byteToHex2 = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex2.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js
import crypto5 from "node:crypto";
function rng2() {
  if (poolPtr2 > rnds8Pool2.length - 16) {
    crypto5.randomFillSync(rnds8Pool2);
    poolPtr2 = 0;
  }
  return rnds8Pool2.slice(poolPtr2, poolPtr2 += 16);
}
var rnds8Pool2, poolPtr2;
var init_rng2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool2 = new Uint8Array(256);
    poolPtr2 = rnds8Pool2.length;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes2(str2) {
  str2 = unescape(encodeURIComponent(str2));
  const bytes = [];
  for (let i = 0; i < str2.length; ++i) {
    bytes.push(str2.charCodeAt(i));
  }
  return bytes;
}
function v352(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes2(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default2(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify2(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS2;
  generateUUID.URL = URL3;
  return generateUUID;
}
var DNS2, URL3;
var init_v352 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify2();
    init_parse2();
    DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js
import crypto6 from "node:crypto";
var native_default2;
var init_native2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js"() {
    native_default2 = {
      randomUUID: crypto6.randomUUID
    };
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js
function v42(options, buf, offset) {
  if (native_default2.randomUUID && !buf && !options) {
    return native_default2.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify2(rnds);
}
var v4_default2;
var init_v42 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js"() {
    init_native2();
    init_rng2();
    init_stringify2();
    v4_default2 = v42;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js
import crypto7 from "node:crypto";
function sha12(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto7.createHash("sha1").update(bytes).digest();
}
var sha1_default2;
var init_sha12 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js"() {
    sha1_default2 = sha12;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js
var v52, v5_default2;
var init_v52 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v352();
    init_sha12();
    v52 = v352("v5", 80, sha1_default2);
    v5_default2 = v52;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js
function v72(options, buf, offset) {
  options = options || {};
  let i = buf && offset || 0;
  const b = buf || new Uint8Array(16);
  const rnds = options.random || (options.rng || rng2)();
  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let seq = options.seq !== void 0 ? options.seq : null;
  let seqHigh = _seqHigh2;
  let seqLow = _seqLow2;
  if (msecs > _msecs2 && options.msecs === void 0) {
    _msecs2 = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs2 && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs2++;
      }
    }
  } else {
    _msecs2 = msecs;
  }
  _seqHigh2 = seqHigh;
  _seqLow2 = seqLow;
  b[i++] = _msecs2 / 1099511627776 & 255;
  b[i++] = _msecs2 / 4294967296 & 255;
  b[i++] = _msecs2 / 16777216 & 255;
  b[i++] = _msecs2 / 65536 & 255;
  b[i++] = _msecs2 / 256 & 255;
  b[i++] = _msecs2 & 255;
  b[i++] = seqHigh >>> 4 & 15 | 112;
  b[i++] = seqHigh & 255;
  b[i++] = seqLow >>> 13 & 63 | 128;
  b[i++] = seqLow >>> 5 & 255;
  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i++] = rnds[11];
  b[i++] = rnds[12];
  b[i++] = rnds[13];
  b[i++] = rnds[14];
  b[i++] = rnds[15];
  return buf || unsafeStringify2(b);
}
var _seqLow2, _seqHigh2, _msecs2, v7_default2;
var init_v72 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js"() {
    init_rng2();
    init_stringify2();
    _seqLow2 = null;
    _seqHigh2 = null;
    _msecs2 = 0;
    v7_default2 = v72;
  }
});

// node_modules/langsmith/node_modules/uuid/dist/esm-node/index.js
var init_esm_node2 = __esm({
  "node_modules/langsmith/node_modules/uuid/dist/esm-node/index.js"() {
    init_v42();
    init_v52();
    init_v72();
  }
});

// node_modules/langsmith/dist/experimental/otel/constants.js
var GEN_AI_OPERATION_NAME, GEN_AI_SYSTEM, GEN_AI_REQUEST_MODEL, GEN_AI_RESPONSE_MODEL, GEN_AI_USAGE_INPUT_TOKENS, GEN_AI_USAGE_OUTPUT_TOKENS, GEN_AI_USAGE_TOTAL_TOKENS, GEN_AI_REQUEST_MAX_TOKENS, GEN_AI_REQUEST_TEMPERATURE, GEN_AI_REQUEST_TOP_P, GEN_AI_REQUEST_FREQUENCY_PENALTY, GEN_AI_REQUEST_PRESENCE_PENALTY, GEN_AI_RESPONSE_FINISH_REASONS, GENAI_PROMPT, GENAI_COMPLETION, GEN_AI_REQUEST_EXTRA_QUERY, GEN_AI_REQUEST_EXTRA_BODY, GEN_AI_SERIALIZED_NAME, GEN_AI_SERIALIZED_SIGNATURE, GEN_AI_SERIALIZED_DOC, GEN_AI_RESPONSE_ID, GEN_AI_RESPONSE_SERVICE_TIER, GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, GEN_AI_USAGE_INPUT_TOKEN_DETAILS, GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, LANGSMITH_SESSION_ID, LANGSMITH_SESSION_NAME, LANGSMITH_RUN_TYPE, LANGSMITH_NAME, LANGSMITH_METADATA, LANGSMITH_TAGS, LANGSMITH_REQUEST_STREAMING, LANGSMITH_REQUEST_HEADERS;
var init_constants = __esm({
  "node_modules/langsmith/dist/experimental/otel/constants.js"() {
    GEN_AI_OPERATION_NAME = "gen_ai.operation.name";
    GEN_AI_SYSTEM = "gen_ai.system";
    GEN_AI_REQUEST_MODEL = "gen_ai.request.model";
    GEN_AI_RESPONSE_MODEL = "gen_ai.response.model";
    GEN_AI_USAGE_INPUT_TOKENS = "gen_ai.usage.input_tokens";
    GEN_AI_USAGE_OUTPUT_TOKENS = "gen_ai.usage.output_tokens";
    GEN_AI_USAGE_TOTAL_TOKENS = "gen_ai.usage.total_tokens";
    GEN_AI_REQUEST_MAX_TOKENS = "gen_ai.request.max_tokens";
    GEN_AI_REQUEST_TEMPERATURE = "gen_ai.request.temperature";
    GEN_AI_REQUEST_TOP_P = "gen_ai.request.top_p";
    GEN_AI_REQUEST_FREQUENCY_PENALTY = "gen_ai.request.frequency_penalty";
    GEN_AI_REQUEST_PRESENCE_PENALTY = "gen_ai.request.presence_penalty";
    GEN_AI_RESPONSE_FINISH_REASONS = "gen_ai.response.finish_reasons";
    GENAI_PROMPT = "gen_ai.prompt";
    GENAI_COMPLETION = "gen_ai.completion";
    GEN_AI_REQUEST_EXTRA_QUERY = "gen_ai.request.extra_query";
    GEN_AI_REQUEST_EXTRA_BODY = "gen_ai.request.extra_body";
    GEN_AI_SERIALIZED_NAME = "gen_ai.serialized.name";
    GEN_AI_SERIALIZED_SIGNATURE = "gen_ai.serialized.signature";
    GEN_AI_SERIALIZED_DOC = "gen_ai.serialized.doc";
    GEN_AI_RESPONSE_ID = "gen_ai.response.id";
    GEN_AI_RESPONSE_SERVICE_TIER = "gen_ai.response.service_tier";
    GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = "gen_ai.response.system_fingerprint";
    GEN_AI_USAGE_INPUT_TOKEN_DETAILS = "gen_ai.usage.input_token_details";
    GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = "gen_ai.usage.output_token_details";
    LANGSMITH_SESSION_ID = "langsmith.trace.session_id";
    LANGSMITH_SESSION_NAME = "langsmith.trace.session_name";
    LANGSMITH_RUN_TYPE = "langsmith.span.kind";
    LANGSMITH_NAME = "langsmith.trace.name";
    LANGSMITH_METADATA = "langsmith.metadata";
    LANGSMITH_TAGS = "langsmith.span.tags";
    LANGSMITH_REQUEST_STREAMING = "langsmith.request.streaming";
    LANGSMITH_REQUEST_HEADERS = "langsmith.request.headers";
  }
});

// node_modules/langsmith/dist/singletons/fetch.js
var DEFAULT_FETCH_IMPLEMENTATION, LANGSMITH_FETCH_IMPLEMENTATION_KEY, _globalFetchImplementationIsNodeFetch, _getFetchImplementation;
var init_fetch = __esm({
  "node_modules/langsmith/dist/singletons/fetch.js"() {
    init_env2();
    DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
    LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
    _globalFetchImplementationIsNodeFetch = () => {
      const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];
      if (!fetchImpl)
        return false;
      return typeof fetchImpl === "function" && "Headers" in fetchImpl && "Request" in fetchImpl && "Response" in fetchImpl;
    };
    _getFetchImplementation = (debug) => {
      return async (...args) => {
        if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
          const [url2, options] = args;
          console.log(`\u2192 ${options?.method || "GET"} ${url2}`);
        }
        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);
        if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
          console.log(`\u2190 ${res.status} ${res.statusText} ${res.url}`);
        }
        return res;
      };
    };
  }
});

// node_modules/langsmith/dist/utils/project.js
var getDefaultProjectName;
var init_project = __esm({
  "node_modules/langsmith/dist/utils/project.js"() {
    init_env2();
    getDefaultProjectName = () => {
      return getLangSmithEnvironmentVariable("PROJECT") ?? getEnvironmentVariable2("LANGCHAIN_SESSION") ?? // TODO: Deprecate
      "default";
    };
  }
});

// node_modules/langsmith/dist/utils/warn.js
function warnOnce(message) {
  if (!warnedMessages[message]) {
    console.warn(message);
    warnedMessages[message] = true;
  }
}
var warnedMessages;
var init_warn = __esm({
  "node_modules/langsmith/dist/utils/warn.js"() {
    warnedMessages = {};
  }
});

// node_modules/langsmith/dist/utils/_uuid.js
function assertUuid(str2, which) {
  if (!UUID_REGEX.test(str2)) {
    const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str2}` : `Invalid UUID: ${str2}`;
    throw new Error(msg);
  }
  return str2;
}
function uuid7FromTime(timestamp2) {
  const msecs = typeof timestamp2 === "string" ? Date.parse(timestamp2) : timestamp2;
  return v7_default2({ msecs, seq: 0 });
}
var UUID_REGEX;
var init_uuid = __esm({
  "node_modules/langsmith/dist/utils/_uuid.js"() {
    init_esm_node2();
    init_warn();
    UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  }
});

// node_modules/langsmith/dist/uuid.js
var init_uuid2 = __esm({
  "node_modules/langsmith/dist/uuid.js"() {
    init_uuid();
  }
});

// node_modules/langsmith/dist/utils/prompts_cache_fs.js
import * as fs from "node:fs";
import * as path from "node:path";
function dumpCache(filePath, entries) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  const data = { entries };
  const tempPath = `${filePath}.tmp`;
  try {
    fs.writeFileSync(tempPath, JSON.stringify(data, null, 2));
    fs.renameSync(tempPath, filePath);
  } catch (e) {
    if (fs.existsSync(tempPath)) {
      fs.unlinkSync(tempPath);
    }
    throw e;
  }
}
function loadCache(filePath) {
  if (!fs.existsSync(filePath)) {
    return null;
  }
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    const data = JSON.parse(content);
    return data.entries ?? null;
  } catch {
    return null;
  }
}
var init_prompts_cache_fs = __esm({
  "node_modules/langsmith/dist/utils/prompts_cache_fs.js"() {
  }
});

// node_modules/langsmith/dist/utils/prompts_cache.js
function isStale(entry, ttlSeconds) {
  if (ttlSeconds === null) {
    return false;
  }
  const ageMs = Date.now() - entry.createdAt;
  return ageMs > ttlSeconds * 1e3;
}
var Cache;
var init_prompts_cache = __esm({
  "node_modules/langsmith/dist/utils/prompts_cache.js"() {
    init_prompts_cache_fs();
    Cache = class {
      constructor(config2 = {}) {
        Object.defineProperty(this, "cache", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        Object.defineProperty(this, "maxSize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "ttlSeconds", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "refreshIntervalSeconds", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "fetchFunc", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "refreshTimer", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_metrics", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: {
            hits: 0,
            misses: 0,
            refreshes: 0,
            refreshErrors: 0
          }
        });
        this.maxSize = config2.maxSize ?? 100;
        this.ttlSeconds = config2.ttlSeconds ?? 3600;
        this.refreshIntervalSeconds = config2.refreshIntervalSeconds ?? 60;
        this.fetchFunc = config2.fetchFunc;
        if (this.fetchFunc && this.ttlSeconds !== null) {
          this.startRefreshLoop();
        }
      }
      /**
       * Get cache performance metrics.
       */
      get metrics() {
        return { ...this._metrics };
      }
      /**
       * Get total cache requests (hits + misses).
       */
      get totalRequests() {
        return this._metrics.hits + this._metrics.misses;
      }
      /**
       * Get cache hit rate (0.0 to 1.0).
       */
      get hitRate() {
        const total = this.totalRequests;
        return total > 0 ? this._metrics.hits / total : 0;
      }
      /**
       * Reset all metrics to zero.
       */
      resetMetrics() {
        this._metrics = {
          hits: 0,
          misses: 0,
          refreshes: 0,
          refreshErrors: 0
        };
      }
      /**
       * Get a value from cache.
       *
       * Returns the cached value or undefined if not found.
       * Stale entries are still returned (background refresh handles updates).
       */
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
          this._metrics.misses += 1;
          return void 0;
        }
        this.cache.delete(key);
        this.cache.set(key, entry);
        this._metrics.hits += 1;
        return entry.value;
      }
      /**
       * Set a value in the cache.
       */
      set(key, value) {
        if (!this.cache.has(key) && this.cache.size >= this.maxSize) {
          const oldestKey = this.cache.keys().next().value;
          if (oldestKey !== void 0) {
            this.cache.delete(oldestKey);
          }
        }
        const entry = {
          value,
          createdAt: Date.now()
        };
        this.cache.delete(key);
        this.cache.set(key, entry);
      }
      /**
       * Remove a specific entry from cache.
       */
      invalidate(key) {
        this.cache.delete(key);
      }
      /**
       * Clear all cache entries.
       */
      clear() {
        this.cache.clear();
      }
      /**
       * Get the number of entries in the cache.
       */
      get size() {
        return this.cache.size;
      }
      /**
       * Stop background refresh.
       * Should be called when the client is being cleaned up.
       */
      stop() {
        if (this.refreshTimer) {
          clearInterval(this.refreshTimer);
          this.refreshTimer = void 0;
        }
      }
      /**
       * Dump cache contents to a JSON file for offline use.
       */
      dump(filePath) {
        const entries = {};
        for (const [key, entry] of this.cache.entries()) {
          entries[key] = entry.value;
        }
        dumpCache(filePath, entries);
      }
      /**
       * Load cache contents from a JSON file.
       *
       * Loaded entries get a fresh TTL starting from load time.
       *
       * @returns Number of entries loaded.
       */
      load(filePath) {
        const entries = loadCache(filePath);
        if (!entries) {
          return 0;
        }
        let loaded = 0;
        const now = Date.now();
        for (const [key, value] of Object.entries(entries)) {
          if (this.cache.size >= this.maxSize) {
            break;
          }
          const entry = {
            value,
            createdAt: now
            // Fresh TTL from load time
          };
          this.cache.set(key, entry);
          loaded += 1;
        }
        return loaded;
      }
      /**
       * Start the background refresh loop.
       */
      startRefreshLoop() {
        this.refreshTimer = setInterval(() => {
          this.refreshStaleEntries().catch((e) => {
            console.warn("Unexpected error in cache refresh loop:", e);
          });
        }, this.refreshIntervalSeconds * 1e3);
        if (this.refreshTimer.unref) {
          this.refreshTimer.unref();
        }
      }
      /**
       * Get list of stale cache keys.
       */
      getStaleKeys() {
        const staleKeys = [];
        for (const [key, entry] of this.cache.entries()) {
          if (isStale(entry, this.ttlSeconds)) {
            staleKeys.push(key);
          }
        }
        return staleKeys;
      }
      /**
       * Check for stale entries and refresh them.
       */
      async refreshStaleEntries() {
        if (!this.fetchFunc) {
          return;
        }
        const staleKeys = this.getStaleKeys();
        if (staleKeys.length === 0) {
          return;
        }
        for (const key of staleKeys) {
          try {
            const newValue = await this.fetchFunc(key);
            this.set(key, newValue);
            this._metrics.refreshes += 1;
          } catch (e) {
            this._metrics.refreshErrors += 1;
            console.warn(`Failed to refresh cache entry ${key}:`, e);
          }
        }
      }
    };
  }
});

// node_modules/langsmith/dist/index.js
var __version__;
var init_dist = __esm({
  "node_modules/langsmith/dist/index.js"() {
    init_client();
    init_run_trees();
    init_fetch();
    init_project();
    init_uuid2();
    init_prompts_cache();
    __version__ = "0.4.8";
  }
});

// node_modules/langsmith/dist/utils/env.js
function getRuntimeEnvironment2() {
  if (runtimeEnvironment2 === void 0) {
    const env = getEnv2();
    const releaseEnv = getShas();
    runtimeEnvironment2 = {
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: __version__,
      ...releaseEnv
    };
  }
  return runtimeEnvironment2;
}
function getLangSmithEnvVarsMetadata() {
  const allEnvVars = getLangSmithEnvironmentVariables();
  const envVars = {};
  const excluded = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [key, value] of Object.entries(allEnvVars)) {
    if (typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
function getLangSmithEnvironmentVariables() {
  const envVars = {};
  try {
    if (typeof process !== "undefined" && process.env) {
      for (const [key, value] of Object.entries(process.env)) {
        if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && value != null) {
          if ((key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("token")) && typeof value === "string") {
            envVars[key] = value.slice(0, 2) + "*".repeat(value.length - 4) + value.slice(-2);
          } else {
            envVars[key] = value;
          }
        }
      }
    }
  } catch (e) {
  }
  return envVars;
}
function getEnvironmentVariable2(name) {
  try {
    return typeof process !== "undefined" ? (
      // eslint-disable-next-line no-process-env
      process.env?.[name]
    ) : void 0;
  } catch (e) {
    return void 0;
  }
}
function getLangSmithEnvironmentVariable(name) {
  return getEnvironmentVariable2(`LANGSMITH_${name}`) || getEnvironmentVariable2(`LANGCHAIN_${name}`);
}
function getShas() {
  if (cachedCommitSHAs !== void 0) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable2(env);
    if (envVar !== void 0) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}
function getOtelEnabled() {
  return getEnvironmentVariable2("OTEL_ENABLED") === "true" || getLangSmithEnvironmentVariable("OTEL_ENABLED") === "true";
}
var globalEnv, isBrowser2, isWebWorker2, isJsDom2, isDeno2, isNode2, getEnv2, runtimeEnvironment2, cachedCommitSHAs;
var init_env2 = __esm({
  "node_modules/langsmith/dist/utils/env.js"() {
    init_dist();
    isBrowser2 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
    isWebWorker2 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
    isJsDom2 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
    isDeno2 = () => typeof Deno !== "undefined";
    isNode2 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno2();
    getEnv2 = () => {
      if (globalEnv) {
        return globalEnv;
      }
      if (typeof Bun !== "undefined") {
        globalEnv = "bun";
      } else if (isBrowser2()) {
        globalEnv = "browser";
      } else if (isNode2()) {
        globalEnv = "node";
      } else if (isWebWorker2()) {
        globalEnv = "webworker";
      } else if (isJsDom2()) {
        globalEnv = "jsdom";
      } else if (isDeno2()) {
        globalEnv = "deno";
      } else {
        globalEnv = "other";
      }
      return globalEnv;
    };
  }
});

// node_modules/langsmith/dist/singletons/otel.js
function getOTELTrace() {
  return OTELProviderSingleton.getTraceInstance();
}
function getOTELContext() {
  return OTELProviderSingleton.getContextInstance();
}
function getDefaultOTLPTracerComponents() {
  return OTELProviderSingleton.getDefaultOTLPTracerComponents();
}
var MockTracer, MockOTELTrace, MockOTELContext, OTEL_TRACE_KEY, OTEL_CONTEXT_KEY, OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY, mockOTELTrace, mockOTELContext, OTELProvider, OTELProviderSingleton;
var init_otel = __esm({
  "node_modules/langsmith/dist/singletons/otel.js"() {
    init_env2();
    MockTracer = class {
      constructor() {
        Object.defineProperty(this, "hasWarned", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
      }
      startActiveSpan(_name, ...args) {
        if (!this.hasWarned && getOtelEnabled()) {
          console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.');
          this.hasWarned = true;
        }
        let fn;
        if (args.length === 1 && typeof args[0] === "function") {
          fn = args[0];
        } else if (args.length === 2 && typeof args[1] === "function") {
          fn = args[1];
        } else if (args.length === 3 && typeof args[2] === "function") {
          fn = args[2];
        }
        if (typeof fn === "function") {
          return fn();
        }
        return void 0;
      }
    };
    MockOTELTrace = class {
      constructor() {
        Object.defineProperty(this, "mockTracer", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new MockTracer()
        });
      }
      getTracer(_name, _version) {
        return this.mockTracer;
      }
      getActiveSpan() {
        return void 0;
      }
      setSpan(context2, _span) {
        return context2;
      }
      getSpan(_context) {
        return void 0;
      }
      setSpanContext(context2, _spanContext) {
        return context2;
      }
      getTracerProvider() {
        return void 0;
      }
      setGlobalTracerProvider(_tracerProvider) {
        return false;
      }
    };
    MockOTELContext = class {
      active() {
        return {};
      }
      with(_context, fn) {
        return fn();
      }
    };
    OTEL_TRACE_KEY = Symbol.for("ls:otel_trace");
    OTEL_CONTEXT_KEY = Symbol.for("ls:otel_context");
    OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
    mockOTELTrace = new MockOTELTrace();
    mockOTELContext = new MockOTELContext();
    OTELProvider = class {
      getTraceInstance() {
        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;
      }
      getContextInstance() {
        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;
      }
      initializeGlobalInstances(otel) {
        if (globalThis[OTEL_TRACE_KEY] === void 0) {
          globalThis[OTEL_TRACE_KEY] = otel.trace;
        }
        if (globalThis[OTEL_CONTEXT_KEY] === void 0) {
          globalThis[OTEL_CONTEXT_KEY] = otel.context;
        }
      }
      setDefaultOTLPTracerComponents(components) {
        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;
      }
      getDefaultOTLPTracerComponents() {
        return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? void 0;
      }
    };
    OTELProviderSingleton = new OTELProvider();
  }
});

// node_modules/langsmith/dist/experimental/otel/translator.js
function getOperationName(runType) {
  return WELL_KNOWN_OPERATION_NAMES[runType] || runType;
}
var WELL_KNOWN_OPERATION_NAMES, LangSmithToOTELTranslator;
var init_translator = __esm({
  "node_modules/langsmith/dist/experimental/otel/translator.js"() {
    init_constants();
    init_otel();
    WELL_KNOWN_OPERATION_NAMES = {
      llm: "chat",
      tool: "execute_tool",
      retriever: "embeddings",
      embedding: "embeddings",
      prompt: "chat"
    };
    LangSmithToOTELTranslator = class {
      constructor() {
        Object.defineProperty(this, "spans", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
      }
      exportBatch(operations, otelContextMap) {
        for (const op of operations) {
          try {
            if (!op.run) {
              continue;
            }
            if (op.operation === "post") {
              const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));
              if (span && !op.run.end_time) {
                this.spans.set(op.id, span);
              }
            } else {
              this.updateSpanForRun(op, op.run);
            }
          } catch (e) {
            console.error(`Error processing operation ${op.id}:`, e);
          }
        }
      }
      createSpanForRun(op, runInfo, otelContext) {
        const activeSpan = otelContext && getOTELTrace().getSpan(otelContext);
        if (!activeSpan) {
          return;
        }
        try {
          return this.finishSpanSetup(activeSpan, runInfo, op);
        } catch (e) {
          console.error(`Failed to create span for run ${op.id}:`, e);
          return void 0;
        }
      }
      finishSpanSetup(span, runInfo, op) {
        this.setSpanAttributes(span, runInfo, op);
        if (runInfo.error) {
          span.setStatus({ code: 2 });
          span.recordException(new Error(runInfo.error));
        } else {
          span.setStatus({ code: 1 });
        }
        if (runInfo.end_time) {
          span.end(new Date(runInfo.end_time));
        }
        return span;
      }
      updateSpanForRun(op, runInfo) {
        try {
          const span = this.spans.get(op.id);
          if (!span) {
            console.debug(`No span found for run ${op.id} during update`);
            return;
          }
          this.setSpanAttributes(span, runInfo, op);
          if (runInfo.error) {
            span.setStatus({ code: 2 });
            span.recordException(new Error(runInfo.error));
          } else {
            span.setStatus({ code: 1 });
          }
          const endTime = runInfo.end_time;
          if (endTime) {
            span.end(new Date(endTime));
            this.spans.delete(op.id);
          }
        } catch (e) {
          console.error(`Failed to update span for run ${op.id}:`, e);
        }
      }
      extractModelName(runInfo) {
        if (runInfo.extra?.metadata) {
          const metadata = runInfo.extra.metadata;
          if (metadata.ls_model_name) {
            return metadata.ls_model_name;
          }
          if (metadata.invocation_params) {
            const invocationParams = metadata.invocation_params;
            if (invocationParams.model) {
              return invocationParams.model;
            } else if (invocationParams.model_name) {
              return invocationParams.model_name;
            }
          }
        }
        return;
      }
      setSpanAttributes(span, runInfo, op) {
        if ("run_type" in runInfo && runInfo.run_type) {
          span.setAttribute(LANGSMITH_RUN_TYPE, runInfo.run_type);
          const operationName = getOperationName(runInfo.run_type || "chain");
          span.setAttribute(GEN_AI_OPERATION_NAME, operationName);
        }
        if ("name" in runInfo && runInfo.name) {
          span.setAttribute(LANGSMITH_NAME, runInfo.name);
        }
        if ("session_id" in runInfo && runInfo.session_id) {
          span.setAttribute(LANGSMITH_SESSION_ID, runInfo.session_id);
        }
        if ("session_name" in runInfo && runInfo.session_name) {
          span.setAttribute(LANGSMITH_SESSION_NAME, runInfo.session_name);
        }
        this.setGenAiSystem(span, runInfo);
        const modelName = this.extractModelName(runInfo);
        if (modelName) {
          span.setAttribute(GEN_AI_REQUEST_MODEL, modelName);
        }
        if ("prompt_tokens" in runInfo && typeof runInfo.prompt_tokens === "number") {
          span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);
        }
        if ("completion_tokens" in runInfo && typeof runInfo.completion_tokens === "number") {
          span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);
        }
        if ("total_tokens" in runInfo && typeof runInfo.total_tokens === "number") {
          span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);
        }
        this.setInvocationParameters(span, runInfo);
        const metadata = runInfo.extra?.metadata || {};
        for (const [key, value] of Object.entries(metadata)) {
          if (value !== null && value !== void 0) {
            span.setAttribute(`${LANGSMITH_METADATA}.${key}`, String(value));
          }
        }
        const tags = runInfo.tags;
        if (tags && Array.isArray(tags)) {
          span.setAttribute(LANGSMITH_TAGS, tags.join(", "));
        } else if (tags) {
          span.setAttribute(LANGSMITH_TAGS, String(tags));
        }
        if ("serialized" in runInfo && typeof runInfo.serialized === "object") {
          const serialized = runInfo.serialized;
          if (serialized.name) {
            span.setAttribute(GEN_AI_SERIALIZED_NAME, String(serialized.name));
          }
          if (serialized.signature) {
            span.setAttribute(GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));
          }
          if (serialized.doc) {
            span.setAttribute(GEN_AI_SERIALIZED_DOC, String(serialized.doc));
          }
        }
        this.setIOAttributes(span, op);
      }
      setGenAiSystem(span, runInfo) {
        let system = "langchain";
        const modelName = this.extractModelName(runInfo);
        if (modelName) {
          const modelLower = modelName.toLowerCase();
          if (modelLower.includes("anthropic") || modelLower.startsWith("claude")) {
            system = "anthropic";
          } else if (modelLower.includes("bedrock")) {
            system = "aws.bedrock";
          } else if (modelLower.includes("azure") && modelLower.includes("openai")) {
            system = "az.ai.openai";
          } else if (modelLower.includes("azure") && modelLower.includes("inference")) {
            system = "az.ai.inference";
          } else if (modelLower.includes("cohere")) {
            system = "cohere";
          } else if (modelLower.includes("deepseek")) {
            system = "deepseek";
          } else if (modelLower.includes("gemini")) {
            system = "gemini";
          } else if (modelLower.includes("groq")) {
            system = "groq";
          } else if (modelLower.includes("watson") || modelLower.includes("ibm")) {
            system = "ibm.watsonx.ai";
          } else if (modelLower.includes("mistral")) {
            system = "mistral_ai";
          } else if (modelLower.includes("gpt") || modelLower.includes("openai")) {
            system = "openai";
          } else if (modelLower.includes("perplexity") || modelLower.includes("sonar")) {
            system = "perplexity";
          } else if (modelLower.includes("vertex")) {
            system = "vertex_ai";
          } else if (modelLower.includes("xai") || modelLower.includes("grok")) {
            system = "xai";
          }
        }
        span.setAttribute(GEN_AI_SYSTEM, system);
      }
      setInvocationParameters(span, runInfo) {
        if (!runInfo.extra?.metadata?.invocation_params) {
          return;
        }
        const invocationParams = runInfo.extra.metadata.invocation_params;
        if (invocationParams.max_tokens !== void 0) {
          span.setAttribute(GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);
        }
        if (invocationParams.temperature !== void 0) {
          span.setAttribute(GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);
        }
        if (invocationParams.top_p !== void 0) {
          span.setAttribute(GEN_AI_REQUEST_TOP_P, invocationParams.top_p);
        }
        if (invocationParams.frequency_penalty !== void 0) {
          span.setAttribute(GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);
        }
        if (invocationParams.presence_penalty !== void 0) {
          span.setAttribute(GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);
        }
      }
      setIOAttributes(span, op) {
        if (op.run.inputs) {
          try {
            const inputs = op.run.inputs;
            if (typeof inputs === "object" && inputs !== null) {
              if (inputs.model && Array.isArray(inputs.messages)) {
                span.setAttribute(GEN_AI_REQUEST_MODEL, inputs.model);
              }
              if (inputs.stream !== void 0) {
                span.setAttribute(LANGSMITH_REQUEST_STREAMING, inputs.stream);
              }
              if (inputs.extra_headers) {
                span.setAttribute(LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));
              }
              if (inputs.extra_query) {
                span.setAttribute(GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));
              }
              if (inputs.extra_body) {
                span.setAttribute(GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));
              }
            }
            span.setAttribute(GENAI_PROMPT, JSON.stringify(inputs));
          } catch (e) {
            console.debug(`Failed to process inputs for run ${op.id}`, e);
          }
        }
        if (op.run.outputs) {
          try {
            const outputs = op.run.outputs;
            const tokenUsage = this.getUnifiedRunTokens(outputs);
            if (tokenUsage) {
              span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);
              span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);
              span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);
            }
            if (outputs && typeof outputs === "object") {
              if (outputs.model) {
                span.setAttribute(GEN_AI_RESPONSE_MODEL, String(outputs.model));
              }
              if (outputs.id) {
                span.setAttribute(GEN_AI_RESPONSE_ID, outputs.id);
              }
              if (outputs.choices && Array.isArray(outputs.choices)) {
                const finishReasons = outputs.choices.map((choice) => choice.finish_reason).filter((reason) => reason).map(String);
                if (finishReasons.length > 0) {
                  span.setAttribute(GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(", "));
                }
              }
              if (outputs.service_tier) {
                span.setAttribute(GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);
              }
              if (outputs.system_fingerprint) {
                span.setAttribute(GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);
              }
              if (outputs.usage_metadata && typeof outputs.usage_metadata === "object") {
                const usageMetadata = outputs.usage_metadata;
                if (usageMetadata.input_token_details) {
                  span.setAttribute(GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));
                }
                if (usageMetadata.output_token_details) {
                  span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));
                }
              }
            }
            span.setAttribute(GENAI_COMPLETION, JSON.stringify(outputs));
          } catch (e) {
            console.debug(`Failed to process outputs for run ${op.id}`, e);
          }
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      getUnifiedRunTokens(outputs) {
        if (!outputs) {
          return null;
        }
        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
        const keys = Object.keys(outputs);
        for (const key of keys) {
          const haystack = outputs[key];
          if (!haystack || typeof haystack !== "object") {
            continue;
          }
          tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);
          if (tokenUsage) {
            return tokenUsage;
          }
          if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === "object") {
            tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);
            if (tokenUsage) {
              return tokenUsage;
            }
          }
        }
        const generations = outputs.generations || [];
        if (!Array.isArray(generations)) {
          return null;
        }
        const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;
        for (const generation of flatGenerations) {
          if (typeof generation === "object" && generation.message && typeof generation.message === "object" && generation.message.kwargs && typeof generation.message.kwargs === "object") {
            tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);
            if (tokenUsage) {
              return tokenUsage;
            }
          }
        }
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      extractUnifiedRunTokens(outputs) {
        if (!outputs || typeof outputs !== "object") {
          return null;
        }
        if (typeof outputs.input_tokens !== "number" || typeof outputs.output_tokens !== "number") {
          return null;
        }
        return [outputs.input_tokens, outputs.output_tokens];
      }
    };
  }
});

// node_modules/langsmith/dist/utils/is-network-error/index.js
function isNetworkError(error40) {
  const isValid2 = error40 && isError(error40) && error40.name === "TypeError" && typeof error40.message === "string";
  if (!isValid2) {
    return false;
  }
  const { message, stack } = error40;
  if (message === "Load failed") {
    return stack === void 0 || // Sentry adds its own stack trace to the fetch error, so also check for that
    "__sentry_captured__" in error40;
  }
  if (message.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message);
}
var objectToString, isError, errorMessages;
var init_is_network_error = __esm({
  "node_modules/langsmith/dist/utils/is-network-error/index.js"() {
    objectToString = Object.prototype.toString;
    isError = (value) => objectToString.call(value) === "[object Error]";
    errorMessages = /* @__PURE__ */ new Set([
      "network error",
      // Chrome
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari 16
      "Network request failed",
      // `cross-fetch`
      "fetch failed",
      // Undici (Node.js)
      "terminated",
      // Undici (Node.js)
      " A network error occurred.",
      // Bun (WebKit)
      "Network connection lost"
      // Cloudflare Workers (fetch)
    ]);
  }
});

// node_modules/langsmith/dist/utils/p-retry/index.js
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) {
    return;
  }
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value)) {
    throw new TypeError(`Expected \`${name}\` to be a finite number.`);
  }
  if (value < min) {
    throw new TypeError(`Expected \`${name}\` to be \u2265 ${min}.`);
  }
}
function calculateDelay(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start);
}
async function onAttemptFailure({ error: error40, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error40 instanceof Error ? error40 : new TypeError(`Non-error was thrown: "${error40}". You should only throw errors.`);
  if (normalizedError instanceof AbortError) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context2 = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context2);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options.shouldConsumeRetry(context2);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context2)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      const onAbort = () => {
        clearTimeout(timeoutToken);
        options.signal?.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        options.signal?.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options.unref) {
        timeoutToken.unref?.();
      }
      options.signal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry(input, options = {}) {
  options = { ...options };
  validateRetries(options.retries);
  if (Object.hasOwn(options, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1e3;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {
  };
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption("factor", options.factor, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption("minTimeout", options.minTimeout, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption("maxTimeout", options.maxTimeout, {
    min: 0,
    allowInfinity: true
  });
  validateNumberOption("maxRetryTime", options.maxRetryTime, {
    min: 0,
    allowInfinity: true
  });
  if (!(options.factor > 0)) {
    options.factor = 1;
  }
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error40) {
      if (await onAttemptFailure({
        error: error40,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var AbortError;
var init_p_retry = __esm({
  "node_modules/langsmith/dist/utils/p-retry/index.js"() {
    init_is_network_error();
    AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module) {
    "use strict";
    module.exports = (promise2, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise2.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise2, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise2);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error40) {
            reject(error40);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise2.cancel === "function") {
          promise2.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise2.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module.exports = pTimeout;
    module.exports.default = pTimeout;
    module.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lowerBound(array2, value, comparator) {
      let first = 0;
      let count = array2.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array2[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports2.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index2 = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index2, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports2.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventEmitter = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter {
      constructor(options) {
        var _a3, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a3 = options.intervalCap) === null || _a3 === void 0 ? void 0 : _a3.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error40) {
              reject(error40);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports2.default = PQueue;
  }
});

// node_modules/langsmith/dist/utils/async_caller.js
var import_p_queue, STATUS_RETRYABLE, AsyncCaller;
var init_async_caller = __esm({
  "node_modules/langsmith/dist/utils/async_caller.js"() {
    init_p_retry();
    import_p_queue = __toESM(require_dist(), 1);
    STATUS_RETRYABLE = [
      408,
      // Request Timeout
      425,
      // Too Early
      429,
      // Too Many Requests
      500,
      // Internal Server Error
      502,
      // Bad Gateway
      503,
      // Service Unavailable
      504
      // Gateway Timeout
    ];
    AsyncCaller = class {
      constructor(params) {
        Object.defineProperty(this, "maxConcurrency", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "maxRetries", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "maxQueueSizeBytes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "queue", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "onFailedResponseHook", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "queueSizeBytes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        });
        this.maxConcurrency = params.maxConcurrency ?? Infinity;
        this.maxRetries = params.maxRetries ?? 6;
        this.maxQueueSizeBytes = params.maxQueueSizeBytes;
        if ("default" in import_p_queue.default) {
          this.queue = new import_p_queue.default.default({
            concurrency: this.maxConcurrency
          });
        } else {
          this.queue = new import_p_queue.default({ concurrency: this.maxConcurrency });
        }
        this.onFailedResponseHook = params?.onFailedResponseHook;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      call(callable, ...args) {
        return this.callWithOptions({}, callable, ...args);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      callWithOptions(options, callable, ...args) {
        const sizeBytes = options.sizeBytes ?? 0;
        if (this.maxQueueSizeBytes !== void 0 && sizeBytes > 0 && this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {
          return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));
        }
        if (sizeBytes > 0) {
          this.queueSizeBytes += sizeBytes;
        }
        const onFailedResponseHook = this.onFailedResponseHook;
        let promise2 = this.queue.add(() => pRetry(() => callable(...args).catch((error40) => {
          if (error40 instanceof Error) {
            throw error40;
          } else {
            throw new Error(error40);
          }
        }), {
          async onFailedAttempt({ error: error40 }) {
            if (typeof error40 !== "object" || error40 == null)
              throw error40;
            const errorMessage = "message" in error40 && typeof error40.message === "string" ? error40.message : void 0;
            if (errorMessage?.startsWith("Cancel") || errorMessage?.startsWith("TimeoutError") || errorMessage?.startsWith("AbortError")) {
              throw error40;
            }
            if ("name" in error40 && error40.name === "TimeoutError") {
              throw error40;
            }
            if ("code" in error40 && error40.code === "ECONNABORTED") {
              throw error40;
            }
            const response = "response" in error40 ? error40.response : void 0;
            if (onFailedResponseHook) {
              const handled = await onFailedResponseHook(response);
              if (handled)
                return;
            }
            const status = response?.status ?? ("status" in error40 ? error40.status : void 0);
            if (status != null && (typeof status === "number" || typeof status === "string") && !STATUS_RETRYABLE.includes(+status)) {
              throw error40;
            }
          },
          retries: this.maxRetries,
          randomize: true
        }), { throwOnTimeout: true });
        if (sizeBytes > 0) {
          promise2 = promise2.finally(() => {
            this.queueSizeBytes -= sizeBytes;
          });
        }
        if (options.signal) {
          return Promise.race([
            promise2,
            new Promise((_, reject) => {
              options.signal?.addEventListener("abort", () => {
                reject(new Error("AbortError"));
              });
            })
          ]);
        }
        return promise2;
      }
    };
  }
});

// node_modules/langsmith/dist/utils/messages.js
function isLangChainMessage(message) {
  return typeof message?._getType === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content }
  };
  if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}
var init_messages = __esm({
  "node_modules/langsmith/dist/utils/messages.js"() {
  }
});

// node_modules/langsmith/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/langsmith/node_modules/semver/internal/constants.js"(exports2, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/langsmith/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/langsmith/node_modules/semver/internal/debug.js"(exports2, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/langsmith/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/langsmith/node_modules/semver/internal/re.js"(exports2, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R++;
      debug(name, index2, value);
      t[name] = index2;
      src[index2] = value;
      safeSrc[index2] = safe;
      re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/langsmith/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/langsmith/node_modules/semver/internal/parse-options.js"(exports2, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/langsmith/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/langsmith/node_modules/semver/internal/identifiers.js"(exports2, module) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/langsmith/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/langsmith/node_modules/semver/classes/semver.js"(exports2, module) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/langsmith/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/parse.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var parse8 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse8;
  }
});

// node_modules/langsmith/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/valid.js"(exports2, module) {
    "use strict";
    var parse8 = require_parse();
    var valid = (version2, options) => {
      const v = parse8(version2, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/langsmith/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/clean.js"(exports2, module) {
    "use strict";
    var parse8 = require_parse();
    var clean = (version2, options) => {
      const s = parse8(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/langsmith/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/inc.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/langsmith/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/diff.js"(exports2, module) {
    "use strict";
    var parse8 = require_parse();
    var diff = (version1, version2) => {
      const v12 = parse8(version1, null, true);
      const v2 = parse8(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/langsmith/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/major.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// node_modules/langsmith/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/minor.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// node_modules/langsmith/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/patch.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/langsmith/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/prerelease.js"(exports2, module) {
    "use strict";
    var parse8 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse8(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/langsmith/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/compare.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare2;
  }
});

// node_modules/langsmith/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/rcompare.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var rcompare = (a, b, loose) => compare2(b, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/langsmith/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/compare-loose.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var compareLoose = (a, b) => compare2(a, b, true);
    module.exports = compareLoose;
  }
});

// node_modules/langsmith/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/compare-build.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/langsmith/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/sort.js"(exports2, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// node_modules/langsmith/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/rsort.js"(exports2, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// node_modules/langsmith/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/gt.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var gt = (a, b, loose) => compare2(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/langsmith/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/lt.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var lt = (a, b, loose) => compare2(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/langsmith/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/eq.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var eq = (a, b, loose) => compare2(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/langsmith/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/neq.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var neq = (a, b, loose) => compare2(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/langsmith/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/gte.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var gte = (a, b, loose) => compare2(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/langsmith/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/lte.js"(exports2, module) {
    "use strict";
    var compare2 = require_compare();
    var lte = (a, b, loose) => compare2(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/langsmith/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/cmp.js"(exports2, module) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/langsmith/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/coerce.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var parse8 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce2 = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse8(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce2;
  }
});

// node_modules/langsmith/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/langsmith/node_modules/semver/internal/lrucache.js"(exports2, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/langsmith/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/langsmith/node_modules/semver/classes/range.js"(exports2, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached2 = cache2.get(memoKey);
        if (cached2) {
          return cached2;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version2, options) => {
      for (let i = 0; i < set2.length; i++) {
        if (!set2[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set2.length; i++) {
          debug(set2[i].semver);
          if (set2[i].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i].semver.prerelease.length > 0) {
            const allowed = set2[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/langsmith/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/langsmith/node_modules/semver/classes/comparator.js"(exports2, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/langsmith/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/langsmith/node_modules/semver/functions/satisfies.js"(exports2, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module.exports = satisfies;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/to-comparators.js"(exports2, module) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/min-version.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/valid.js"(exports2, module) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/outside.js"(exports2, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/gtr.js"(exports2, module) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/ltr.js"(exports2, module) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/intersects.js"(exports2, module) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/langsmith/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/simplify.js"(exports2, module) {
    "use strict";
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare2(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/langsmith/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/langsmith/node_modules/semver/ranges/subset.js"(exports2, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// node_modules/langsmith/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/langsmith/node_modules/semver/index.js"(exports2, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse8 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse8,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/langsmith/dist/utils/prompts.js
function parsePromptIdentifier(identifier) {
  if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
    throw new Error(`Invalid identifier format: ${identifier}`);
  }
  const [ownerNamePart, commitPart] = identifier.split(":");
  const commit = commitPart || "latest";
  if (ownerNamePart.includes("/")) {
    const [owner, name] = ownerNamePart.split("/", 2);
    if (!owner || !name) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return [owner, name, commit];
  } else {
    if (!ownerNamePart) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return ["-", ownerNamePart, commit];
  }
}
var import_semver;
var init_prompts = __esm({
  "node_modules/langsmith/dist/utils/prompts.js"() {
    import_semver = __toESM(require_semver2(), 1);
  }
});

// node_modules/langsmith/dist/utils/error.js
function isLangSmithNotFoundError(error40) {
  return error40 != null && typeof error40 === "object" && "name" in error40 && error40?.name === "LangSmithNotFoundError";
}
async function raiseForStatus(response, context2, consumeOnSuccess) {
  let errorBody;
  if (response.ok) {
    if (consumeOnSuccess) {
      errorBody = await response.text();
    }
    return;
  }
  if (response.status === 403) {
    try {
      const errorData = await response.json();
      const errorCode = errorData?.error;
      if (errorCode === "org_scoped_key_requires_workspace") {
        errorBody = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.";
      }
    } catch (e) {
      const errorWithStatus = new Error(`${response.status} ${response.statusText}`);
      errorWithStatus.status = response?.status;
      throw errorWithStatus;
    }
  }
  if (errorBody === void 0) {
    try {
      errorBody = await response.text();
    } catch (e) {
      errorBody = "";
    }
  }
  const fullMessage = `Failed to ${context2}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;
  if (response.status === 404) {
    throw new LangSmithNotFoundError(fullMessage);
  }
  if (response.status === 409) {
    throw new LangSmithConflictError(fullMessage);
  }
  const err = new Error(fullMessage);
  err.status = response.status;
  throw err;
}
function isConflictingEndpointsError(err) {
  return typeof err === "object" && err !== null && err.code === ERR_CONFLICTING_ENDPOINTS;
}
var LangSmithConflictError, LangSmithNotFoundError, ERR_CONFLICTING_ENDPOINTS, ConflictingEndpointsError;
var init_error = __esm({
  "node_modules/langsmith/dist/utils/error.js"() {
    LangSmithConflictError = class extends Error {
      constructor(message) {
        super(message);
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = "LangSmithConflictError";
        this.status = 409;
      }
    };
    LangSmithNotFoundError = class extends Error {
      constructor(message) {
        super(message);
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = "LangSmithNotFoundError";
        this.status = 404;
      }
    };
    ERR_CONFLICTING_ENDPOINTS = "ERR_CONFLICTING_ENDPOINTS";
    ConflictingEndpointsError = class extends Error {
      constructor() {
        super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS.");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: ERR_CONFLICTING_ENDPOINTS
        });
        this.name = "ConflictingEndpointsError";
      }
    };
  }
});

// node_modules/langsmith/dist/utils/fast-safe-stringify/index.js
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function encodeString(str2) {
  return encoder.encode(str2);
}
function serializeWellKnownTypes(val) {
  if (val && typeof val === "object" && val !== null) {
    if (val instanceof Map) {
      return Object.fromEntries(val);
    } else if (val instanceof Set) {
      return Array.from(val);
    } else if (val instanceof Date) {
      return val.toISOString();
    } else if (val instanceof RegExp) {
      return val.toString();
    } else if (val instanceof Error) {
      return {
        name: val.name,
        message: val.message
      };
    }
  } else if (typeof val === "bigint") {
    return val.toString();
  }
  return val;
}
function createDefaultReplacer(userReplacer) {
  return function(key, val) {
    if (userReplacer) {
      const userResult = userReplacer.call(this, key, val);
      if (userResult !== void 0) {
        return userResult;
      }
    }
    return serializeWellKnownTypes(val);
  };
}
function serialize(obj, errorContext, replacer, spacer, options) {
  try {
    const str2 = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);
    return encodeString(str2);
  } catch (e) {
    if (!e.message?.includes("Converting circular structure to JSON")) {
      console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `
Context: ${errorContext}` : ""}`);
      return encodeString("[Unserializable]");
    }
    getLangSmithEnvironmentVariable("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `
Context: ${errorContext}` : ""}`);
    if (typeof options === "undefined") {
      options = defaultOptions();
    }
    decirc(obj, "", 0, [], void 0, 0, options);
    let res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return encodeString("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        const part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return encodeString(res);
  }
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      val = serializeWellKnownTypes(val);
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}
var LIMIT_REPLACE_NODE, CIRCULAR_REPLACE_NODE, arr, replacerStack, encoder;
var init_fast_safe_stringify = __esm({
  "node_modules/langsmith/dist/utils/fast-safe-stringify/index.js"() {
    init_env2();
    LIMIT_REPLACE_NODE = "[...]";
    CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
    arr = [];
    replacerStack = [];
    encoder = new TextEncoder();
  }
});

// node_modules/langsmith/dist/client.js
function mergeRuntimeEnvIntoRun(run, cachedEnvVars, omitTracedRuntimeInfo) {
  if (omitTracedRuntimeInfo) {
    return run;
  }
  const runtimeEnv = getRuntimeEnvironment2();
  const envVars = cachedEnvVars ?? getLangSmithEnvVarsMetadata();
  const extra = run.extra ?? {};
  const metadata = extra.metadata;
  run.extra = {
    ...extra,
    runtime: {
      ...runtimeEnv,
      ...extra?.runtime
    },
    metadata: {
      ...envVars,
      ...envVars.revision_id || "revision_id" in run && run.revision_id ? {
        revision_id: ("revision_id" in run ? run.revision_id : void 0) ?? envVars.revision_id
      } : {},
      ...metadata
    }
  };
  return run;
}
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str2) {
  if (str2 === void 0) {
    return void 0;
  }
  return str2.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
function _formatFeedbackScore(score) {
  if (typeof score === "number") {
    return Number(score.toFixed(4));
  }
  return score;
}
function isExampleCreate(input) {
  return "dataset_id" in input || "dataset_name" in input;
}
var getTracingSamplingRate, isLocalhost, handle429, DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES, DEFAULT_MAX_SIZE_BYTES, SERVER_INFO_REQUEST_TIMEOUT_MS, DEFAULT_BATCH_SIZE_LIMIT, DEFAULT_API_URL, AutoBatchQueue, Client;
var init_client = __esm({
  "node_modules/langsmith/dist/client.js"() {
    init_esm_node2();
    init_translator();
    init_otel();
    init_async_caller();
    init_messages();
    init_env2();
    init_dist();
    init_uuid();
    init_warn();
    init_prompts();
    init_error();
    init_prompts_cache();
    init_fetch();
    init_fast_safe_stringify();
    getTracingSamplingRate = (configRate) => {
      const samplingRateStr = configRate?.toString() ?? getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
      if (samplingRateStr === void 0) {
        return void 0;
      }
      const samplingRate = parseFloat(samplingRateStr);
      if (samplingRate < 0 || samplingRate > 1) {
        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
      }
      return samplingRate;
    };
    isLocalhost = (url2) => {
      const strippedUrl = url2.replace("http://", "").replace("https://", "");
      const hostname2 = strippedUrl.split("/")[0].split(":")[0];
      return hostname2 === "localhost" || hostname2 === "127.0.0.1" || hostname2 === "::1";
    };
    handle429 = async (response) => {
      if (response?.status === 429) {
        const retryAfter = parseInt(response.headers.get("retry-after") ?? "10", 10) * 1e3;
        if (retryAfter > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryAfter));
          return true;
        }
      }
      return false;
    };
    DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;
    DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024;
    SERVER_INFO_REQUEST_TIMEOUT_MS = 1e4;
    DEFAULT_BATCH_SIZE_LIMIT = 100;
    DEFAULT_API_URL = "https://api.smith.langchain.com";
    AutoBatchQueue = class {
      constructor(maxSizeBytes) {
        Object.defineProperty(this, "items", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "sizeBytes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        });
        Object.defineProperty(this, "maxSizeBytes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;
      }
      peek() {
        return this.items[0];
      }
      push(item) {
        let itemPromiseResolve;
        const itemPromise = new Promise((resolve) => {
          itemPromiseResolve = resolve;
        });
        const size = serialize(item.item, `Serializing run with id: ${item.item.id}`).length;
        if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {
          console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);
          itemPromiseResolve();
          return itemPromise;
        }
        this.items.push({
          action: item.action,
          payload: item.item,
          otelContext: item.otelContext,
          apiKey: item.apiKey,
          apiUrl: item.apiUrl,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          itemPromiseResolve,
          itemPromise,
          size
        });
        this.sizeBytes += size;
        return itemPromise;
      }
      pop({ upToSizeBytes, upToSize }) {
        if (upToSizeBytes < 1) {
          throw new Error("Number of bytes to pop off may not be less than 1.");
        }
        const popped = [];
        let poppedSizeBytes = 0;
        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0 && popped.length < upToSize) {
          const item = this.items.shift();
          if (item) {
            popped.push(item);
            poppedSizeBytes += item.size;
            this.sizeBytes -= item.size;
          }
        }
        if (popped.length === 0 && this.items.length > 0) {
          const item = this.items.shift();
          popped.push(item);
          poppedSizeBytes += item.size;
          this.sizeBytes -= item.size;
        }
        return [
          popped.map((it) => ({
            action: it.action,
            item: it.payload,
            otelContext: it.otelContext,
            apiKey: it.apiKey,
            apiUrl: it.apiUrl,
            size: it.size
          })),
          () => popped.forEach((it) => it.itemPromiseResolve())
        ];
      }
    };
    Client = class _Client {
      get _fetch() {
        return this.fetchImplementation || _getFetchImplementation(this.debug);
      }
      constructor(config2 = {}) {
        Object.defineProperty(this, "apiKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "apiUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "webUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "workspaceId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "caller", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "batchIngestCaller", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "timeout_ms", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_tenantId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: null
        });
        Object.defineProperty(this, "hideInputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "hideOutputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "omitTracedRuntimeInfo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tracingSampleRate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "filteredPostUuids", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        Object.defineProperty(this, "autoBatchTracing", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: true
        });
        Object.defineProperty(this, "autoBatchQueue", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "autoBatchTimeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "autoBatchAggregationDelayMs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 250
        });
        Object.defineProperty(this, "batchSizeBytesLimit", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "batchSizeLimit", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "fetchOptions", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "settings", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "blockOnRootRunFinalization", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: getEnvironmentVariable2("LANGSMITH_TRACING_BACKGROUND") === "false"
        });
        Object.defineProperty(this, "traceBatchConcurrency", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 5
        });
        Object.defineProperty(this, "_serverInfo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_getServerInfoPromise", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "manualFlushMode", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "langSmithToOTELTranslator", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "fetchImplementation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_cache", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "multipartStreamingDisabled", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "_multipartDisabled", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "_runCompressionDisabled", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: getLangSmithEnvironmentVariable("DISABLE_RUN_COMPRESSION") === "true"
        });
        Object.defineProperty(this, "debug", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: getEnvironmentVariable2("LANGSMITH_DEBUG") === "true"
        });
        const defaultConfig = _Client.getDefaultClientConfig();
        this.tracingSampleRate = getTracingSamplingRate(config2.tracingSamplingRate);
        this.apiUrl = trimQuotes(config2.apiUrl ?? defaultConfig.apiUrl) ?? "";
        if (this.apiUrl.endsWith("/")) {
          this.apiUrl = this.apiUrl.slice(0, -1);
        }
        this.apiKey = trimQuotes(config2.apiKey ?? defaultConfig.apiKey);
        this.webUrl = trimQuotes(config2.webUrl ?? defaultConfig.webUrl);
        if (this.webUrl?.endsWith("/")) {
          this.webUrl = this.webUrl.slice(0, -1);
        }
        this.workspaceId = trimQuotes(config2.workspaceId ?? getLangSmithEnvironmentVariable("WORKSPACE_ID"));
        this.timeout_ms = config2.timeout_ms ?? 9e4;
        this.caller = new AsyncCaller({
          ...config2.callerOptions ?? {},
          maxRetries: 4,
          debug: config2.debug ?? this.debug
        });
        this.traceBatchConcurrency = config2.traceBatchConcurrency ?? this.traceBatchConcurrency;
        if (this.traceBatchConcurrency < 1) {
          throw new Error("Trace batch concurrency must be positive.");
        }
        this.debug = config2.debug ?? this.debug;
        this.fetchImplementation = config2.fetchImplementation;
        const maxMemory = config2.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;
        this.batchIngestCaller = new AsyncCaller({
          maxRetries: 4,
          maxConcurrency: this.traceBatchConcurrency,
          maxQueueSizeBytes: maxMemory,
          ...config2.callerOptions ?? {},
          onFailedResponseHook: handle429,
          debug: config2.debug ?? this.debug
        });
        this.hideInputs = config2.hideInputs ?? config2.anonymizer ?? defaultConfig.hideInputs;
        this.hideOutputs = config2.hideOutputs ?? config2.anonymizer ?? defaultConfig.hideOutputs;
        this.omitTracedRuntimeInfo = config2.omitTracedRuntimeInfo ?? false;
        this.autoBatchTracing = config2.autoBatchTracing ?? this.autoBatchTracing;
        this.autoBatchQueue = new AutoBatchQueue(maxMemory);
        this.blockOnRootRunFinalization = config2.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
        this.batchSizeBytesLimit = config2.batchSizeBytesLimit;
        this.batchSizeLimit = config2.batchSizeLimit;
        this.fetchOptions = config2.fetchOptions || {};
        this.manualFlushMode = config2.manualFlushMode ?? this.manualFlushMode;
        if (getOtelEnabled()) {
          this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();
        }
        this.cachedLSEnvVarsForMetadata = getLangSmithEnvVarsMetadata();
        if (config2.cache === true) {
          this._cache = new Cache();
        } else if (config2.cache && typeof config2.cache === "object") {
          this._cache = config2.cache;
        } else {
          this._cache = void 0;
        }
      }
      static getDefaultClientConfig() {
        const apiKey = getLangSmithEnvironmentVariable("API_KEY");
        const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? DEFAULT_API_URL;
        const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
        const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
        return {
          apiUrl,
          apiKey,
          webUrl: void 0,
          hideInputs,
          hideOutputs
        };
      }
      getHostUrl() {
        if (this.webUrl) {
          return this.webUrl;
        } else if (isLocalhost(this.apiUrl)) {
          this.webUrl = "http://localhost:3000";
          return this.webUrl;
        } else if (this.apiUrl.endsWith("/api/v1")) {
          this.webUrl = this.apiUrl.replace("/api/v1", "");
          return this.webUrl;
        } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
          this.webUrl = this.apiUrl.replace("/api", "");
          return this.webUrl;
        } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
          this.webUrl = "https://dev.smith.langchain.com";
          return this.webUrl;
        } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
          this.webUrl = "https://eu.smith.langchain.com";
          return this.webUrl;
        } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
          this.webUrl = "https://beta.smith.langchain.com";
          return this.webUrl;
        } else {
          this.webUrl = "https://smith.langchain.com";
          return this.webUrl;
        }
      }
      get headers() {
        const headers = {
          "User-Agent": `langsmith-js/${__version__}`
        };
        if (this.apiKey) {
          headers["x-api-key"] = `${this.apiKey}`;
        }
        if (this.workspaceId) {
          headers["x-tenant-id"] = this.workspaceId;
        }
        return headers;
      }
      _getPlatformEndpointPath(path3) {
        const needsV1Prefix = this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/";
        return needsV1Prefix ? `/v1/platform/${path3}` : `/platform/${path3}`;
      }
      async processInputs(inputs) {
        if (this.hideInputs === false) {
          return inputs;
        }
        if (this.hideInputs === true) {
          return {};
        }
        if (typeof this.hideInputs === "function") {
          return this.hideInputs(inputs);
        }
        return inputs;
      }
      async processOutputs(outputs) {
        if (this.hideOutputs === false) {
          return outputs;
        }
        if (this.hideOutputs === true) {
          return {};
        }
        if (typeof this.hideOutputs === "function") {
          return this.hideOutputs(outputs);
        }
        return outputs;
      }
      async prepareRunCreateOrUpdateInputs(run) {
        const runParams = { ...run };
        if (runParams.inputs !== void 0) {
          runParams.inputs = await this.processInputs(runParams.inputs);
        }
        if (runParams.outputs !== void 0) {
          runParams.outputs = await this.processOutputs(runParams.outputs);
        }
        return runParams;
      }
      async _getResponse(path3, queryParams) {
        const paramsString = queryParams?.toString() ?? "";
        const url2 = `${this.apiUrl}${path3}?${paramsString}`;
        const response = await this.caller.call(async () => {
          const res = await this._fetch(url2, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, `fetch ${path3}`);
          return res;
        });
        return response;
      }
      async _get(path3, queryParams) {
        const response = await this._getResponse(path3, queryParams);
        return response.json();
      }
      async *_getPaginated(path3, queryParams = new URLSearchParams(), transform2) {
        let offset = Number(queryParams.get("offset")) || 0;
        const limit2 = Number(queryParams.get("limit")) || 100;
        while (true) {
          queryParams.set("offset", String(offset));
          queryParams.set("limit", String(limit2));
          const url2 = `${this.apiUrl}${path3}?${queryParams}`;
          const response = await this.caller.call(async () => {
            const res = await this._fetch(url2, {
              method: "GET",
              headers: this.headers,
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions
            });
            await raiseForStatus(res, `fetch ${path3}`);
            return res;
          });
          const items = transform2 ? transform2(await response.json()) : await response.json();
          if (items.length === 0) {
            break;
          }
          yield items;
          if (items.length < limit2) {
            break;
          }
          offset += items.length;
        }
      }
      async *_getCursorPaginatedList(path3, body = null, requestMethod = "POST", dataKey = "runs") {
        const bodyParams = body ? { ...body } : {};
        while (true) {
          const body2 = JSON.stringify(bodyParams);
          const response = await this.caller.call(async () => {
            const res = await this._fetch(`${this.apiUrl}${path3}`, {
              method: requestMethod,
              headers: { ...this.headers, "Content-Type": "application/json" },
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions,
              body: body2
            });
            await raiseForStatus(res, `fetch ${path3}`);
            return res;
          });
          const responseBody = await response.json();
          if (!responseBody) {
            break;
          }
          if (!responseBody[dataKey]) {
            break;
          }
          yield responseBody[dataKey];
          const cursors = responseBody.cursors;
          if (!cursors) {
            break;
          }
          if (!cursors.next) {
            break;
          }
          bodyParams.cursor = cursors.next;
        }
      }
      // Allows mocking for tests
      _shouldSample() {
        if (this.tracingSampleRate === void 0) {
          return true;
        }
        return Math.random() < this.tracingSampleRate;
      }
      _filterForSampling(runs, patch = false) {
        if (this.tracingSampleRate === void 0) {
          return runs;
        }
        if (patch) {
          const sampled = [];
          for (const run of runs) {
            if (!this.filteredPostUuids.has(run.trace_id)) {
              sampled.push(run);
            } else if (run.id === run.trace_id) {
              this.filteredPostUuids.delete(run.trace_id);
            }
          }
          return sampled;
        } else {
          const sampled = [];
          for (const run of runs) {
            const traceId = run.trace_id ?? run.id;
            if (this.filteredPostUuids.has(traceId)) {
              continue;
            }
            if (run.id === traceId) {
              if (this._shouldSample()) {
                sampled.push(run);
              } else {
                this.filteredPostUuids.add(traceId);
              }
            } else {
              sampled.push(run);
            }
          }
          return sampled;
        }
      }
      async _getBatchSizeLimitBytes() {
        const serverInfo = await this._ensureServerInfo();
        return this.batchSizeBytesLimit ?? serverInfo?.batch_ingest_config?.size_limit_bytes ?? DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES;
      }
      /**
       * Get the maximum number of operations to batch in a single request.
       */
      async _getBatchSizeLimit() {
        const serverInfo = await this._ensureServerInfo();
        return this.batchSizeLimit ?? serverInfo?.batch_ingest_config?.size_limit ?? DEFAULT_BATCH_SIZE_LIMIT;
      }
      async _getDatasetExamplesMultiPartSupport() {
        const serverInfo = await this._ensureServerInfo();
        return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;
      }
      drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit }) {
        const promises = [];
        while (this.autoBatchQueue.items.length > 0) {
          const [batch, done] = this.autoBatchQueue.pop({
            upToSizeBytes: batchSizeLimitBytes,
            upToSize: batchSizeLimit
          });
          if (!batch.length) {
            done();
            break;
          }
          const batchesByDestination = batch.reduce((acc, item) => {
            const apiUrl = item.apiUrl ?? this.apiUrl;
            const apiKey = item.apiKey ?? this.apiKey;
            const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;
            const batchKey = isDefault ? "default" : `${apiUrl}|${apiKey}`;
            if (!acc[batchKey]) {
              acc[batchKey] = [];
            }
            acc[batchKey].push(item);
            return acc;
          }, {});
          const batchPromises = [];
          for (const [batchKey, batch2] of Object.entries(batchesByDestination)) {
            const batchPromise = this._processBatch(batch2, {
              apiUrl: batchKey === "default" ? void 0 : batchKey.split("|")[0],
              apiKey: batchKey === "default" ? void 0 : batchKey.split("|")[1]
            });
            batchPromises.push(batchPromise);
          }
          const allBatchesPromise = Promise.all(batchPromises).finally(done);
          promises.push(allBatchesPromise);
        }
        return Promise.all(promises);
      }
      async _processBatch(batch, options) {
        if (!batch.length) {
          return;
        }
        const batchSizeBytes = batch.reduce((sum, item) => sum + (item.size ?? 0), 0);
        try {
          if (this.langSmithToOTELTranslator !== void 0) {
            this._sendBatchToOTELTranslator(batch);
          } else {
            const ingestParams = {
              runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
              runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
            };
            const serverInfo = await this._ensureServerInfo();
            const useMultipart = !this._multipartDisabled && (serverInfo?.batch_ingest_config?.use_multipart_endpoint ?? true);
            if (useMultipart) {
              const useGzip = !this._runCompressionDisabled && serverInfo?.instance_flags?.gzip_body_enabled;
              try {
                await this.multipartIngestRuns(ingestParams, {
                  ...options,
                  useGzip,
                  sizeBytes: batchSizeBytes
                });
              } catch (e) {
                if (isLangSmithNotFoundError(e)) {
                  this._multipartDisabled = true;
                  await this.batchIngestRuns(ingestParams, {
                    ...options,
                    sizeBytes: batchSizeBytes
                  });
                } else {
                  throw e;
                }
              }
            } else {
              await this.batchIngestRuns(ingestParams, {
                ...options,
                sizeBytes: batchSizeBytes
              });
            }
          }
        } catch (e) {
          console.error("Error exporting batch:", e);
        }
      }
      _sendBatchToOTELTranslator(batch) {
        if (this.langSmithToOTELTranslator !== void 0) {
          const otelContextMap = /* @__PURE__ */ new Map();
          const operations = [];
          for (const item of batch) {
            if (item.item.id && item.otelContext) {
              otelContextMap.set(item.item.id, item.otelContext);
              if (item.action === "create") {
                operations.push({
                  operation: "post",
                  id: item.item.id,
                  trace_id: item.item.trace_id ?? item.item.id,
                  run: item.item
                });
              } else {
                operations.push({
                  operation: "patch",
                  id: item.item.id,
                  trace_id: item.item.trace_id ?? item.item.id,
                  run: item.item
                });
              }
            }
          }
          this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);
        }
      }
      async processRunOperation(item) {
        clearTimeout(this.autoBatchTimeout);
        this.autoBatchTimeout = void 0;
        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);
        const itemPromise = this.autoBatchQueue.push(item);
        if (this.manualFlushMode) {
          return itemPromise;
        }
        const sizeLimitBytes = await this._getBatchSizeLimitBytes();
        const sizeLimit = await this._getBatchSizeLimit();
        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes || this.autoBatchQueue.items.length > sizeLimit) {
          void this.drainAutoBatchQueue({
            batchSizeLimitBytes: sizeLimitBytes,
            batchSizeLimit: sizeLimit
          });
        }
        if (this.autoBatchQueue.items.length > 0) {
          this.autoBatchTimeout = setTimeout(() => {
            this.autoBatchTimeout = void 0;
            void this.drainAutoBatchQueue({
              batchSizeLimitBytes: sizeLimitBytes,
              batchSizeLimit: sizeLimit
            });
          }, this.autoBatchAggregationDelayMs);
        }
        return itemPromise;
      }
      async _getServerInfo() {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/info`, {
            method: "GET",
            headers: { Accept: "application/json" },
            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "get server info");
          return res;
        });
        const json2 = await response.json();
        if (this.debug) {
          console.log("\n=== LangSmith Server Configuration ===\n" + JSON.stringify(json2, null, 2) + "\n");
        }
        return json2;
      }
      async _ensureServerInfo() {
        if (this._getServerInfoPromise === void 0) {
          this._getServerInfoPromise = (async () => {
            if (this._serverInfo === void 0) {
              try {
                this._serverInfo = await this._getServerInfo();
              } catch (e) {
                console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? "Unspecified status code"} ${e.message}`);
              }
            }
            return this._serverInfo ?? {};
          })();
        }
        return this._getServerInfoPromise.then((serverInfo) => {
          if (this._serverInfo === void 0) {
            this._getServerInfoPromise = void 0;
          }
          return serverInfo;
        });
      }
      async _getSettings() {
        if (!this.settings) {
          this.settings = this._get("/settings");
        }
        return await this.settings;
      }
      /**
       * Flushes current queued traces.
       */
      async flush() {
        const sizeLimitBytes = await this._getBatchSizeLimitBytes();
        const sizeLimit = await this._getBatchSizeLimit();
        await this.drainAutoBatchQueue({
          batchSizeLimitBytes: sizeLimitBytes,
          batchSizeLimit: sizeLimit
        });
      }
      _cloneCurrentOTELContext() {
        const otel_trace = getOTELTrace();
        const otel_context = getOTELContext();
        if (this.langSmithToOTELTranslator !== void 0) {
          const currentSpan = otel_trace.getActiveSpan();
          if (currentSpan) {
            return otel_trace.setSpan(otel_context.active(), currentSpan);
          }
        }
        return void 0;
      }
      async createRun(run, options) {
        if (!this._filterForSampling([run]).length) {
          return;
        }
        const headers = {
          ...this.headers,
          "Content-Type": "application/json"
        };
        const session_name = run.project_name;
        delete run.project_name;
        const runCreate = await this.prepareRunCreateOrUpdateInputs({
          session_name,
          ...run,
          start_time: run.start_time ?? Date.now()
        });
        if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
          const otelContext = this._cloneCurrentOTELContext();
          void this.processRunOperation({
            action: "create",
            item: runCreate,
            otelContext,
            apiKey: options?.apiKey,
            apiUrl: options?.apiUrl
          }).catch(console.error);
          return;
        }
        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);
        if (options?.apiKey !== void 0) {
          headers["x-api-key"] = options.apiKey;
        }
        if (options?.workspaceId !== void 0) {
          headers["x-tenant-id"] = options.workspaceId;
        }
        const body = serialize(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);
        await this.caller.call(async () => {
          const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {
            method: "POST",
            headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "create run", true);
          return res;
        });
      }
      /**
       * Batch ingest/upsert multiple runs in the Langsmith system.
       * @param runs
       */
      async batchIngestRuns({ runCreates, runUpdates }, options) {
        if (runCreates === void 0 && runUpdates === void 0) {
          return;
        }
        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);
        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);
        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
          const createById = preparedCreateParams.reduce((params, run) => {
            if (!run.id) {
              return params;
            }
            params[run.id] = run;
            return params;
          }, {});
          const standaloneUpdates = [];
          for (const updateParam of preparedUpdateParams) {
            if (updateParam.id !== void 0 && createById[updateParam.id]) {
              createById[updateParam.id] = {
                ...createById[updateParam.id],
                ...updateParam
              };
            } else {
              standaloneUpdates.push(updateParam);
            }
          }
          preparedCreateParams = Object.values(createById);
          preparedUpdateParams = standaloneUpdates;
        }
        const rawBatch = {
          post: preparedCreateParams,
          patch: preparedUpdateParams
        };
        if (!rawBatch.post.length && !rawBatch.patch.length) {
          return;
        }
        const batchChunks = {
          post: [],
          patch: []
        };
        for (const k of ["post", "patch"]) {
          const key = k;
          const batchItems = rawBatch[key].reverse();
          let batchItem = batchItems.pop();
          while (batchItem !== void 0) {
            batchChunks[key].push(batchItem);
            batchItem = batchItems.pop();
          }
        }
        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
          const runIds = batchChunks.post.map((item) => item.id).concat(batchChunks.patch.map((item) => item.id)).join(",");
          await this._postBatchIngestRuns(serialize(batchChunks, `Ingesting runs with ids: ${runIds}`), options);
        }
      }
      async _postBatchIngestRuns(body, options) {
        const headers = {
          ...this.headers,
          "Content-Type": "application/json",
          Accept: "application/json"
        };
        if (options?.apiKey !== void 0) {
          headers["x-api-key"] = options.apiKey;
        }
        await this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {
          const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {
            method: "POST",
            headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "batch create run", true);
          return res;
        });
      }
      /**
       * Batch ingest/upsert multiple runs in the Langsmith system.
       * @param runs
       */
      async multipartIngestRuns({ runCreates, runUpdates }, options) {
        if (runCreates === void 0 && runUpdates === void 0) {
          return;
        }
        const allAttachments = {};
        let preparedCreateParams = [];
        for (const create of runCreates ?? []) {
          const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);
          if (preparedCreate.id !== void 0 && preparedCreate.attachments !== void 0) {
            allAttachments[preparedCreate.id] = preparedCreate.attachments;
          }
          delete preparedCreate.attachments;
          preparedCreateParams.push(preparedCreate);
        }
        let preparedUpdateParams = [];
        for (const update of runUpdates ?? []) {
          preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));
        }
        const invalidRunCreate = preparedCreateParams.find((runCreate) => {
          return runCreate.trace_id === void 0 || runCreate.dotted_order === void 0;
        });
        if (invalidRunCreate !== void 0) {
          throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
        }
        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
          return runUpdate.trace_id === void 0 || runUpdate.dotted_order === void 0;
        });
        if (invalidRunUpdate !== void 0) {
          throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
        }
        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
          const createById = preparedCreateParams.reduce((params, run) => {
            if (!run.id) {
              return params;
            }
            params[run.id] = run;
            return params;
          }, {});
          const standaloneUpdates = [];
          for (const updateParam of preparedUpdateParams) {
            if (updateParam.id !== void 0 && createById[updateParam.id]) {
              createById[updateParam.id] = {
                ...createById[updateParam.id],
                ...updateParam
              };
            } else {
              standaloneUpdates.push(updateParam);
            }
          }
          preparedCreateParams = Object.values(createById);
          preparedUpdateParams = standaloneUpdates;
        }
        if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
          return;
        }
        const accumulatedContext = [];
        const accumulatedParts = [];
        for (const [method, payloads] of [
          ["post", preparedCreateParams],
          ["patch", preparedUpdateParams]
        ]) {
          for (const originalPayload of payloads) {
            const { inputs, outputs, events, extra, error: error40, serialized, attachments, ...payload } = originalPayload;
            const fields = { inputs, outputs, events, extra, error: error40, serialized };
            const stringifiedPayload = serialize(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);
            accumulatedParts.push({
              name: `${method}.${payload.id}`,
              payload: new Blob([stringifiedPayload], {
                type: `application/json; length=${stringifiedPayload.length}`
                // encoding=gzip
              })
            });
            for (const [key, value] of Object.entries(fields)) {
              if (value === void 0) {
                continue;
              }
              const stringifiedValue = serialize(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);
              accumulatedParts.push({
                name: `${method}.${payload.id}.${key}`,
                payload: new Blob([stringifiedValue], {
                  type: `application/json; length=${stringifiedValue.length}`
                })
              });
            }
            if (payload.id !== void 0) {
              const attachments2 = allAttachments[payload.id];
              if (attachments2) {
                delete allAttachments[payload.id];
                for (const [name, attachment] of Object.entries(attachments2)) {
                  let contentType;
                  let content;
                  if (Array.isArray(attachment)) {
                    [contentType, content] = attachment;
                  } else {
                    contentType = attachment.mimeType;
                    content = attachment.data;
                  }
                  if (name.includes(".")) {
                    console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                    continue;
                  }
                  accumulatedParts.push({
                    name: `attachment.${payload.id}.${name}`,
                    payload: new Blob([content], {
                      type: `${contentType}; length=${content.byteLength}`
                    })
                  });
                }
              }
            }
            accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
          }
        }
        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "), options);
      }
      async _createNodeFetchBody(parts, boundary) {
        const chunks = [];
        for (const part of parts) {
          chunks.push(new Blob([`--${boundary}\r
`]));
          chunks.push(new Blob([
            `Content-Disposition: form-data; name="${part.name}"\r
`,
            `Content-Type: ${part.payload.type}\r
\r
`
          ]));
          chunks.push(part.payload);
          chunks.push(new Blob(["\r\n"]));
        }
        chunks.push(new Blob([`--${boundary}--\r
`]));
        const body = new Blob(chunks);
        const arrayBuffer = await body.arrayBuffer();
        return arrayBuffer;
      }
      async _createMultipartStream(parts, boundary) {
        const encoder2 = new TextEncoder();
        const stream = new ReadableStream({
          async start(controller) {
            const writeChunk = async (chunk) => {
              if (typeof chunk === "string") {
                controller.enqueue(encoder2.encode(chunk));
              } else {
                controller.enqueue(chunk);
              }
            };
            for (const part of parts) {
              await writeChunk(`--${boundary}\r
`);
              await writeChunk(`Content-Disposition: form-data; name="${part.name}"\r
`);
              await writeChunk(`Content-Type: ${part.payload.type}\r
\r
`);
              const payloadStream = part.payload.stream();
              const reader = payloadStream.getReader();
              try {
                let result;
                while (!(result = await reader.read()).done) {
                  controller.enqueue(result.value);
                }
              } finally {
                reader.releaseLock();
              }
              await writeChunk("\r\n");
            }
            await writeChunk(`--${boundary}--\r
`);
            controller.close();
          }
        });
        return stream;
      }
      async _sendMultipartRequest(parts, context2, options) {
        const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
        const isNodeFetch = _globalFetchImplementationIsNodeFetch();
        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);
        const buildStream = () => this._createMultipartStream(parts, boundary);
        const sendWithRetry = async (bodyFactory) => {
          return this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {
            const body = await bodyFactory();
            const headers = {
              ...this.headers,
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            };
            if (options?.apiKey !== void 0) {
              headers["x-api-key"] = options.apiKey;
            }
            let transformedBody = body;
            if (options?.useGzip && typeof body === "object" && "pipeThrough" in body) {
              transformedBody = body.pipeThrough(new CompressionStream("gzip"));
              headers["Content-Encoding"] = "gzip";
            }
            const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {
              method: "POST",
              headers,
              body: transformedBody,
              duplex: "half",
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions
            });
            await raiseForStatus(response, `Failed to send multipart request`, true);
            return response;
          });
        };
        try {
          let res;
          let streamedAttempt = false;
          if (!isNodeFetch && !this.multipartStreamingDisabled && getEnv2() !== "bun") {
            streamedAttempt = true;
            res = await sendWithRetry(buildStream);
          } else {
            res = await sendWithRetry(buildBuffered);
          }
          if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {
            console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${context2}".`);
            this.multipartStreamingDisabled = true;
            res = await sendWithRetry(buildBuffered);
          }
        } catch (e) {
          if (isLangSmithNotFoundError(e)) {
            throw e;
          }
          console.warn(`${e.message.trim()}

Context: ${context2}`);
        }
      }
      async updateRun(runId, run, options) {
        assertUuid(runId);
        if (run.inputs) {
          run.inputs = await this.processInputs(run.inputs);
        }
        if (run.outputs) {
          run.outputs = await this.processOutputs(run.outputs);
        }
        const data = { ...run, id: runId };
        if (!this._filterForSampling([data], true).length) {
          return;
        }
        if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
          const otelContext = this._cloneCurrentOTELContext();
          if (run.end_time !== void 0 && data.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
            await this.processRunOperation({
              action: "update",
              item: data,
              otelContext,
              apiKey: options?.apiKey,
              apiUrl: options?.apiUrl
            }).catch(console.error);
            return;
          } else {
            void this.processRunOperation({
              action: "update",
              item: data,
              otelContext,
              apiKey: options?.apiKey,
              apiUrl: options?.apiUrl
            }).catch(console.error);
          }
          return;
        }
        const headers = {
          ...this.headers,
          "Content-Type": "application/json"
        };
        if (options?.apiKey !== void 0) {
          headers["x-api-key"] = options.apiKey;
        }
        if (options?.workspaceId !== void 0) {
          headers["x-tenant-id"] = options.workspaceId;
        }
        const body = serialize(run, `Serializing payload to update run with id: ${runId}`);
        await this.caller.call(async () => {
          const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {
            method: "PATCH",
            headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update run", true);
          return res;
        });
      }
      async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
        assertUuid(runId);
        let run = await this._get(`/runs/${runId}`);
        if (loadChildRuns) {
          run = await this._loadChildRuns(run);
        }
        return run;
      }
      async getRunUrl({ runId, run, projectOpts }) {
        if (run !== void 0) {
          let sessionId;
          if (run.session_id) {
            sessionId = run.session_id;
          } else if (projectOpts?.projectName) {
            sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;
          } else if (projectOpts?.projectId) {
            sessionId = projectOpts?.projectId;
          } else {
            const project = await this.readProject({
              projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
            });
            sessionId = project.id;
          }
          const tenantId = await this._getTenantId();
          return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
        } else if (runId !== void 0) {
          const run_ = await this.readRun(runId);
          if (!run_.app_path) {
            throw new Error(`Run ${runId} has no app_path`);
          }
          const baseUrl = this.getHostUrl();
          return `${baseUrl}${run_.app_path}`;
        } else {
          throw new Error("Must provide either runId or run");
        }
      }
      async _loadChildRuns(run) {
        const childRuns = await toArray(this.listRuns({
          isRoot: false,
          projectId: run.session_id,
          traceId: run.trace_id
        }));
        const treemap = {};
        const runs = {};
        childRuns.sort((a, b) => (a?.dotted_order ?? "").localeCompare(b?.dotted_order ?? ""));
        for (const childRun of childRuns) {
          if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
            throw new Error(`Child run ${childRun.id} has no parent`);
          }
          if (childRun.dotted_order?.startsWith(run.dotted_order ?? "") && childRun.id !== run.id) {
            if (!(childRun.parent_run_id in treemap)) {
              treemap[childRun.parent_run_id] = [];
            }
            treemap[childRun.parent_run_id].push(childRun);
            runs[childRun.id] = childRun;
          }
        }
        run.child_runs = treemap[run.id] || [];
        for (const runId in treemap) {
          if (runId !== run.id) {
            runs[runId].child_runs = treemap[runId];
          }
        }
        return run;
      }
      /**
       * List runs from the LangSmith server.
       * @param projectId - The ID of the project to filter by.
       * @param projectName - The name of the project to filter by.
       * @param parentRunId - The ID of the parent run to filter by.
       * @param traceId - The ID of the trace to filter by.
       * @param referenceExampleId - The ID of the reference example to filter by.
       * @param startTime - The start time to filter by.
       * @param isRoot - Indicates whether to only return root runs.
       * @param runType - The run type to filter by.
       * @param error - Indicates whether to filter by error runs.
       * @param id - The ID of the run to filter by.
       * @param query - The query string to filter by.
       * @param filter - The filter string to apply to the run spans.
       * @param traceFilter - The filter string to apply on the root run of the trace.
       * @param treeFilter - The filter string to apply on other runs in the trace.
       * @param limit - The maximum number of runs to retrieve.
       * @returns {AsyncIterable<Run>} - The runs.
       *
       * @example
       * // List all runs in a project
       * const projectRuns = client.listRuns({ projectName: "<your_project>" });
       *
       * @example
       * // List LLM and Chat runs in the last 24 hours
       * const todaysLLMRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
       *   run_type: "llm",
       * });
       *
       * @example
       * // List traces in a project
       * const rootRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   execution_order: 1,
       * });
       *
       * @example
       * // List runs without errors
       * const correctRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   error: false,
       * });
       *
       * @example
       * // List runs by run ID
       * const runIds = [
       *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
       *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
       * ];
       * const selectedRuns = client.listRuns({ run_ids: runIds });
       *
       * @example
       * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
       * const chainRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
       * });
       *
       * @example
       * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
       * const goodExtractorRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'eq(name, "extractor")',
       *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
       * });
       *
       * @example
       * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
       * const complexRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
       * });
       *
       * @example
       * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
       * const taggedRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
       * });
       */
      async *listRuns(props) {
        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error: error40, id, query, filter, traceFilter, treeFilter, limit: limit2, select, order } = props;
        let projectIds = [];
        if (projectId) {
          projectIds = Array.isArray(projectId) ? projectId : [projectId];
        }
        if (projectName) {
          const projectNames = Array.isArray(projectName) ? projectName : [projectName];
          const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
          projectIds.push(...projectIds_);
        }
        const default_select = [
          "app_path",
          "completion_cost",
          "completion_tokens",
          "dotted_order",
          "end_time",
          "error",
          "events",
          "extra",
          "feedback_stats",
          "first_token_time",
          "id",
          "inputs",
          "name",
          "outputs",
          "parent_run_id",
          "parent_run_ids",
          "prompt_cost",
          "prompt_tokens",
          "reference_example_id",
          "run_type",
          "session_id",
          "start_time",
          "status",
          "tags",
          "total_cost",
          "total_tokens",
          "trace_id"
        ];
        const body = {
          session: projectIds.length ? projectIds : null,
          run_type: runType,
          reference_example: referenceExampleId,
          query,
          filter,
          trace_filter: traceFilter,
          tree_filter: treeFilter,
          execution_order: executionOrder,
          parent_run: parentRunId,
          start_time: startTime ? startTime.toISOString() : null,
          error: error40,
          id,
          limit: limit2,
          trace: traceId,
          select: select ? select : default_select,
          is_root: isRoot,
          order
        };
        if (body.select.includes("child_run_ids")) {
          warnOnce("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
        }
        let runsYielded = 0;
        for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
          if (limit2) {
            if (runsYielded >= limit2) {
              break;
            }
            if (runs.length + runsYielded > limit2) {
              const newRuns = runs.slice(0, limit2 - runsYielded);
              yield* newRuns;
              break;
            }
            runsYielded += runs.length;
            yield* runs;
          } else {
            yield* runs;
          }
        }
      }
      async *listGroupRuns(props) {
        const { projectId, projectName, groupBy, filter, startTime, endTime, limit: limit2, offset } = props;
        const sessionId = projectId || (await this.readProject({ projectName })).id;
        const baseBody = {
          session_id: sessionId,
          group_by: groupBy,
          filter,
          start_time: startTime ? startTime.toISOString() : null,
          end_time: endTime ? endTime.toISOString() : null,
          limit: Number(limit2) || 100
        };
        let currentOffset = Number(offset) || 0;
        const path3 = "/runs/group";
        const url2 = `${this.apiUrl}${path3}`;
        while (true) {
          const currentBody = {
            ...baseBody,
            offset: currentOffset
          };
          const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== void 0));
          const body = JSON.stringify(filteredPayload);
          const response = await this.caller.call(async () => {
            const res = await this._fetch(url2, {
              method: "POST",
              headers: { ...this.headers, "Content-Type": "application/json" },
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions,
              body
            });
            await raiseForStatus(res, `Failed to fetch ${path3}`);
            return res;
          });
          const items = await response.json();
          const { groups, total } = items;
          if (groups.length === 0) {
            break;
          }
          for (const thread of groups) {
            yield thread;
          }
          currentOffset += groups.length;
          if (currentOffset >= total) {
            break;
          }
        }
      }
      async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error: error40, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
        let projectIds_ = projectIds || [];
        if (projectNames) {
          projectIds_ = [
            ...projectIds || [],
            ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
          ];
        }
        const payload = {
          id,
          trace,
          parent_run: parentRun,
          run_type: runType,
          session: projectIds_,
          reference_example: referenceExampleIds,
          start_time: startTime,
          end_time: endTime,
          error: error40,
          query,
          filter,
          trace_filter: traceFilter,
          tree_filter: treeFilter,
          is_root: isRoot,
          data_source_type: dataSourceType
        };
        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
        const body = JSON.stringify(filteredPayload);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/stats`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "get run stats");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async shareRun(runId, { shareId } = {}) {
        const data = {
          run_id: runId,
          share_token: shareId || v4_default2()
        };
        assertUuid(runId);
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
            method: "PUT",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "share run");
          return res;
        });
        const result = await response.json();
        if (result === null || !("share_token" in result)) {
          throw new Error("Invalid response from server");
        }
        return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
      }
      async unshareRun(runId) {
        assertUuid(runId);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "unshare run", true);
          return res;
        });
      }
      async readRunSharedLink(runId) {
        assertUuid(runId);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "read run shared link");
          return res;
        });
        const result = await response.json();
        if (result === null || !("share_token" in result)) {
          return void 0;
        }
        return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
      }
      async listSharedRuns(shareToken, { runIds } = {}) {
        const queryParams = new URLSearchParams({
          share_token: shareToken
        });
        if (runIds !== void 0) {
          for (const runId of runIds) {
            queryParams.append("id", runId);
          }
        }
        assertUuid(shareToken);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "list shared runs");
          return res;
        });
        const runs = await response.json();
        return runs;
      }
      async readDatasetSharedSchema(datasetId, datasetName) {
        if (!datasetId && !datasetName) {
          throw new Error("Either datasetId or datasetName must be given");
        }
        if (!datasetId) {
          const dataset = await this.readDataset({ datasetName });
          datasetId = dataset.id;
        }
        assertUuid(datasetId);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "read dataset shared schema");
          return res;
        });
        const shareSchema = await response.json();
        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
        return shareSchema;
      }
      async shareDataset(datasetId, datasetName) {
        if (!datasetId && !datasetName) {
          throw new Error("Either datasetId or datasetName must be given");
        }
        if (!datasetId) {
          const dataset = await this.readDataset({ datasetName });
          datasetId = dataset.id;
        }
        const data = {
          dataset_id: datasetId
        };
        assertUuid(datasetId);
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
            method: "PUT",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "share dataset");
          return res;
        });
        const shareSchema = await response.json();
        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
        return shareSchema;
      }
      async unshareDataset(datasetId) {
        assertUuid(datasetId);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "unshare dataset", true);
          return res;
        });
      }
      async readSharedDataset(shareToken) {
        assertUuid(shareToken);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "read shared dataset");
          return res;
        });
        const dataset = await response.json();
        return dataset;
      }
      /**
       * Get shared examples.
       *
       * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
       * @param {Object} [options] Additional options for listing the examples.
       * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
       * @returns {Promise<Example[]>} The shared examples.
       */
      async listSharedExamples(shareToken, options) {
        const params = {};
        if (options?.exampleIds) {
          params.id = options.exampleIds;
        }
        const urlParams = new URLSearchParams();
        Object.entries(params).forEach(([key, value]) => {
          if (Array.isArray(value)) {
            value.forEach((v) => urlParams.append(key, v));
          } else {
            urlParams.append(key, value);
          }
        });
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "list shared examples");
          return res;
        });
        const result = await response.json();
        if (!response.ok) {
          if ("detail" in result) {
            throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${Array.isArray(result.detail) ? result.detail.join("\n") : "Unspecified error"}`);
          }
          throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
        }
        return result.map((example) => ({
          ...example,
          _hostUrl: this.getHostUrl()
        }));
      }
      async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
        const upsert_ = upsert ? `?upsert=true` : "";
        const endpoint = `${this.apiUrl}/sessions${upsert_}`;
        const extra = projectExtra || {};
        if (metadata) {
          extra["metadata"] = metadata;
        }
        const body = {
          name: projectName,
          extra,
          description
        };
        if (referenceDatasetId !== null) {
          body["reference_dataset_id"] = referenceDatasetId;
        }
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(endpoint, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await raiseForStatus(res, "create project");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
        const endpoint = `${this.apiUrl}/sessions/${projectId}`;
        let extra = projectExtra;
        if (metadata) {
          extra = { ...extra || {}, metadata };
        }
        const body = JSON.stringify({
          name,
          extra,
          description,
          end_time: endTime ? new Date(endTime).toISOString() : null
        });
        const response = await this.caller.call(async () => {
          const res = await this._fetch(endpoint, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update project");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async hasProject({ projectId, projectName }) {
        let path3 = "/sessions";
        const params = new URLSearchParams();
        if (projectId !== void 0 && projectName !== void 0) {
          throw new Error("Must provide either projectName or projectId, not both");
        } else if (projectId !== void 0) {
          assertUuid(projectId);
          path3 += `/${projectId}`;
        } else if (projectName !== void 0) {
          params.append("name", projectName);
        } else {
          throw new Error("Must provide projectName or projectId");
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${path3}?${params}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "has project");
          return res;
        });
        try {
          const result = await response.json();
          if (!response.ok) {
            return false;
          }
          if (Array.isArray(result)) {
            return result.length > 0;
          }
          return true;
        } catch (e) {
          return false;
        }
      }
      async readProject({ projectId, projectName, includeStats }) {
        let path3 = "/sessions";
        const params = new URLSearchParams();
        if (projectId !== void 0 && projectName !== void 0) {
          throw new Error("Must provide either projectName or projectId, not both");
        } else if (projectId !== void 0) {
          assertUuid(projectId);
          path3 += `/${projectId}`;
        } else if (projectName !== void 0) {
          params.append("name", projectName);
        } else {
          throw new Error("Must provide projectName or projectId");
        }
        if (includeStats !== void 0) {
          params.append("include_stats", includeStats.toString());
        }
        const response = await this._get(path3, params);
        let result;
        if (Array.isArray(response)) {
          if (response.length === 0) {
            throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
          }
          result = response[0];
        } else {
          result = response;
        }
        return result;
      }
      async getProjectUrl({ projectId, projectName }) {
        if (projectId === void 0 && projectName === void 0) {
          throw new Error("Must provide either projectName or projectId");
        }
        const project = await this.readProject({ projectId, projectName });
        const tenantId = await this._getTenantId();
        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
      }
      async getDatasetUrl({ datasetId, datasetName }) {
        if (datasetId === void 0 && datasetName === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const dataset = await this.readDataset({ datasetId, datasetName });
        const tenantId = await this._getTenantId();
        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
      }
      async _getTenantId() {
        if (this._tenantId !== null) {
          return this._tenantId;
        }
        const queryParams = new URLSearchParams({ limit: "1" });
        for await (const projects of this._getPaginated("/sessions", queryParams)) {
          this._tenantId = projects[0].tenant_id;
          return projects[0].tenant_id;
        }
        throw new Error("No projects found to resolve tenant.");
      }
      async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata } = {}) {
        const params = new URLSearchParams();
        if (projectIds !== void 0) {
          for (const projectId of projectIds) {
            params.append("id", projectId);
          }
        }
        if (name !== void 0) {
          params.append("name", name);
        }
        if (nameContains !== void 0) {
          params.append("name_contains", nameContains);
        }
        if (referenceDatasetId !== void 0) {
          params.append("reference_dataset", referenceDatasetId);
        } else if (referenceDatasetName !== void 0) {
          const dataset = await this.readDataset({
            datasetName: referenceDatasetName
          });
          params.append("reference_dataset", dataset.id);
        }
        if (includeStats !== void 0) {
          params.append("include_stats", includeStats.toString());
        }
        if (datasetVersion !== void 0) {
          params.append("dataset_version", datasetVersion);
        }
        if (referenceFree !== void 0) {
          params.append("reference_free", referenceFree.toString());
        }
        if (metadata !== void 0) {
          params.append("metadata", JSON.stringify(metadata));
        }
        for await (const projects of this._getPaginated("/sessions", params)) {
          yield* projects;
        }
      }
      async deleteProject({ projectId, projectName }) {
        let projectId_;
        if (projectId === void 0 && projectName === void 0) {
          throw new Error("Must provide projectName or projectId");
        } else if (projectId !== void 0 && projectName !== void 0) {
          throw new Error("Must provide either projectName or projectId, not both");
        } else if (projectId === void 0) {
          projectId_ = (await this.readProject({ projectName })).id;
        } else {
          projectId_ = projectId;
        }
        assertUuid(projectId_);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, `delete session ${projectId_} (${projectName})`, true);
          return res;
        });
      }
      async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
        const url2 = `${this.apiUrl}/datasets/upload`;
        const formData = new FormData();
        const csvBlob = new Blob([csvFile], { type: "text/csv" });
        formData.append("file", csvBlob, fileName);
        inputKeys.forEach((key) => {
          formData.append("input_keys", key);
        });
        outputKeys.forEach((key) => {
          formData.append("output_keys", key);
        });
        if (description) {
          formData.append("description", description);
        }
        if (dataType) {
          formData.append("data_type", dataType);
        }
        if (name) {
          formData.append("name", name);
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(url2, {
            method: "POST",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: formData
          });
          await raiseForStatus(res, "upload CSV");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
        const body = {
          name,
          description,
          extra: metadata ? { metadata } : void 0
        };
        if (dataType) {
          body.data_type = dataType;
        }
        if (inputsSchema) {
          body.inputs_schema_definition = inputsSchema;
        }
        if (outputsSchema) {
          body.outputs_schema_definition = outputsSchema;
        }
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await raiseForStatus(res, "create dataset");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async readDataset({ datasetId, datasetName }) {
        let path3 = "/datasets";
        const params = new URLSearchParams({ limit: "1" });
        if (datasetId && datasetName) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId) {
          assertUuid(datasetId);
          path3 += `/${datasetId}`;
        } else if (datasetName) {
          params.append("name", datasetName);
        } else {
          throw new Error("Must provide datasetName or datasetId");
        }
        const response = await this._get(path3, params);
        let result;
        if (Array.isArray(response)) {
          if (response.length === 0) {
            throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
          }
          result = response[0];
        } else {
          result = response;
        }
        return result;
      }
      async hasDataset({ datasetId, datasetName }) {
        try {
          await this.readDataset({ datasetId, datasetName });
          return true;
        } catch (e) {
          if (
            // eslint-disable-next-line no-instanceof/no-instanceof
            e instanceof Error && e.message.toLocaleLowerCase().includes("not found")
          ) {
            return false;
          }
          throw e;
        }
      }
      async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
        let datasetId_ = datasetId;
        if (datasetId_ === void 0 && datasetName === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId_ === void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        }
        const urlParams = new URLSearchParams({
          from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
          to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
        });
        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
        return response;
      }
      async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
        const path3 = "/datasets";
        if (datasetId !== void 0) {
        } else if (datasetName !== void 0) {
          datasetId = (await this.readDataset({ datasetName })).id;
        } else {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const response = await this._getResponse(`${path3}/${datasetId}/openai_ft`);
        const datasetText = await response.text();
        const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
        return dataset;
      }
      async *listDatasets({ limit: limit2 = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
        const path3 = "/datasets";
        const params = new URLSearchParams({
          limit: limit2.toString(),
          offset: offset.toString()
        });
        if (datasetIds !== void 0) {
          for (const id_ of datasetIds) {
            params.append("id", id_);
          }
        }
        if (datasetName !== void 0) {
          params.append("name", datasetName);
        }
        if (datasetNameContains !== void 0) {
          params.append("name_contains", datasetNameContains);
        }
        if (metadata !== void 0) {
          params.append("metadata", JSON.stringify(metadata));
        }
        for await (const datasets of this._getPaginated(path3, params)) {
          yield* datasets;
        }
      }
      /**
       * Update a dataset
       * @param props The dataset details to update
       * @returns The updated dataset
       */
      async updateDataset(props) {
        const { datasetId, datasetName, ...update } = props;
        if (!datasetId && !datasetName) {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
        assertUuid(_datasetId);
        const body = JSON.stringify(update);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update dataset");
          return res;
        });
        return await response.json();
      }
      /**
       * Updates a tag on a dataset.
       *
       * If the tag is already assigned to a different version of this dataset,
       * the tag will be moved to the new version. The as_of parameter is used to
       * determine which version of the dataset to apply the new tags to.
       *
       * It must be an exact version of the dataset to succeed. You can
       * use the "readDatasetVersion" method to find the exact version
       * to apply the tags to.
       * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
       * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
       * @param params.asOf The timestamp of the dataset to apply the new tags to.
       * @param params.tag The new tag to apply to the dataset.
       */
      async updateDatasetTag(props) {
        const { datasetId, datasetName, asOf, tag } = props;
        if (!datasetId && !datasetName) {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
        assertUuid(_datasetId);
        const body = JSON.stringify({
          as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
          tag
        });
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {
            method: "PUT",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update dataset tags", true);
          return res;
        });
      }
      async deleteDataset({ datasetId, datasetName }) {
        let path3 = "/datasets";
        let datasetId_ = datasetId;
        if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetName !== void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        }
        if (datasetId_ !== void 0) {
          assertUuid(datasetId_);
          path3 += `/${datasetId_}`;
        } else {
          throw new Error("Must provide datasetName or datasetId");
        }
        await this.caller.call(async () => {
          const res = await this._fetch(this.apiUrl + path3, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, `delete ${path3}`, true);
          return res;
        });
      }
      async indexDataset({ datasetId, datasetName, tag }) {
        let datasetId_ = datasetId;
        if (!datasetId_ && !datasetName) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ && datasetName) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (!datasetId_) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        }
        assertUuid(datasetId_);
        const data = {
          tag
        };
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "index dataset");
          return res;
        });
        await response.json();
      }
      /**
       * Lets you run a similarity search query on a dataset.
       *
       * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
       *
       * @param inputs      The input on which to run the similarity search. Must have the
       *                    same schema as the dataset.
       *
       * @param datasetId   The dataset to search for similar examples.
       *
       * @param limit       The maximum number of examples to return. Will return the top `limit` most
       *                    similar examples in order of most similar to least similar. If no similar
       *                    examples are found, random examples will be returned.
       *
       * @param filter      A filter string to apply to the search. Only examples will be returned that
       *                    match the filter string. Some examples of filters
       *
       *                    - eq(metadata.mykey, "value")
       *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
       *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
       *
       * @returns           A list of similar examples.
       *
       *
       * @example
       * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
       * inputs = {"text": "How many people live in Berlin?"}
       * limit = 5
       * examples = await client.similarExamples(inputs, dataset_id, limit)
       */
      async similarExamples(inputs, datasetId, limit2, { filter } = {}) {
        const data = {
          limit: limit2,
          inputs
        };
        if (filter !== void 0) {
          data["filter"] = filter;
        }
        assertUuid(datasetId);
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            method: "POST",
            body
          });
          await raiseForStatus(res, "fetch similar examples");
          return res;
        });
        const result = await response.json();
        return result["examples"];
      }
      async createExample(inputsOrUpdate, outputs, options) {
        if (isExampleCreate(inputsOrUpdate)) {
          if (outputs !== void 0 || options !== void 0) {
            throw new Error("Cannot provide outputs or options when using ExampleCreate object");
          }
        }
        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;
        const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;
        if (datasetId_ === void 0 && datasetName_ === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId_ === void 0) {
          const dataset = await this.readDataset({ datasetName: datasetName_ });
          datasetId_ = dataset.id;
        }
        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || /* @__PURE__ */ new Date();
        let data;
        if (!isExampleCreate(inputsOrUpdate)) {
          data = {
            inputs: inputsOrUpdate,
            outputs,
            created_at: createdAt_?.toISOString(),
            id: options?.exampleId,
            metadata: options?.metadata,
            split: options?.split,
            source_run_id: options?.sourceRunId,
            use_source_run_io: options?.useSourceRunIO,
            use_source_run_attachments: options?.useSourceRunAttachments,
            attachments: options?.attachments
          };
        } else {
          data = inputsOrUpdate;
        }
        const response = await this._uploadExamplesMultipart(datasetId_, [data]);
        const example = await this.readExample(response.example_ids?.[0] ?? v4_default2());
        return example;
      }
      async createExamples(propsOrUploads) {
        if (Array.isArray(propsOrUploads)) {
          if (propsOrUploads.length === 0) {
            return [];
          }
          const uploads = propsOrUploads;
          let datasetId_2 = uploads[0].dataset_id;
          const datasetName_2 = uploads[0].dataset_name;
          if (datasetId_2 === void 0 && datasetName_2 === void 0) {
            throw new Error("Must provide either datasetName or datasetId");
          } else if (datasetId_2 !== void 0 && datasetName_2 !== void 0) {
            throw new Error("Must provide either datasetName or datasetId, not both");
          } else if (datasetId_2 === void 0) {
            const dataset = await this.readDataset({ datasetName: datasetName_2 });
            datasetId_2 = dataset.id;
          }
          const response2 = await this._uploadExamplesMultipart(datasetId_2, uploads);
          const examples2 = await Promise.all(response2.example_ids.map((id) => this.readExample(id)));
          return examples2;
        }
        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
        if (inputs === void 0) {
          throw new Error("Must provide inputs when using legacy parameters");
        }
        let datasetId_ = datasetId;
        const datasetName_ = datasetName;
        if (datasetId_ === void 0 && datasetName_ === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId_ === void 0) {
          const dataset = await this.readDataset({ datasetName: datasetName_ });
          datasetId_ = dataset.id;
        }
        const formattedExamples = inputs.map((input, idx) => {
          return {
            dataset_id: datasetId_,
            inputs: input,
            outputs: outputs?.[idx],
            metadata: metadata?.[idx],
            split: splits?.[idx],
            id: exampleIds?.[idx],
            attachments: attachments?.[idx],
            source_run_id: sourceRunIds?.[idx],
            use_source_run_io: useSourceRunIOs?.[idx],
            use_source_run_attachments: useSourceRunAttachments?.[idx]
          };
        });
        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));
        return examples;
      }
      async createLLMExample(input, generation, options) {
        return this.createExample({ input }, { output: generation }, options);
      }
      async createChatExample(input, generations, options) {
        const finalInput = input.map((message) => {
          if (isLangChainMessage(message)) {
            return convertLangChainMessageToExample(message);
          }
          return message;
        });
        const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
        return this.createExample({ input: finalInput }, { output: finalOutput }, options);
      }
      async readExample(exampleId) {
        assertUuid(exampleId);
        const path3 = `/examples/${exampleId}`;
        const rawExample = await this._get(path3);
        const { attachment_urls, ...rest } = rawExample;
        const example = rest;
        if (attachment_urls) {
          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
            acc[key.slice("attachment.".length)] = {
              presigned_url: value.presigned_url,
              mime_type: value.mime_type
            };
            return acc;
          }, {});
        }
        return example;
      }
      async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit: limit2, offset, filter, includeAttachments } = {}) {
        let datasetId_;
        if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId !== void 0) {
          datasetId_ = datasetId;
        } else if (datasetName !== void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        } else {
          throw new Error("Must provide a datasetName or datasetId");
        }
        const params = new URLSearchParams({ dataset: datasetId_ });
        const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : void 0;
        if (dataset_version) {
          params.append("as_of", dataset_version);
        }
        const inlineS3Urls_ = inlineS3Urls ?? true;
        params.append("inline_s3_urls", inlineS3Urls_.toString());
        if (exampleIds !== void 0) {
          for (const id_ of exampleIds) {
            params.append("id", id_);
          }
        }
        if (splits !== void 0) {
          for (const split of splits) {
            params.append("splits", split);
          }
        }
        if (metadata !== void 0) {
          const serializedMetadata = JSON.stringify(metadata);
          params.append("metadata", serializedMetadata);
        }
        if (limit2 !== void 0) {
          params.append("limit", limit2.toString());
        }
        if (offset !== void 0) {
          params.append("offset", offset.toString());
        }
        if (filter !== void 0) {
          params.append("filter", filter);
        }
        if (includeAttachments === true) {
          ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
        }
        let i = 0;
        for await (const rawExamples of this._getPaginated("/examples", params)) {
          for (const rawExample of rawExamples) {
            const { attachment_urls, ...rest } = rawExample;
            const example = rest;
            if (attachment_urls) {
              example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
                acc[key.slice("attachment.".length)] = {
                  presigned_url: value.presigned_url,
                  mime_type: value.mime_type || void 0
                };
                return acc;
              }, {});
            }
            yield example;
            i++;
          }
          if (limit2 !== void 0 && i >= limit2) {
            break;
          }
        }
      }
      async deleteExample(exampleId) {
        assertUuid(exampleId);
        const path3 = `/examples/${exampleId}`;
        await this.caller.call(async () => {
          const res = await this._fetch(this.apiUrl + path3, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, `delete ${path3}`, true);
          return res;
        });
      }
      /**
       * Delete multiple examples by ID.
       * @param exampleIds - The IDs of the examples to delete
       * @param options - Optional settings for deletion
       * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.
       */
      async deleteExamples(exampleIds, options) {
        exampleIds.forEach((id) => assertUuid(id));
        if (options?.hardDelete) {
          const path3 = this._getPlatformEndpointPath("datasets/examples/delete");
          await this.caller.call(async () => {
            const res = await this._fetch(`${this.apiUrl}${path3}`, {
              method: "POST",
              headers: { ...this.headers, "Content-Type": "application/json" },
              body: JSON.stringify({
                example_ids: exampleIds,
                hard_delete: true
              }),
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions
            });
            await raiseForStatus(res, "hard delete examples", true);
            return res;
          });
        } else {
          const params = new URLSearchParams();
          exampleIds.forEach((id) => params.append("example_ids", id));
          await this.caller.call(async () => {
            const res = await this._fetch(`${this.apiUrl}/examples?${params.toString()}`, {
              method: "DELETE",
              headers: this.headers,
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions
            });
            await raiseForStatus(res, "delete examples", true);
            return res;
          });
        }
      }
      async updateExample(exampleIdOrUpdate, update) {
        let exampleId;
        if (update) {
          exampleId = exampleIdOrUpdate;
        } else {
          exampleId = exampleIdOrUpdate.id;
        }
        assertUuid(exampleId);
        let updateToUse;
        if (update) {
          updateToUse = { id: exampleId, ...update };
        } else {
          updateToUse = exampleIdOrUpdate;
        }
        let datasetId;
        if (updateToUse.dataset_id !== void 0) {
          datasetId = updateToUse.dataset_id;
        } else {
          const example = await this.readExample(exampleId);
          datasetId = example.dataset_id;
        }
        return this._updateExamplesMultipart(datasetId, [updateToUse]);
      }
      async updateExamples(update) {
        let datasetId;
        if (update[0].dataset_id === void 0) {
          const example = await this.readExample(update[0].id);
          datasetId = example.dataset_id;
        } else {
          datasetId = update[0].dataset_id;
        }
        return this._updateExamplesMultipart(datasetId, update);
      }
      /**
       * Get dataset version by closest date or exact tag.
       *
       * Use this to resolve the nearest version to a given timestamp or for a given tag.
       *
       * @param options The options for getting the dataset version
       * @param options.datasetId The ID of the dataset
       * @param options.datasetName The name of the dataset
       * @param options.asOf The timestamp of the dataset to retrieve
       * @param options.tag The tag of the dataset to retrieve
       * @returns The dataset version
       */
      async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
        let resolvedDatasetId;
        if (!datasetId) {
          const dataset = await this.readDataset({ datasetName });
          resolvedDatasetId = dataset.id;
        } else {
          resolvedDatasetId = datasetId;
        }
        assertUuid(resolvedDatasetId);
        if (asOf && tag || !asOf && !tag) {
          throw new Error("Exactly one of asOf and tag must be specified.");
        }
        const params = new URLSearchParams();
        if (asOf !== void 0) {
          params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
        }
        if (tag !== void 0) {
          params.append("tag", tag);
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
            method: "GET",
            headers: { ...this.headers },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "read dataset version");
          return res;
        });
        return await response.json();
      }
      async listDatasetSplits({ datasetId, datasetName, asOf }) {
        let datasetId_;
        if (datasetId === void 0 && datasetName === void 0) {
          throw new Error("Must provide dataset name or ID");
        } else if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId === void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        } else {
          datasetId_ = datasetId;
        }
        assertUuid(datasetId_);
        const params = new URLSearchParams();
        const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : void 0;
        if (dataset_version) {
          params.append("as_of", dataset_version);
        }
        const response = await this._get(`/datasets/${datasetId_}/splits`, params);
        return response;
      }
      async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
        let datasetId_;
        if (datasetId === void 0 && datasetName === void 0) {
          throw new Error("Must provide dataset name or ID");
        } else if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId === void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        } else {
          datasetId_ = datasetId;
        }
        assertUuid(datasetId_);
        const data = {
          split_name: splitName,
          examples: exampleIds.map((id) => {
            assertUuid(id);
            return id;
          }),
          remove
        };
        const body = JSON.stringify(data);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {
            method: "PUT",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update dataset splits", true);
          return res;
        });
      }
      async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
        if (!runId && !projectId) {
          throw new Error("One of runId or projectId must be provided");
        }
        if (runId && projectId) {
          throw new Error("Only one of runId or projectId can be provided");
        }
        const feedback_source = {
          type: feedbackSourceType ?? "api",
          metadata: sourceInfo ?? {}
        };
        if (sourceRunId !== void 0 && feedback_source?.metadata !== void 0 && !feedback_source.metadata["__run"]) {
          feedback_source.metadata["__run"] = { run_id: sourceRunId };
        }
        if (feedback_source?.metadata !== void 0 && feedback_source.metadata["__run"]?.run_id !== void 0) {
          assertUuid(feedback_source.metadata["__run"].run_id);
        }
        const feedback = {
          id: feedbackId ?? v4_default2(),
          run_id: runId,
          key,
          score: _formatFeedbackScore(score),
          value,
          correction,
          comment,
          feedback_source,
          comparative_experiment_id: comparativeExperimentId,
          feedbackConfig,
          session_id: projectId
        };
        const body = JSON.stringify(feedback);
        const url2 = `${this.apiUrl}/feedback`;
        await this.caller.call(async () => {
          const res = await this._fetch(url2, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "create feedback", true);
          return res;
        });
        return feedback;
      }
      async updateFeedback(feedbackId, { score, value, correction, comment }) {
        const feedbackUpdate = {};
        if (score !== void 0 && score !== null) {
          feedbackUpdate["score"] = _formatFeedbackScore(score);
        }
        if (value !== void 0 && value !== null) {
          feedbackUpdate["value"] = value;
        }
        if (correction !== void 0 && correction !== null) {
          feedbackUpdate["correction"] = correction;
        }
        if (comment !== void 0 && comment !== null) {
          feedbackUpdate["comment"] = comment;
        }
        assertUuid(feedbackId);
        const body = JSON.stringify(feedbackUpdate);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update feedback", true);
          return res;
        });
      }
      async readFeedback(feedbackId) {
        assertUuid(feedbackId);
        const path3 = `/feedback/${feedbackId}`;
        const response = await this._get(path3);
        return response;
      }
      async deleteFeedback(feedbackId) {
        assertUuid(feedbackId);
        const path3 = `/feedback/${feedbackId}`;
        await this.caller.call(async () => {
          const res = await this._fetch(this.apiUrl + path3, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, `delete ${path3}`, true);
          return res;
        });
      }
      async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
        const queryParams = new URLSearchParams();
        if (runIds) {
          for (const runId of runIds) {
            assertUuid(runId);
            queryParams.append("run", runId);
          }
        }
        if (feedbackKeys) {
          for (const key of feedbackKeys) {
            queryParams.append("key", key);
          }
        }
        if (feedbackSourceTypes) {
          for (const type of feedbackSourceTypes) {
            queryParams.append("source", type);
          }
        }
        for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
          yield* feedbacks;
        }
      }
      /**
       * Creates a presigned feedback token and URL.
       *
       * The token can be used to authorize feedback metrics without
       * needing an API key. This is useful for giving browser-based
       * applications the ability to submit feedback without needing
       * to expose an API key.
       *
       * @param runId The ID of the run.
       * @param feedbackKey The feedback key.
       * @param options Additional options for the token.
       * @param options.expiration The expiration time for the token.
       *
       * @returns A promise that resolves to a FeedbackIngestToken.
       */
      async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
        const body = {
          run_id: runId,
          feedback_key: feedbackKey,
          feedback_config: feedbackConfig
        };
        if (expiration) {
          if (typeof expiration === "string") {
            body["expires_at"] = expiration;
          } else if (expiration?.hours || expiration?.minutes || expiration?.days) {
            body["expires_in"] = expiration;
          }
        } else {
          body["expires_in"] = {
            hours: 3
          };
        }
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await raiseForStatus(res, "create presigned feedback token");
          return res;
        });
        return await response.json();
      }
      async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
        if (experimentIds.length === 0) {
          throw new Error("At least one experiment is required");
        }
        if (!referenceDatasetId) {
          referenceDatasetId = (await this.readProject({
            projectId: experimentIds[0]
          })).reference_dataset_id;
        }
        if (!referenceDatasetId == null) {
          throw new Error("A reference dataset is required");
        }
        const body = {
          id,
          name,
          experiment_ids: experimentIds,
          reference_dataset_id: referenceDatasetId,
          description,
          created_at: (createdAt ?? /* @__PURE__ */ new Date())?.toISOString(),
          extra: {}
        };
        if (metadata)
          body.extra["metadata"] = metadata;
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await raiseForStatus(res, "create comparative experiment");
          return res;
        });
        return response.json();
      }
      /**
       * Retrieves a list of presigned feedback tokens for a given run ID.
       * @param runId The ID of the run.
       * @returns An async iterable of FeedbackIngestToken objects.
       */
      async *listPresignedFeedbackTokens(runId) {
        assertUuid(runId);
        const params = new URLSearchParams({ run_id: runId });
        for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
          yield* tokens;
        }
      }
      _selectEvalResults(results) {
        let results_;
        if ("results" in results) {
          results_ = results.results;
        } else if (Array.isArray(results)) {
          results_ = results;
        } else {
          results_ = [results];
        }
        return results_;
      }
      async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
        const evalResults = this._selectEvalResults(evaluatorResponse);
        const feedbacks = [];
        for (const res of evalResults) {
          let sourceInfo_ = sourceInfo || {};
          if (res.evaluatorInfo) {
            sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
          }
          let runId_ = null;
          if (res.targetRunId) {
            runId_ = res.targetRunId;
          } else if (run) {
            runId_ = run.id;
          }
          feedbacks.push(await this.createFeedback(runId_, res.key, {
            score: res.score,
            value: res.value,
            comment: res.comment,
            correction: res.correction,
            sourceInfo: sourceInfo_,
            sourceRunId: res.sourceRunId,
            feedbackConfig: res.feedbackConfig,
            feedbackSourceType: "model"
          }));
        }
        return [evalResults, feedbacks];
      }
      async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
        return results;
      }
      /**
       * API for managing annotation queues
       */
      /**
       * List the annotation queues on the LangSmith API.
       * @param options - The options for listing annotation queues
       * @param options.queueIds - The IDs of the queues to filter by
       * @param options.name - The name of the queue to filter by
       * @param options.nameContains - The substring that the queue name should contain
       * @param options.limit - The maximum number of queues to return
       * @returns An iterator of AnnotationQueue objects
       */
      async *listAnnotationQueues(options = {}) {
        const { queueIds, name, nameContains, limit: limit2 } = options;
        const params = new URLSearchParams();
        if (queueIds) {
          queueIds.forEach((id, i) => {
            assertUuid(id, `queueIds[${i}]`);
            params.append("ids", id);
          });
        }
        if (name)
          params.append("name", name);
        if (nameContains)
          params.append("name_contains", nameContains);
        params.append("limit", (limit2 !== void 0 ? Math.min(limit2, 100) : 100).toString());
        let count = 0;
        for await (const queues of this._getPaginated("/annotation-queues", params)) {
          yield* queues;
          count++;
          if (limit2 !== void 0 && count >= limit2)
            break;
        }
      }
      /**
       * Create an annotation queue on the LangSmith API.
       * @param options - The options for creating an annotation queue
       * @param options.name - The name of the annotation queue
       * @param options.description - The description of the annotation queue
       * @param options.queueId - The ID of the annotation queue
       * @returns The created AnnotationQueue object
       */
      async createAnnotationQueue(options) {
        const { name, description, queueId, rubricInstructions } = options;
        const body = {
          name,
          description,
          id: queueId || v4_default2(),
          rubric_instructions: rubricInstructions
        };
        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== void 0)));
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await raiseForStatus(res, "create annotation queue");
          return res;
        });
        return response.json();
      }
      /**
       * Read an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue to read
       * @returns The AnnotationQueueWithDetails object
       */
      async readAnnotationQueue(queueId) {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "read annotation queue");
          return res;
        });
        return response.json();
      }
      /**
       * Update an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue to update
       * @param options - The options for updating the annotation queue
       * @param options.name - The new name for the annotation queue
       * @param options.description - The new description for the annotation queue
       */
      async updateAnnotationQueue(queueId, options) {
        const { name, description, rubricInstructions } = options;
        const body = JSON.stringify({
          name,
          description,
          rubric_instructions: rubricInstructions
        });
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update annotation queue", true);
          return res;
        });
      }
      /**
       * Delete an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue to delete
       */
      async deleteAnnotationQueue(queueId) {
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
            method: "DELETE",
            headers: { ...this.headers, Accept: "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "delete annotation queue", true);
          return res;
        });
      }
      /**
       * Add runs to an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue
       * @param runIds - The IDs of the runs to be added to the annotation queue
       */
      async addRunsToAnnotationQueue(queueId, runIds) {
        const body = JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString()));
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "add runs to annotation queue", true);
          return res;
        });
      }
      /**
       * Get a run from an annotation queue at the specified index.
       * @param queueId - The ID of the annotation queue
       * @param index - The index of the run to retrieve
       * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
       * @throws {Error} If the run is not found at the given index or for other API-related errors
       */
      async getRunFromAnnotationQueue(queueId, index2) {
        const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index2}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "get run from annotation queue");
          return res;
        });
        return response.json();
      }
      /**
       * Delete a run from an an annotation queue.
       * @param queueId - The ID of the annotation queue to delete the run from
       * @param queueRunId - The ID of the run to delete from the annotation queue
       */
      async deleteRunFromAnnotationQueue(queueId, queueRunId) {
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
            method: "DELETE",
            headers: { ...this.headers, Accept: "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "delete run from annotation queue", true);
          return res;
        });
      }
      /**
       * Get the size of an annotation queue.
       * @param queueId - The ID of the annotation queue
       */
      async getSizeFromAnnotationQueue(queueId) {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "get size from annotation queue");
          return res;
        });
        return response.json();
      }
      async _currentTenantIsOwner(owner) {
        const settings = await this._getSettings();
        return owner == "-" || settings.tenant_handle === owner;
      }
      async _ownerConflictError(action, owner) {
        const settings = await this._getSettings();
        return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
      }
      async _getLatestCommitHash(promptOwnerAndName) {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "get latest commit hash");
          return res;
        });
        const json2 = await response.json();
        if (json2.commits.length === 0) {
          return void 0;
        }
        return json2.commits[0].commit_hash;
      }
      async _likeOrUnlikePrompt(promptIdentifier, like) {
        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
        const body = JSON.stringify({ like });
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, `${like ? "like" : "unlike"} prompt`);
          return res;
        });
        return response.json();
      }
      async _getPromptUrl(promptIdentifier) {
        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          if (commitHash !== "latest") {
            return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
          } else {
            return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
          }
        } else {
          const settings = await this._getSettings();
          if (commitHash !== "latest") {
            return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
          } else {
            return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
          }
        }
      }
      async promptExists(promptIdentifier) {
        const prompt = await this.getPrompt(promptIdentifier);
        return !!prompt;
      }
      async likePrompt(promptIdentifier) {
        return this._likeOrUnlikePrompt(promptIdentifier, true);
      }
      async unlikePrompt(promptIdentifier) {
        return this._likeOrUnlikePrompt(promptIdentifier, false);
      }
      async *listCommits(promptOwnerAndName) {
        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
          yield* commits;
        }
      }
      async *listPrompts(options) {
        const params = new URLSearchParams();
        params.append("sort_field", options?.sortField ?? "updated_at");
        params.append("sort_direction", "desc");
        params.append("is_archived", (!!options?.isArchived).toString());
        if (options?.isPublic !== void 0) {
          params.append("is_public", options.isPublic.toString());
        }
        if (options?.query) {
          params.append("query", options.query);
        }
        for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
          yield* prompts;
        }
      }
      async getPrompt(promptIdentifier) {
        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          if (res?.status === 404) {
            return null;
          }
          await raiseForStatus(res, "get prompt");
          return res;
        });
        const result = await response?.json();
        if (result?.repo) {
          return result.repo;
        } else {
          return null;
        }
      }
      async createPrompt(promptIdentifier, options) {
        const settings = await this._getSettings();
        if (options?.isPublic && !settings.tenant_handle) {
          throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
        }
        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          throw await this._ownerConflictError("create a prompt", owner);
        }
        const data = {
          repo_handle: promptName,
          ...options?.description && { description: options.description },
          ...options?.readme && { readme: options.readme },
          ...options?.tags && { tags: options.tags },
          is_public: !!options?.isPublic
        };
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "create prompt");
          return res;
        });
        const { repo } = await response.json();
        return repo;
      }
      async createCommit(promptIdentifier, object2, options) {
        if (!await this.promptExists(promptIdentifier)) {
          throw new Error("Prompt does not exist, you must create it first.");
        }
        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
        const resolvedParentCommitHash = options?.parentCommitHash === "latest" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;
        const payload = {
          manifest: JSON.parse(JSON.stringify(object2)),
          parent_commit: resolvedParentCommitHash
        };
        const body = JSON.stringify(payload);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "create commit");
          return res;
        });
        const result = await response.json();
        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
      }
      /**
       * Update examples with attachments using multipart form data.
       * @param updates List of ExampleUpdateWithAttachments objects to upsert
       * @returns Promise with the update response
       */
      async updateExamplesMultipart(datasetId, updates = []) {
        return this._updateExamplesMultipart(datasetId, updates);
      }
      async _updateExamplesMultipart(datasetId, updates = []) {
        if (!await this._getDatasetExamplesMultiPartSupport()) {
          throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
        }
        const formData = new FormData();
        for (const example of updates) {
          const exampleId = example.id;
          const exampleBody = {
            ...example.metadata && { metadata: example.metadata },
            ...example.split && { split: example.split }
          };
          const stringifiedExample = serialize(exampleBody, `Serializing body for example with id: ${exampleId}`);
          const exampleBlob = new Blob([stringifiedExample], {
            type: "application/json"
          });
          formData.append(exampleId, exampleBlob);
          if (example.inputs) {
            const stringifiedInputs = serialize(example.inputs, `Serializing inputs for example with id: ${exampleId}`);
            const inputsBlob = new Blob([stringifiedInputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.inputs`, inputsBlob);
          }
          if (example.outputs) {
            const stringifiedOutputs = serialize(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);
            const outputsBlob = new Blob([stringifiedOutputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.outputs`, outputsBlob);
          }
          if (example.attachments) {
            for (const [name, attachment] of Object.entries(example.attachments)) {
              let mimeType;
              let data;
              if (Array.isArray(attachment)) {
                [mimeType, data] = attachment;
              } else {
                mimeType = attachment.mimeType;
                data = attachment.data;
              }
              const attachmentBlob = new Blob([data], {
                type: `${mimeType}; length=${data.byteLength}`
              });
              formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
            }
          }
          if (example.attachments_operations) {
            const stringifiedAttachmentsOperations = serialize(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);
            const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
              type: "application/json"
            });
            formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
          }
        }
        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {
            method: "PATCH",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: formData
          });
          await raiseForStatus(res, "update examples");
          return res;
        });
        return response.json();
      }
      /**
       * Upload examples with attachments using multipart form data.
       * @param uploads List of ExampleUploadWithAttachments objects to upload
       * @returns Promise with the upload response
       * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
       */
      async uploadExamplesMultipart(datasetId, uploads = []) {
        return this._uploadExamplesMultipart(datasetId, uploads);
      }
      async _uploadExamplesMultipart(datasetId, uploads = []) {
        if (!await this._getDatasetExamplesMultiPartSupport()) {
          throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
        }
        const formData = new FormData();
        for (const example of uploads) {
          const exampleId = (example.id ?? v4_default2()).toString();
          const exampleBody = {
            created_at: example.created_at,
            ...example.metadata && { metadata: example.metadata },
            ...example.split && { split: example.split },
            ...example.source_run_id && { source_run_id: example.source_run_id },
            ...example.use_source_run_io && {
              use_source_run_io: example.use_source_run_io
            },
            ...example.use_source_run_attachments && {
              use_source_run_attachments: example.use_source_run_attachments
            }
          };
          const stringifiedExample = serialize(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);
          const exampleBlob = new Blob([stringifiedExample], {
            type: "application/json"
          });
          formData.append(exampleId, exampleBlob);
          if (example.inputs) {
            const stringifiedInputs = serialize(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);
            const inputsBlob = new Blob([stringifiedInputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.inputs`, inputsBlob);
          }
          if (example.outputs) {
            const stringifiedOutputs = serialize(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);
            const outputsBlob = new Blob([stringifiedOutputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.outputs`, outputsBlob);
          }
          if (example.attachments) {
            for (const [name, attachment] of Object.entries(example.attachments)) {
              let mimeType;
              let data;
              if (Array.isArray(attachment)) {
                [mimeType, data] = attachment;
              } else {
                mimeType = attachment.mimeType;
                data = attachment.data;
              }
              const attachmentBlob = new Blob([data], {
                type: `${mimeType}; length=${data.byteLength}`
              });
              formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
            }
          }
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {
            method: "POST",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: formData
          });
          await raiseForStatus(res, "upload examples");
          return res;
        });
        return response.json();
      }
      async updatePrompt(promptIdentifier, options) {
        if (!await this.promptExists(promptIdentifier)) {
          throw new Error("Prompt does not exist, you must create it first.");
        }
        const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          throw await this._ownerConflictError("update a prompt", owner);
        }
        const payload = {};
        if (options?.description !== void 0)
          payload.description = options.description;
        if (options?.readme !== void 0)
          payload.readme = options.readme;
        if (options?.tags !== void 0)
          payload.tags = options.tags;
        if (options?.isPublic !== void 0)
          payload.is_public = options.isPublic;
        if (options?.isArchived !== void 0)
          payload.is_archived = options.isArchived;
        if (Object.keys(payload).length === 0) {
          throw new Error("No valid update options provided");
        }
        const body = JSON.stringify(payload);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
            method: "PATCH",
            headers: {
              ...this.headers,
              "Content-Type": "application/json"
            },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await raiseForStatus(res, "update prompt");
          return res;
        });
        return response.json();
      }
      async deletePrompt(promptIdentifier) {
        if (!await this.promptExists(promptIdentifier)) {
          throw new Error("Prompt does not exist, you must create it first.");
        }
        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          throw await this._ownerConflictError("delete a prompt", owner);
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "delete prompt");
          return res;
        });
        return response.json();
      }
      /**
       * Generate a cache key for a prompt.
       * Format: "{identifier}" or "{identifier}:with_model"
       */
      _getPromptCacheKey(promptIdentifier, includeModel) {
        const suffix = includeModel ? ":with_model" : "";
        return `${promptIdentifier}${suffix}`;
      }
      /**
       * Fetch a prompt commit directly from the API (bypassing cache).
       */
      async _fetchPromptFromApi(promptIdentifier, options) {
        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? "?include_model=true" : ""}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await raiseForStatus(res, "pull prompt commit");
          return res;
        });
        const result = await response.json();
        return {
          owner,
          repo: promptName,
          commit_hash: result.commit_hash,
          manifest: result.manifest,
          examples: result.examples
        };
      }
      async pullPromptCommit(promptIdentifier, options) {
        if (!options?.skipCache && this._cache) {
          const cacheKey = this._getPromptCacheKey(promptIdentifier, options?.includeModel);
          const cached2 = this._cache.get(cacheKey);
          if (cached2) {
            return cached2;
          }
          const result = await this._fetchPromptFromApi(promptIdentifier, options);
          this._cache.set(cacheKey, result);
          return result;
        }
        return this._fetchPromptFromApi(promptIdentifier, options);
      }
      /**
       * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
       * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
       * @private
       */
      async _pullPrompt(promptIdentifier, options) {
        const promptObject = await this.pullPromptCommit(promptIdentifier, {
          includeModel: options?.includeModel,
          skipCache: options?.skipCache
        });
        const prompt = JSON.stringify(promptObject.manifest);
        return prompt;
      }
      async pushPrompt(promptIdentifier, options) {
        if (await this.promptExists(promptIdentifier)) {
          if (options && Object.keys(options).some((key) => key !== "object")) {
            await this.updatePrompt(promptIdentifier, {
              description: options?.description,
              readme: options?.readme,
              tags: options?.tags,
              isPublic: options?.isPublic
            });
          }
        } else {
          await this.createPrompt(promptIdentifier, {
            description: options?.description,
            readme: options?.readme,
            tags: options?.tags,
            isPublic: options?.isPublic
          });
        }
        if (!options?.object) {
          return await this._getPromptUrl(promptIdentifier);
        }
        const url2 = await this.createCommit(promptIdentifier, options?.object, {
          parentCommitHash: options?.parentCommitHash
        });
        return url2;
      }
      /**
         * Clone a public dataset to your own langsmith tenant.
         * This operation is idempotent. If you already have a dataset with the given name,
         * this function will do nothing.
      
         * @param {string} tokenOrUrl The token of the public dataset to clone.
         * @param {Object} [options] Additional options for cloning the dataset.
         * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
         * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
         * @returns {Promise<void>}
         */
      async clonePublicDataset(tokenOrUrl, options = {}) {
        const { sourceApiUrl = this.apiUrl, datasetName } = options;
        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
        const sourceClient = new _Client({
          apiUrl: parsedApiUrl,
          // Placeholder API key not needed anymore in most cases, but
          // some private deployments may have API key-based rate limiting
          // that would cause this to fail if we provide no value.
          apiKey: "placeholder"
        });
        const ds = await sourceClient.readSharedDataset(tokenUuid);
        const finalDatasetName = datasetName || ds.name;
        try {
          if (await this.hasDataset({ datasetId: finalDatasetName })) {
            console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
            return;
          }
        } catch (_) {
        }
        const examples = await sourceClient.listSharedExamples(tokenUuid);
        const dataset = await this.createDataset(finalDatasetName, {
          description: ds.description,
          dataType: ds.data_type || "kv",
          inputsSchema: ds.inputs_schema_definition ?? void 0,
          outputsSchema: ds.outputs_schema_definition ?? void 0
        });
        try {
          await this.createExamples({
            inputs: examples.map((e) => e.inputs),
            outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
            datasetId: dataset.id
          });
        } catch (e) {
          console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
          throw e;
        }
      }
      parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
        try {
          assertUuid(urlOrToken);
          return [apiUrl, urlOrToken];
        } catch (_) {
        }
        try {
          const parsedUrl = new URL(urlOrToken);
          const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
          if (pathParts.length >= numParts) {
            const tokenUuid = pathParts[pathParts.length - numParts];
            return [apiUrl, tokenUuid];
          } else {
            throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
          }
        } catch (error40) {
          throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
        }
      }
      /**
       * Get the cache instance, if caching is enabled.
       * Useful for accessing cache metrics or manually managing the cache.
       */
      get cache() {
        return this._cache;
      }
      /**
       * Cleanup resources held by the client.
       * Stops the cache's background refresh timer.
       */
      cleanup() {
        if (this._cache) {
          this._cache.stop();
        }
      }
      /**
       * Awaits all pending trace batches. Useful for environments where
       * you need to be sure that all tracing requests finish before execution ends,
       * such as serverless environments.
       *
       * @example
       * ```
       * import { Client } from "langsmith";
       *
       * const client = new Client();
       *
       * try {
       *   // Tracing happens here
       *   ...
       * } finally {
       *   await client.awaitPendingTraceBatches();
       * }
       * ```
       *
       * @returns A promise that resolves once all currently pending traces have sent.
       */
      async awaitPendingTraceBatches() {
        if (this.manualFlushMode) {
          console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
          return Promise.resolve();
        }
        await new Promise((resolve) => setTimeout(resolve, 1));
        await Promise.all([
          ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
          this.batchIngestCaller.queue.onIdle()
        ]);
        if (this.langSmithToOTELTranslator !== void 0) {
          await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();
        }
      }
    };
  }
});

// node_modules/langsmith/dist/env.js
var isTracingEnabled;
var init_env3 = __esm({
  "node_modules/langsmith/dist/env.js"() {
    init_env2();
    isTracingEnabled = (tracingEnabled2) => {
      if (tracingEnabled2 !== void 0) {
        return tracingEnabled2;
      }
      const envVars = ["TRACING_V2", "TRACING"];
      return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
    };
  }
});

// node_modules/langsmith/dist/singletons/constants.js
var _LC_CONTEXT_VARIABLES_KEY, _LC_CHILD_RUN_END_PROMISES_KEY, _REPLICA_TRACE_ROOTS_KEY;
var init_constants2 = __esm({
  "node_modules/langsmith/dist/singletons/constants.js"() {
    _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
    _LC_CHILD_RUN_END_PROMISES_KEY = Symbol.for("lc:child_run_end_promises");
    _REPLICA_TRACE_ROOTS_KEY = Symbol.for("langsmith:replica_trace_roots");
  }
});

// node_modules/langsmith/dist/utils/context_vars.js
function getContextVar(runTree, key) {
  if (_LC_CONTEXT_VARIABLES_KEY in runTree) {
    const contextVars = runTree[_LC_CONTEXT_VARIABLES_KEY];
    return contextVars[key];
  }
  return void 0;
}
function setContextVar(runTree, key, value) {
  const contextVars = _LC_CONTEXT_VARIABLES_KEY in runTree ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    runTree[_LC_CONTEXT_VARIABLES_KEY]
  ) : {};
  contextVars[key] = value;
  runTree[_LC_CONTEXT_VARIABLES_KEY] = contextVars;
}
var init_context_vars = __esm({
  "node_modules/langsmith/dist/utils/context_vars.js"() {
    init_constants2();
  }
});

// node_modules/langsmith/dist/run_trees.js
function getReplicaKey(replica) {
  const sortedKeys = Object.keys(replica).sort();
  const keyData = sortedKeys.map((key) => `${key}:${replica[key] ?? ""}`).join("|");
  return v5_default2(keyData, UUID_NAMESPACE_DNS);
}
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;
}
function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
  const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);
  return {
    dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,
    microsecondPrecisionDatestring
  };
}
function filterReplicaForHeaders(replica) {
  const filtered = {};
  for (const key of Object.keys(replica)) {
    if (HEADER_SAFE_REPLICA_FIELDS.has(key)) {
      filtered[key] = replica[key];
    }
  }
  return filtered;
}
function isRunTree(x) {
  return x != null && typeof x.createChild === "function" && typeof x.postRun === "function";
}
function isLangChainTracerLike(x) {
  return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
}
function containsLangChainTracerLike(x) {
  return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
}
function isCallbackManagerLike(x) {
  return typeof x === "object" && x != null && Array.isArray(x.handlers);
}
function isRunnableConfigLike(x) {
  const callbacks = x?.callbacks;
  return x != null && typeof callbacks === "object" && // Callback manager with a langchain tracer
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (containsLangChainTracerLike(callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it
  containsLangChainTracerLike(callbacks));
}
function _getWriteReplicasFromEnv() {
  const envVar = getEnvironmentVariable2("LANGSMITH_RUNS_ENDPOINTS");
  if (!envVar)
    return [];
  try {
    const parsed = JSON.parse(envVar);
    if (Array.isArray(parsed)) {
      const replicas = [];
      for (const item of parsed) {
        if (typeof item !== "object" || item === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof item}`);
          continue;
        }
        if (typeof item.api_url !== "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof item.api_url}`);
          continue;
        }
        if (typeof item.api_key !== "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof item.api_key}`);
          continue;
        }
        replicas.push({
          apiUrl: item.api_url.replace(/\/$/, ""),
          apiKey: item.api_key
        });
      }
      return replicas;
    } else if (typeof parsed === "object" && parsed !== null) {
      _checkEndpointEnvUnset(parsed);
      const replicas = [];
      for (const [url2, key] of Object.entries(parsed)) {
        const cleanUrl = url2.replace(/\/$/, "");
        if (typeof key === "string") {
          replicas.push({
            apiUrl: cleanUrl,
            apiKey: key
          });
        } else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url2}: expected string, got ${typeof key}`);
          continue;
        }
      }
      return replicas;
    } else {
      console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS \u2013 must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);
      return [];
    }
  } catch (e) {
    if (isConflictingEndpointsError(e)) {
      throw e;
    }
    console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS \u2013 must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey");
    return [];
  }
}
function _ensureWriteReplicas(replicas) {
  if (replicas) {
    return replicas.map((replica) => {
      if (Array.isArray(replica)) {
        return {
          projectName: replica[0],
          updates: replica[1]
        };
      }
      return replica;
    });
  }
  return _getWriteReplicasFromEnv();
}
function _checkEndpointEnvUnset(parsed) {
  if (Object.keys(parsed).length > 0 && getLangSmithEnvironmentVariable("ENDPOINT")) {
    throw new ConflictingEndpointsError();
  }
}
var TIMESTAMP_LENGTH, UUID_NAMESPACE_DNS, HEADER_SAFE_REPLICA_FIELDS, Baggage, RunTree;
var init_run_trees = __esm({
  "node_modules/langsmith/dist/run_trees.js"() {
    init_client();
    init_env3();
    init_error();
    init_constants2();
    init_context_vars();
    init_env2();
    init_project();
    init_env2();
    init_warn();
    init_uuid();
    init_esm_node2();
    TIMESTAMP_LENGTH = 36;
    UUID_NAMESPACE_DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    HEADER_SAFE_REPLICA_FIELDS = /* @__PURE__ */ new Set([
      "projectName",
      "updates",
      "reroot"
    ]);
    Baggage = class _Baggage {
      constructor(metadata, tags, project_name, replicas) {
        Object.defineProperty(this, "metadata", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tags", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "project_name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "replicas", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.metadata = metadata;
        this.tags = tags;
        this.project_name = project_name;
        this.replicas = replicas;
      }
      static fromHeader(value) {
        const items = value.split(",");
        let metadata = {};
        let tags = [];
        let project_name;
        let replicas;
        for (const item of items) {
          const [key, uriValue] = item.split("=");
          const value2 = decodeURIComponent(uriValue);
          if (key === "langsmith-metadata") {
            metadata = JSON.parse(value2);
          } else if (key === "langsmith-tags") {
            tags = value2.split(",");
          } else if (key === "langsmith-project") {
            project_name = value2;
          } else if (key === "langsmith-replicas") {
            const parsed = JSON.parse(value2);
            replicas = parsed.map((replica) => {
              if (Array.isArray(replica)) {
                return replica;
              }
              return filterReplicaForHeaders(replica);
            });
          }
        }
        return new _Baggage(metadata, tags, project_name, replicas);
      }
      toHeader() {
        const items = [];
        if (this.metadata && Object.keys(this.metadata).length > 0) {
          items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
        }
        if (this.tags && this.tags.length > 0) {
          items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
        }
        if (this.project_name) {
          items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
        }
        return items.join(",");
      }
    };
    RunTree = class _RunTree {
      constructor(originalConfig) {
        Object.defineProperty(this, "id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "run_type", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "project_name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "parent_run", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "parent_run_id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "child_runs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "start_time", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "end_time", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "extra", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tags", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "error", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "serialized", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "inputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "outputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reference_example_id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "events", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "trace_id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "dotted_order", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tracingEnabled", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "execution_order", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "child_execution_order", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "attachments", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "replicas", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "distributedParentId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_serialized_start_time", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_awaitInputsOnPost", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        if (isRunTree(originalConfig)) {
          Object.assign(this, { ...originalConfig });
          return;
        }
        const defaultConfig = _RunTree.getDefaultConfig();
        const { metadata, ...config2 } = originalConfig;
        const client2 = config2.client ?? _RunTree.getSharedClient();
        const dedupedMetadata = {
          ...metadata,
          ...config2?.extra?.metadata
        };
        config2.extra = { ...config2.extra, metadata: dedupedMetadata };
        if ("id" in config2 && config2.id == null) {
          delete config2.id;
        }
        Object.assign(this, { ...defaultConfig, ...config2, client: client2 });
        this.execution_order ??= 1;
        this.child_execution_order ??= 1;
        if (!this.dotted_order) {
          this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);
        }
        if (!this.id) {
          this.id = uuid7FromTime(this._serialized_start_time ?? this.start_time);
        }
        if (!this.trace_id) {
          if (this.parent_run) {
            this.trace_id = this.parent_run.trace_id ?? this.id;
          } else {
            this.trace_id = this.id;
          }
        }
        this.replicas = _ensureWriteReplicas(this.replicas);
        if (!this.dotted_order) {
          const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
          if (this.parent_run) {
            this.dotted_order = this.parent_run.dotted_order + "." + dottedOrder;
          } else {
            this.dotted_order = dottedOrder;
          }
        }
      }
      set metadata(metadata) {
        this.extra = {
          ...this.extra,
          metadata: {
            ...this.extra?.metadata,
            ...metadata
          }
        };
      }
      get metadata() {
        return this.extra?.metadata;
      }
      static getDefaultConfig() {
        const start_time = Date.now();
        return {
          run_type: "chain",
          project_name: getDefaultProjectName(),
          child_runs: [],
          api_url: getEnvironmentVariable2("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
          api_key: getEnvironmentVariable2("LANGCHAIN_API_KEY"),
          caller_options: {},
          start_time,
          serialized: {},
          inputs: {},
          extra: {}
        };
      }
      static getSharedClient() {
        if (!_RunTree.sharedClient) {
          _RunTree.sharedClient = new Client();
        }
        return _RunTree.sharedClient;
      }
      createChild(config2) {
        const child_execution_order = this.child_execution_order + 1;
        const inheritedReplicas = this.replicas?.map((replica) => {
          const { reroot, ...rest } = replica;
          return rest;
        });
        const childReplicas = config2.replicas ?? inheritedReplicas;
        const child = new _RunTree({
          ...config2,
          parent_run: this,
          project_name: this.project_name,
          replicas: childReplicas,
          client: this.client,
          tracingEnabled: this.tracingEnabled,
          execution_order: child_execution_order,
          child_execution_order
        });
        if (_LC_CONTEXT_VARIABLES_KEY in this) {
          child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
        }
        const LC_CHILD = Symbol.for("lc:child_config");
        const presentConfig = config2.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];
        if (isRunnableConfigLike(presentConfig)) {
          const newConfig = { ...presentConfig };
          const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : void 0;
          if (callbacks) {
            Object.assign(callbacks, { _parentRunId: child.id });
            callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);
            newConfig.callbacks = callbacks;
          }
          child.extra[LC_CHILD] = newConfig;
        }
        const visited = /* @__PURE__ */ new Set();
        let current = this;
        while (current != null && !visited.has(current.id)) {
          visited.add(current.id);
          current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
          current = current.parent_run;
        }
        this.child_runs.push(child);
        return child;
      }
      async end(outputs, error40, endTime = Date.now(), metadata) {
        this.outputs = this.outputs ?? outputs;
        this.error = this.error ?? error40;
        this.end_time = this.end_time ?? endTime;
        if (metadata && Object.keys(metadata).length > 0) {
          this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
        }
      }
      _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
        const runExtra = run.extra ?? {};
        if (runExtra?.runtime?.library === void 0) {
          if (!runExtra.runtime) {
            runExtra.runtime = {};
          }
          if (runtimeEnv) {
            for (const [k, v] of Object.entries(runtimeEnv)) {
              if (!runExtra.runtime[k]) {
                runExtra.runtime[k] = v;
              }
            }
          }
        }
        let child_runs;
        let parent_run_id;
        if (!excludeChildRuns) {
          child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
          parent_run_id = void 0;
        } else {
          parent_run_id = run.parent_run?.id ?? run.parent_run_id;
          child_runs = [];
        }
        return {
          id: run.id,
          name: run.name,
          start_time: run._serialized_start_time ?? run.start_time,
          end_time: run.end_time,
          run_type: run.run_type,
          reference_example_id: run.reference_example_id,
          extra: runExtra,
          serialized: run.serialized,
          error: run.error,
          inputs: run.inputs,
          outputs: run.outputs,
          session_name: run.project_name,
          child_runs,
          parent_run_id,
          trace_id: run.trace_id,
          dotted_order: run.dotted_order,
          tags: run.tags,
          attachments: run.attachments,
          events: run.events
        };
      }
      _sliceParentId(parentId, run) {
        if (run.dotted_order) {
          const segs = run.dotted_order.split(".");
          let startIdx = null;
          for (let idx = 0; idx < segs.length; idx++) {
            const segId = segs[idx].slice(-TIMESTAMP_LENGTH);
            if (segId === parentId) {
              startIdx = idx;
              break;
            }
          }
          if (startIdx !== null) {
            const trimmedSegs = segs.slice(startIdx + 1);
            run.dotted_order = trimmedSegs.join(".");
            if (trimmedSegs.length > 0) {
              run.trace_id = trimmedSegs[0].slice(-TIMESTAMP_LENGTH);
            } else {
              run.trace_id = run.id;
            }
          }
        }
        if (run.parent_run_id === parentId) {
          run.parent_run_id = void 0;
        }
      }
      _setReplicaTraceRoot(replicaKey, traceRootId) {
        const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};
        replicaTraceRoots[replicaKey] = traceRootId;
        setContextVar(this, _REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);
        for (const child of this.child_runs) {
          child._setReplicaTraceRoot(replicaKey, traceRootId);
        }
      }
      _remapForProject(params) {
        const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId } = params;
        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
        if (projectName === this.project_name) {
          return {
            ...baseRun,
            session_name: projectName
          };
        }
        if (reroot) {
          if (distributedParentId) {
            this._sliceParentId(distributedParentId, baseRun);
          } else {
            baseRun.parent_run_id = void 0;
            if (baseRun.dotted_order) {
              const segs = baseRun.dotted_order.split(".");
              if (segs.length > 0) {
                baseRun.dotted_order = segs[segs.length - 1];
                baseRun.trace_id = baseRun.id;
              }
            }
          }
          const replicaKey = getReplicaKey({
            projectName,
            apiUrl,
            apiKey,
            workspaceId
          });
          this._setReplicaTraceRoot(replicaKey, baseRun.id);
        }
        let ancestorRerootedTraceId;
        if (!reroot) {
          const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};
          const replicaKey = getReplicaKey({
            projectName,
            apiUrl,
            apiKey,
            workspaceId
          });
          ancestorRerootedTraceId = replicaTraceRoots[replicaKey];
          if (ancestorRerootedTraceId) {
            baseRun.trace_id = ancestorRerootedTraceId;
            if (baseRun.dotted_order) {
              const segs = baseRun.dotted_order.split(".");
              let rootIdx = null;
              for (let idx = 0; idx < segs.length; idx++) {
                const segId = segs[idx].slice(-TIMESTAMP_LENGTH);
                if (segId === ancestorRerootedTraceId) {
                  rootIdx = idx;
                  break;
                }
              }
              if (rootIdx !== null) {
                const trimmedSegs = segs.slice(rootIdx);
                baseRun.dotted_order = trimmedSegs.join(".");
              }
            }
          }
        }
        const oldId = baseRun.id;
        const newId = v5_default2(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);
        let newTraceId;
        if (baseRun.trace_id) {
          newTraceId = v5_default2(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);
        } else {
          newTraceId = newId;
        }
        let newParentId;
        if (baseRun.parent_run_id) {
          newParentId = v5_default2(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);
        }
        let newDottedOrder;
        if (baseRun.dotted_order) {
          const segs = baseRun.dotted_order.split(".");
          const remappedSegs = segs.map((seg) => {
            const segId = seg.slice(-TIMESTAMP_LENGTH);
            const remappedId = v5_default2(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);
            return seg.slice(0, -TIMESTAMP_LENGTH) + remappedId;
          });
          newDottedOrder = remappedSegs.join(".");
        }
        return {
          ...baseRun,
          id: newId,
          trace_id: newTraceId,
          parent_run_id: newParentId,
          dotted_order: newDottedOrder,
          session_name: projectName
        };
      }
      async postRun(excludeChildRuns = true) {
        if (this._awaitInputsOnPost) {
          this.inputs = await this.inputs;
        }
        try {
          const runtimeEnv = getRuntimeEnvironment2();
          if (this.replicas && this.replicas.length > 0) {
            for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this.replicas) {
              const runCreate = this._remapForProject({
                projectName: projectName ?? this.project_name,
                runtimeEnv,
                excludeChildRuns: true,
                reroot,
                distributedParentId: this.distributedParentId,
                apiUrl,
                apiKey,
                workspaceId
              });
              await this.client.createRun(runCreate, {
                apiKey,
                apiUrl,
                workspaceId
              });
            }
          } else {
            const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
            await this.client.createRun(runCreate);
          }
          if (!excludeChildRuns) {
            warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
            for (const childRun of this.child_runs) {
              await childRun.postRun(false);
            }
          }
          this.child_runs = [];
        } catch (error40) {
          console.error(`Error in postRun for run ${this.id}:`, error40);
        }
      }
      async patchRun(options) {
        if (this.replicas && this.replicas.length > 0) {
          for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot } of this.replicas) {
            const runData = this._remapForProject({
              projectName: projectName ?? this.project_name,
              runtimeEnv: void 0,
              excludeChildRuns: true,
              reroot,
              distributedParentId: this.distributedParentId,
              apiUrl,
              apiKey,
              workspaceId
            });
            const updatePayload = {
              id: runData.id,
              name: runData.name,
              run_type: runData.run_type,
              start_time: runData.start_time,
              outputs: runData.outputs,
              error: runData.error,
              parent_run_id: runData.parent_run_id,
              session_name: runData.session_name,
              reference_example_id: runData.reference_example_id,
              end_time: runData.end_time,
              dotted_order: runData.dotted_order,
              trace_id: runData.trace_id,
              events: runData.events,
              tags: runData.tags,
              extra: runData.extra,
              attachments: this.attachments,
              ...updates
            };
            if (!options?.excludeInputs) {
              updatePayload.inputs = runData.inputs;
            }
            await this.client.updateRun(runData.id, updatePayload, {
              apiKey,
              apiUrl,
              workspaceId
            });
          }
        } else {
          try {
            const runUpdate = {
              name: this.name,
              run_type: this.run_type,
              start_time: this._serialized_start_time ?? this.start_time,
              end_time: this.end_time,
              error: this.error,
              outputs: this.outputs,
              parent_run_id: this.parent_run?.id ?? this.parent_run_id,
              reference_example_id: this.reference_example_id,
              extra: this.extra,
              events: this.events,
              dotted_order: this.dotted_order,
              trace_id: this.trace_id,
              tags: this.tags,
              attachments: this.attachments,
              session_name: this.project_name
            };
            if (!options?.excludeInputs) {
              runUpdate.inputs = this.inputs;
            }
            await this.client.updateRun(this.id, runUpdate);
          } catch (error40) {
            console.error(`Error in patchRun for run ${this.id}`, error40);
          }
        }
        this.child_runs = [];
      }
      toJSON() {
        return this._convertToCreate(this, void 0, false);
      }
      /**
       * Add an event to the run tree.
       * @param event - A single event or string to add
       */
      addEvent(event) {
        if (!this.events) {
          this.events = [];
        }
        if (typeof event === "string") {
          this.events.push({
            name: "event",
            time: (/* @__PURE__ */ new Date()).toISOString(),
            message: event
          });
        } else {
          this.events.push({
            ...event,
            time: event.time ?? (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }
      static fromRunnableConfig(parentConfig, props) {
        const callbackManager = parentConfig?.callbacks;
        let parentRun;
        let projectName;
        let client2;
        let tracingEnabled2 = isTracingEnabled();
        if (callbackManager) {
          const parentRunId = callbackManager?.getParentRunId?.() ?? "";
          const langChainTracer = callbackManager?.handlers?.find((handler2) => handler2?.name == "langchain_tracer");
          parentRun = langChainTracer?.getRun?.(parentRunId);
          projectName = langChainTracer?.projectName;
          client2 = langChainTracer?.client;
          tracingEnabled2 = tracingEnabled2 || !!langChainTracer;
        }
        if (!parentRun) {
          return new _RunTree({
            ...props,
            client: client2,
            tracingEnabled: tracingEnabled2,
            project_name: projectName
          });
        }
        const parentRunTree = new _RunTree({
          name: parentRun.name,
          id: parentRun.id,
          trace_id: parentRun.trace_id,
          dotted_order: parentRun.dotted_order,
          client: client2,
          tracingEnabled: tracingEnabled2,
          project_name: projectName,
          tags: [
            ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))
          ],
          extra: {
            metadata: {
              ...parentRun?.extra?.metadata,
              ...parentConfig?.metadata
            }
          }
        });
        return parentRunTree.createChild(props);
      }
      static fromDottedOrder(dottedOrder) {
        return this.fromHeaders({ "langsmith-trace": dottedOrder });
      }
      static fromHeaders(headers, inheritArgs) {
        const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
          "langsmith-trace": headers.get("langsmith-trace"),
          baggage: headers.get("baggage")
        } : headers;
        const headerTrace = rawHeaders["langsmith-trace"];
        if (!headerTrace || typeof headerTrace !== "string")
          return void 0;
        const parentDottedOrder = headerTrace.trim();
        const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
          const [strTime, uuid8] = part.split("Z");
          return { strTime, time: Date.parse(strTime + "Z"), uuid: uuid8 };
        });
        const traceId = parsedDottedOrder[0].uuid;
        const config2 = {
          ...inheritArgs,
          name: inheritArgs?.["name"] ?? "parent",
          run_type: inheritArgs?.["run_type"] ?? "chain",
          start_time: inheritArgs?.["start_time"] ?? Date.now(),
          id: parsedDottedOrder.at(-1)?.uuid,
          trace_id: traceId,
          dotted_order: parentDottedOrder
        };
        if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
          const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
          config2.metadata = baggage.metadata;
          config2.tags = baggage.tags;
          config2.project_name = baggage.project_name;
          config2.replicas = baggage.replicas;
        }
        const runTree = new _RunTree(config2);
        runTree.distributedParentId = runTree.id;
        return runTree;
      }
      toHeaders(headers) {
        const result = {
          "langsmith-trace": this.dotted_order,
          baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()
        };
        if (headers) {
          for (const [key, value] of Object.entries(result)) {
            headers.set(key, value);
          }
        }
        return result;
      }
    };
    Object.defineProperty(RunTree, "sharedClient", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
  }
});

// node_modules/langsmith/run_trees.js
var init_run_trees2 = __esm({
  "node_modules/langsmith/run_trees.js"() {
    init_run_trees();
  }
});

// node_modules/@langchain/core/dist/tracers/base.js
function convertRunToRunTree(run, parentRun) {
  if (!run) return void 0;
  return new RunTree({
    ...run,
    start_time: run._serialized_start_time ?? run.start_time,
    parent_run: convertRunToRunTree(parentRun),
    child_runs: run.child_runs.map((r) => convertRunToRunTree(r)).filter((r) => r !== void 0),
    extra: {
      ...run.extra,
      runtime: getRuntimeEnvironment()
    },
    tracingEnabled: false
  });
}
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
}
function isBaseTracer(x) {
  return typeof x._addRunToRunMap === "function";
}
var base_exports2, convertRunTreeToRun, BaseTracer;
var init_base3 = __esm({
  "node_modules/@langchain/core/dist/tracers/base.js"() {
    init_rolldown_runtime();
    init_env();
    init_base2();
    init_run_trees2();
    base_exports2 = {};
    __export2(base_exports2, {
      BaseTracer: () => BaseTracer,
      isBaseTracer: () => isBaseTracer
    });
    convertRunTreeToRun = (runTree) => {
      if (!runTree) return void 0;
      runTree.events = runTree.events ?? [];
      runTree.child_runs = runTree.child_runs ?? [];
      return runTree;
    };
    BaseTracer = class extends BaseCallbackHandler {
      /** @deprecated Use `runTreeMap` instead. */
      runMap = /* @__PURE__ */ new Map();
      runTreeMap = /* @__PURE__ */ new Map();
      usesRunTreeMap = false;
      constructor(_fields) {
        super(...arguments);
      }
      copy() {
        return this;
      }
      getRunById(runId) {
        if (runId === void 0) return void 0;
        return this.usesRunTreeMap ? convertRunTreeToRun(this.runTreeMap.get(runId)) : this.runMap.get(runId);
      }
      stringifyError(error40) {
        if (error40 instanceof Error) return error40.message + (error40?.stack ? `

${error40.stack}` : "");
        if (typeof error40 === "string") return error40;
        return `${error40}`;
      }
      _addChildRun(parentRun, childRun) {
        parentRun.child_runs.push(childRun);
      }
      _addRunToRunMap(run) {
        const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = convertToDottedOrderFormat(new Date(run.start_time).getTime(), run.id, run.execution_order);
        const storedRun = { ...run };
        const parentRun = this.getRunById(storedRun.parent_run_id);
        if (storedRun.parent_run_id !== void 0) if (parentRun) {
          this._addChildRun(parentRun, storedRun);
          parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
          storedRun.trace_id = parentRun.trace_id;
          if (parentRun.dotted_order !== void 0) {
            storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(".");
            storedRun._serialized_start_time = microsecondPrecisionDatestring;
          }
        } else storedRun.parent_run_id = void 0;
        else {
          storedRun.trace_id = storedRun.id;
          storedRun.dotted_order = currentDottedOrder;
          storedRun._serialized_start_time = microsecondPrecisionDatestring;
        }
        if (this.usesRunTreeMap) {
          const runTree = convertRunToRunTree(storedRun, parentRun);
          if (runTree !== void 0) this.runTreeMap.set(storedRun.id, runTree);
        } else this.runMap.set(storedRun.id, storedRun);
        return storedRun;
      }
      async _endTrace(run) {
        const parentRun = run.parent_run_id !== void 0 && this.getRunById(run.parent_run_id);
        if (parentRun) parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
        else await this.persistRun(run);
        await this.onRunUpdate?.(run);
        if (this.usesRunTreeMap) this.runTreeMap.delete(run.id);
        else this.runMap.delete(run.id);
      }
      _getExecutionOrder(parentRunId) {
        const parentRun = parentRunId !== void 0 && this.getRunById(parentRunId);
        if (!parentRun) return 1;
        return parentRun.child_execution_order + 1;
      }
      /**
      * Create and add a run to the run map for LLM start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const finalExtraParams = metadata ? {
          ...extraParams,
          metadata
        } : extraParams;
        const run = {
          id: runId,
          name: name ?? llm.id[llm.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: llm,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { prompts },
          execution_order,
          child_runs: [],
          child_execution_order: execution_order,
          run_type: "llm",
          extra: finalExtraParams ?? {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onLLMStart?.(run);
        return run;
      }
      /**
      * Create and add a run to the run map for chat model start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const finalExtraParams = metadata ? {
          ...extraParams,
          metadata
        } : extraParams;
        const run = {
          id: runId,
          name: name ?? llm.id[llm.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: llm,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { messages },
          execution_order,
          child_runs: [],
          child_execution_order: execution_order,
          run_type: "llm",
          extra: finalExtraParams ?? {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onLLMStart?.(run);
        return run;
      }
      async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "llm") throw new Error("No LLM run to end.");
        run.end_time = Date.now();
        run.outputs = output;
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        run.extra = {
          ...run.extra,
          ...extraParams
        };
        await this.onLLMEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleLLMError(error40, runId, _parentRunId, _tags, extraParams) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "llm") throw new Error("No LLM run to end.");
        run.end_time = Date.now();
        run.error = this.stringifyError(error40);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        run.extra = {
          ...run.extra,
          ...extraParams
        };
        await this.onLLMError?.(run);
        await this._endTrace(run);
        return run;
      }
      /**
      * Create and add a run to the run map for chain start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name, extra) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const run = {
          id: runId,
          name: name ?? chain.id[chain.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: chain,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs,
          execution_order,
          child_execution_order: execution_order,
          run_type: runType ?? "chain",
          child_runs: [],
          extra: metadata ? {
            ...extra,
            metadata
          } : { ...extra },
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
        const run = this.getRunById(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
        await this.onRunCreate?.(run);
        await this.onChainStart?.(run);
        return run;
      }
      async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
        const run = this.getRunById(runId);
        if (!run) throw new Error("No chain run to end.");
        run.end_time = Date.now();
        run.outputs = _coerceToDict(outputs, "output");
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        if (kwargs?.inputs !== void 0) run.inputs = _coerceToDict(kwargs.inputs, "input");
        await this.onChainEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleChainError(error40, runId, _parentRunId, _tags, kwargs) {
        const run = this.getRunById(runId);
        if (!run) throw new Error("No chain run to end.");
        run.end_time = Date.now();
        run.error = this.stringifyError(error40);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        if (kwargs?.inputs !== void 0) run.inputs = _coerceToDict(kwargs.inputs, "input");
        await this.onChainError?.(run);
        await this._endTrace(run);
        return run;
      }
      /**
      * Create and add a run to the run map for tool start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForToolStart(tool2, input, runId, parentRunId, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const run = {
          id: runId,
          name: name ?? tool2.id[tool2.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: tool2,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { input },
          execution_order,
          child_execution_order: execution_order,
          run_type: "tool",
          child_runs: [],
          extra: metadata ? { metadata } : {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleToolStart(tool2, input, runId, parentRunId, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForToolStart(tool2, input, runId, parentRunId, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onToolStart?.(run);
        return run;
      }
      async handleToolEnd(output, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "tool") throw new Error("No tool run to end");
        run.end_time = Date.now();
        run.outputs = { output };
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        await this.onToolEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleToolError(error40, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "tool") throw new Error("No tool run to end");
        run.end_time = Date.now();
        run.error = this.stringifyError(error40);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        await this.onToolError?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleAgentAction(action, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "chain") return;
        const agentRun = run;
        agentRun.actions = agentRun.actions || [];
        agentRun.actions.push(action);
        agentRun.events.push({
          name: "agent_action",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: { action }
        });
        await this.onAgentAction?.(run);
      }
      async handleAgentEnd(action, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "chain") return;
        run.events.push({
          name: "agent_end",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: { action }
        });
        await this.onAgentEnd?.(run);
      }
      /**
      * Create and add a run to the run map for retriever start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const run = {
          id: runId,
          name: name ?? retriever.id[retriever.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: retriever,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { query },
          execution_order,
          child_execution_order: execution_order,
          run_type: "retriever",
          child_runs: [],
          extra: metadata ? { metadata } : {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onRetrieverStart?.(run);
        return run;
      }
      async handleRetrieverEnd(documents, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "retriever") throw new Error("No retriever run to end");
        run.end_time = Date.now();
        run.outputs = { documents };
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        await this.onRetrieverEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleRetrieverError(error40, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "retriever") throw new Error("No retriever run to end");
        run.end_time = Date.now();
        run.error = this.stringifyError(error40);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        await this.onRetrieverError?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleText(text2, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "chain") return;
        run.events.push({
          name: "text",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: { text: text2 }
        });
        await this.onText?.(run);
      }
      async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "llm") throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
        run.events.push({
          name: "new_token",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: {
            token,
            idx,
            chunk: fields?.chunk
          }
        });
        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });
        return run;
      }
    };
  }
});

// node_modules/@langchain/core/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/@langchain/core/node_modules/ansi-styles/index.js"(exports2, module) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi256();
      styles2.color.ansi16m = wrapAnsi16m();
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer3 = Number.parseInt(colorString, 16);
            return [
              integer3 >> 16 & 255,
              integer3 >> 8 & 255,
              integer3 & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles2;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/@langchain/core/dist/tracers/console.js
function wrap(style, text2) {
  return `${style.open}${text2}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch {
    return fallback;
  }
}
function formatKVMapItem(value) {
  if (typeof value === "string") return value.trim();
  if (value === null || value === void 0) return value;
  return tryJsonStringify(value, value.toString());
}
function elapsed(run) {
  if (!run.end_time) return "";
  const elapsed$1 = run.end_time - run.start_time;
  if (elapsed$1 < 1e3) return `${elapsed$1}ms`;
  return `${(elapsed$1 / 1e3).toFixed(2)}s`;
}
var import_ansi_styles, console_exports, color, ConsoleCallbackHandler;
var init_console = __esm({
  "node_modules/@langchain/core/dist/tracers/console.js"() {
    init_rolldown_runtime();
    init_base3();
    import_ansi_styles = __toESM(require_ansi_styles(), 1);
    console_exports = {};
    __export2(console_exports, { ConsoleCallbackHandler: () => ConsoleCallbackHandler });
    ({ color } = import_ansi_styles.default);
    ConsoleCallbackHandler = class extends BaseTracer {
      name = "console_callback_handler";
      /**
      * Method used to persist the run. In this case, it simply returns a
      * resolved promise as there's no persistence logic.
      * @param _run The run to persist.
      * @returns A resolved promise.
      */
      persistRun(_run) {
        return Promise.resolve();
      }
      /**
      * Method used to get all the parent runs of a given run.
      * @param run The run whose parents are to be retrieved.
      * @returns An array of parent runs.
      */
      getParents(run) {
        const parents = [];
        let currentRun = run;
        while (currentRun.parent_run_id) {
          const parent = this.runMap.get(currentRun.parent_run_id);
          if (parent) {
            parents.push(parent);
            currentRun = parent;
          } else break;
        }
        return parents;
      }
      /**
      * Method used to get a string representation of the run's lineage, which
      * is used in logging.
      * @param run The run whose lineage is to be retrieved.
      * @returns A string representation of the run's lineage.
      */
      getBreadcrumbs(run) {
        const parents = this.getParents(run).reverse();
        const string4 = [...parents, run].map((parent, i, arr3) => {
          const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
          return i === arr3.length - 1 ? wrap(import_ansi_styles.default.bold, name) : name;
        }).join(" > ");
        return wrap(color.grey, string4);
      }
      /**
      * Method used to log the start of a chain run.
      * @param run The chain run that has started.
      * @returns void
      */
      onChainStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
      }
      /**
      * Method used to log the end of a chain run.
      * @param run The chain run that has ended.
      * @returns void
      */
      onChainEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
      }
      /**
      * Method used to log any errors of a chain run.
      * @param run The chain run that has errored.
      * @returns void
      */
      onChainError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the start of an LLM run.
      * @param run The LLM run that has started.
      * @returns void
      */
      onLLMStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
        console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
      }
      /**
      * Method used to log the end of an LLM run.
      * @param run The LLM run that has ended.
      * @returns void
      */
      onLLMEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
      }
      /**
      * Method used to log any errors of an LLM run.
      * @param run The LLM run that has errored.
      * @returns void
      */
      onLLMError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the start of a tool run.
      * @param run The tool run that has started.
      * @returns void
      */
      onToolStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
      }
      /**
      * Method used to log the end of a tool run.
      * @param run The tool run that has ended.
      * @returns void
      */
      onToolEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem(run.outputs?.output)}"`);
      }
      /**
      * Method used to log any errors of a tool run.
      * @param run The tool run that has errored.
      * @returns void
      */
      onToolError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the start of a retriever run.
      * @param run The retriever run that has started.
      * @returns void
      */
      onRetrieverStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
      }
      /**
      * Method used to log the end of a retriever run.
      * @param run The retriever run that has ended.
      * @returns void
      */
      onRetrieverEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
      }
      /**
      * Method used to log any errors of a retriever run.
      * @param run The retriever run that has errored.
      * @returns void
      */
      onRetrieverError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the action selected by the agent.
      * @param run The run in which the agent action occurred.
      * @returns void
      */
      onAgentAction(run) {
        const agentRun = run;
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
      }
    };
  }
});

// node_modules/langsmith/index.js
var init_langsmith = __esm({
  "node_modules/langsmith/index.js"() {
    init_dist();
  }
});

// node_modules/@langchain/core/dist/singletons/tracer.js
var client, getDefaultLangChainClientSingleton;
var init_tracer = __esm({
  "node_modules/@langchain/core/dist/singletons/tracer.js"() {
    init_env();
    init_langsmith();
    getDefaultLangChainClientSingleton = () => {
      if (client === void 0) {
        const clientParams = getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: true } : {};
        client = new Client(clientParams);
      }
      return client;
    };
  }
});

// node_modules/langsmith/dist/singletons/traceable.js
function getCurrentRunTree(permitAbsentRunTree = false) {
  const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
  if (!permitAbsentRunTree && runTree === void 0) {
    throw new Error("Could not get the current run tree.\n\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.");
  }
  return runTree;
}
function isTraceableFunction(x) {
  return typeof x === "function" && "langsmith:traceable" in x;
}
var MockAsyncLocalStorage, TRACING_ALS_KEY2, mockAsyncLocalStorage, AsyncLocalStorageProvider, AsyncLocalStorageProviderSingleton, ROOT;
var init_traceable = __esm({
  "node_modules/langsmith/dist/singletons/traceable.js"() {
    MockAsyncLocalStorage = class {
      getStore() {
        return void 0;
      }
      run(_, callback) {
        return callback();
      }
    };
    TRACING_ALS_KEY2 = Symbol.for("ls:tracing_async_local_storage");
    mockAsyncLocalStorage = new MockAsyncLocalStorage();
    AsyncLocalStorageProvider = class {
      getInstance() {
        return globalThis[TRACING_ALS_KEY2] ?? mockAsyncLocalStorage;
      }
      initializeGlobalInstance(instance) {
        if (globalThis[TRACING_ALS_KEY2] === void 0) {
          globalThis[TRACING_ALS_KEY2] = instance;
        }
      }
    };
    AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
    ROOT = Symbol.for("langsmith:traceable:root");
  }
});

// node_modules/langsmith/singletons/traceable.js
var init_traceable2 = __esm({
  "node_modules/langsmith/singletons/traceable.js"() {
    init_traceable();
  }
});

// node_modules/@langchain/core/dist/tracers/tracer_langchain.js
function _getUsageMetadataFromGenerations(generations) {
  let output = void 0;
  for (const generationBatch of generations) for (const generation of generationBatch) if (AIMessage.isInstance(generation.message) && generation.message.usage_metadata !== void 0) output = mergeUsageMetadata(output, generation.message.usage_metadata);
  return output;
}
var tracer_langchain_exports, LangChainTracer;
var init_tracer_langchain = __esm({
  "node_modules/@langchain/core/dist/tracers/tracer_langchain.js"() {
    init_rolldown_runtime();
    init_metadata();
    init_ai();
    init_base3();
    init_tracer();
    init_traceable2();
    init_run_trees2();
    init_langsmith();
    tracer_langchain_exports = {};
    __export2(tracer_langchain_exports, { LangChainTracer: () => LangChainTracer });
    LangChainTracer = class LangChainTracer2 extends BaseTracer {
      name = "langchain_tracer";
      projectName;
      exampleId;
      client;
      replicas;
      usesRunTreeMap = true;
      constructor(fields = {}) {
        super(fields);
        const { exampleId, projectName, client: client2, replicas } = fields;
        this.projectName = projectName ?? getDefaultProjectName();
        this.replicas = replicas;
        this.exampleId = exampleId;
        this.client = client2 ?? getDefaultLangChainClientSingleton();
        const traceableTree = LangChainTracer2.getTraceableRunTree();
        if (traceableTree) this.updateFromRunTree(traceableTree);
      }
      async persistRun(_run) {
      }
      async onRunCreate(run) {
        if (!run.extra?.lc_defers_inputs) {
          const runTree = this.getRunTreeWithTracingConfig(run.id);
          await runTree?.postRun();
        }
      }
      async onRunUpdate(run) {
        const runTree = this.getRunTreeWithTracingConfig(run.id);
        if (run.extra?.lc_defers_inputs) await runTree?.postRun();
        else await runTree?.patchRun();
      }
      onLLMEnd(run) {
        const outputs = run.outputs;
        if (outputs?.generations) {
          const usageMetadata = _getUsageMetadataFromGenerations(outputs.generations);
          if (usageMetadata !== void 0) {
            run.extra = run.extra ?? {};
            const metadata = run.extra.metadata ?? {};
            metadata.usage_metadata = usageMetadata;
            run.extra.metadata = metadata;
          }
        }
      }
      getRun(id) {
        return this.runTreeMap.get(id);
      }
      updateFromRunTree(runTree) {
        this.runTreeMap.set(runTree.id, runTree);
        let rootRun = runTree;
        const visited = /* @__PURE__ */ new Set();
        while (rootRun.parent_run) {
          if (visited.has(rootRun.id)) break;
          visited.add(rootRun.id);
          if (!rootRun.parent_run) break;
          rootRun = rootRun.parent_run;
        }
        visited.clear();
        const queue2 = [rootRun];
        while (queue2.length > 0) {
          const current = queue2.shift();
          if (!current || visited.has(current.id)) continue;
          visited.add(current.id);
          this.runTreeMap.set(current.id, current);
          if (current.child_runs) queue2.push(...current.child_runs);
        }
        this.client = runTree.client ?? this.client;
        this.replicas = runTree.replicas ?? this.replicas;
        this.projectName = runTree.project_name ?? this.projectName;
        this.exampleId = runTree.reference_example_id ?? this.exampleId;
      }
      getRunTreeWithTracingConfig(id) {
        const runTree = this.runTreeMap.get(id);
        if (!runTree) return void 0;
        return new RunTree({
          ...runTree,
          client: this.client,
          project_name: this.projectName,
          replicas: this.replicas,
          reference_example_id: this.exampleId,
          tracingEnabled: true
        });
      }
      static getTraceableRunTree() {
        try {
          return getCurrentRunTree(true);
        } catch {
          return void 0;
        }
      }
    };
  }
});

// node_modules/@langchain/core/dist/singletons/callbacks.js
function createQueue() {
  const PQueue = "default" in import_p_queue2.default ? import_p_queue2.default.default : import_p_queue2.default;
  return new PQueue({
    autoStart: true,
    concurrency: 1
  });
}
function getQueue() {
  if (typeof queue === "undefined") queue = createQueue();
  return queue;
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
    if (asyncLocalStorageInstance !== void 0) await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
    else await promiseFn();
  } else {
    queue = getQueue();
    queue.add(async () => {
      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance !== void 0) await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
      else await promiseFn();
    });
  }
}
async function awaitAllCallbacks() {
  const defaultClient = getDefaultLangChainClientSingleton();
  await Promise.allSettled([typeof queue !== "undefined" ? queue.onIdle() : Promise.resolve(), defaultClient.awaitPendingTraceBatches()]);
}
var import_p_queue2, queue;
var init_callbacks = __esm({
  "node_modules/@langchain/core/dist/singletons/callbacks.js"() {
    init_tracer();
    init_globals();
    import_p_queue2 = __toESM(require_dist(), 1);
  }
});

// node_modules/@langchain/core/dist/callbacks/promises.js
var promises_exports;
var init_promises = __esm({
  "node_modules/@langchain/core/dist/callbacks/promises.js"() {
    init_rolldown_runtime();
    init_callbacks();
    promises_exports = {};
    __export2(promises_exports, {
      awaitAllCallbacks: () => awaitAllCallbacks,
      consumeCallback: () => consumeCallback
    });
  }
});

// node_modules/@langchain/core/dist/utils/callbacks.js
var isTracingEnabled2;
var init_callbacks2 = __esm({
  "node_modules/@langchain/core/dist/utils/callbacks.js"() {
    init_env();
    isTracingEnabled2 = (tracingEnabled2) => {
      if (tracingEnabled2 !== void 0) return tracingEnabled2;
      const envVars = [
        "LANGSMITH_TRACING_V2",
        "LANGCHAIN_TRACING_V2",
        "LANGSMITH_TRACING",
        "LANGCHAIN_TRACING"
      ];
      return !!envVars.find((envVar) => getEnvironmentVariable(envVar) === "true");
    };
  }
});

// node_modules/@langchain/core/dist/singletons/async_local_storage/context.js
function getContextVariable(name) {
  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
  if (asyncLocalStorageInstance === void 0) return void 0;
  const runTree = asyncLocalStorageInstance.getStore();
  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];
}
var LC_CONFIGURE_HOOKS_KEY, _getConfigureHooks;
var init_context = __esm({
  "node_modules/@langchain/core/dist/singletons/async_local_storage/context.js"() {
    init_globals();
    init_run_trees2();
    LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
    _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];
  }
});

// node_modules/@langchain/core/dist/callbacks/manager.js
function parseCallbackConfigArg(arg) {
  if (!arg) return {};
  else if (Array.isArray(arg) || "name" in arg) return { callbacks: arg };
  else return arg;
}
function ensureHandler(handler2) {
  if ("name" in handler2) return handler2;
  return BaseCallbackHandler.fromMethods(handler2);
}
var manager_exports, BaseCallbackManager, BaseRunManager, CallbackManagerForRetrieverRun, CallbackManagerForLLMRun, CallbackManagerForChainRun, CallbackManagerForToolRun, CallbackManager;
var init_manager = __esm({
  "node_modules/@langchain/core/dist/callbacks/manager.js"() {
    init_rolldown_runtime();
    init_utils3();
    init_env();
    init_base2();
    init_base3();
    init_console();
    init_tracer_langchain();
    init_callbacks();
    init_promises();
    init_callbacks2();
    init_context();
    init_esm_node();
    manager_exports = {};
    __export2(manager_exports, {
      BaseCallbackManager: () => BaseCallbackManager,
      BaseRunManager: () => BaseRunManager,
      CallbackManager: () => CallbackManager,
      CallbackManagerForChainRun: () => CallbackManagerForChainRun,
      CallbackManagerForLLMRun: () => CallbackManagerForLLMRun,
      CallbackManagerForRetrieverRun: () => CallbackManagerForRetrieverRun,
      CallbackManagerForToolRun: () => CallbackManagerForToolRun,
      ensureHandler: () => ensureHandler,
      parseCallbackConfigArg: () => parseCallbackConfigArg
    });
    BaseCallbackManager = class {
      setHandler(handler2) {
        return this.setHandlers([handler2]);
      }
    };
    BaseRunManager = class {
      constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
        this.runId = runId;
        this.handlers = handlers;
        this.inheritableHandlers = inheritableHandlers;
        this.tags = tags;
        this.inheritableTags = inheritableTags;
        this.metadata = metadata;
        this.inheritableMetadata = inheritableMetadata;
        this._parentRunId = _parentRunId;
      }
      get parentRunId() {
        return this._parentRunId;
      }
      async handleText(text2) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          try {
            await handler2.handleText?.(text2, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleText: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
      async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          try {
            await handler2.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleCustomEvent: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
    };
    CallbackManagerForRetrieverRun = class extends BaseRunManager {
      getChild(tag) {
        const manager = new CallbackManager(this.runId);
        manager.setHandlers(this.inheritableHandlers);
        manager.addTags(this.inheritableTags);
        manager.addMetadata(this.inheritableMetadata);
        if (tag) manager.addTags([tag], false);
        return manager;
      }
      async handleRetrieverEnd(documents) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreRetriever) try {
            await handler2.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleRetriever`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
      async handleRetrieverError(err) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreRetriever) try {
            await handler2.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);
          } catch (error40) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleRetrieverError: ${error40}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
    };
    CallbackManagerForLLMRun = class extends BaseRunManager {
      async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreLLM) try {
            await handler2.handleLLMNewToken?.(token, idx ?? {
              prompt: 0,
              completion: 0
            }, this.runId, this._parentRunId, this.tags, fields);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleLLMNewToken: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
      async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreLLM) try {
            await handler2.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);
          } catch (err$1) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleLLMError: ${err$1}`);
            if (handler2.raiseError) throw err$1;
          }
        }, handler2.awaitHandlers)));
      }
      async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreLLM) try {
            await handler2.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleLLMEnd: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
    };
    CallbackManagerForChainRun = class extends BaseRunManager {
      getChild(tag) {
        const manager = new CallbackManager(this.runId);
        manager.setHandlers(this.inheritableHandlers);
        manager.addTags(this.inheritableTags);
        manager.addMetadata(this.inheritableMetadata);
        if (tag) manager.addTags([tag], false);
        return manager;
      }
      async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreChain) try {
            await handler2.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);
          } catch (err$1) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleChainError: ${err$1}`);
            if (handler2.raiseError) throw err$1;
          }
        }, handler2.awaitHandlers)));
      }
      async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreChain) try {
            await handler2.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleChainEnd: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
      async handleAgentAction(action) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreAgent) try {
            await handler2.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleAgentAction: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
      async handleAgentEnd(action) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreAgent) try {
            await handler2.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleAgentEnd: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
    };
    CallbackManagerForToolRun = class extends BaseRunManager {
      getChild(tag) {
        const manager = new CallbackManager(this.runId);
        manager.setHandlers(this.inheritableHandlers);
        manager.addTags(this.inheritableTags);
        manager.addMetadata(this.inheritableMetadata);
        if (tag) manager.addTags([tag], false);
        return manager;
      }
      async handleToolError(err) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreAgent) try {
            await handler2.handleToolError?.(err, this.runId, this._parentRunId, this.tags);
          } catch (err$1) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleToolError: ${err$1}`);
            if (handler2.raiseError) throw err$1;
          }
        }, handler2.awaitHandlers)));
      }
      async handleToolEnd(output) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreAgent) try {
            await handler2.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleToolEnd: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
    };
    CallbackManager = class CallbackManager2 extends BaseCallbackManager {
      handlers = [];
      inheritableHandlers = [];
      tags = [];
      inheritableTags = [];
      metadata = {};
      inheritableMetadata = {};
      name = "callback_manager";
      _parentRunId;
      constructor(parentRunId, options) {
        super();
        this.handlers = options?.handlers ?? this.handlers;
        this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;
        this.tags = options?.tags ?? this.tags;
        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;
        this.metadata = options?.metadata ?? this.metadata;
        this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;
        this._parentRunId = parentRunId;
      }
      /**
      * Gets the parent run ID, if any.
      *
      * @returns The parent run ID.
      */
      getParentRunId() {
        return this._parentRunId;
      }
      async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        return Promise.all(prompts.map(async (prompt, idx) => {
          const runId_ = idx === 0 && runId ? runId : v7_default();
          await Promise.all(this.handlers.map((handler2) => {
            if (handler2.ignoreLLM) return;
            if (isBaseTracer(handler2)) handler2._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            return consumeCallback(async () => {
              try {
                await handler2.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
              } catch (err) {
                const logFunction = handler2.raiseError ? console.error : console.warn;
                logFunction(`Error in handler ${handler2.constructor.name}, handleLLMStart: ${err}`);
                if (handler2.raiseError) throw err;
              }
            }, handler2.awaitHandlers);
          }));
          return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
        }));
      }
      async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        return Promise.all(messages.map(async (messageGroup, idx) => {
          const runId_ = idx === 0 && runId ? runId : v7_default();
          await Promise.all(this.handlers.map((handler2) => {
            if (handler2.ignoreLLM) return;
            if (isBaseTracer(handler2)) handler2._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            return consumeCallback(async () => {
              try {
                if (handler2.handleChatModelStart) await handler2.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                else if (handler2.handleLLMStart) {
                  const messageString = getBufferString(messageGroup);
                  await handler2.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                }
              } catch (err) {
                const logFunction = handler2.raiseError ? console.error : console.warn;
                logFunction(`Error in handler ${handler2.constructor.name}, handleLLMStart: ${err}`);
                if (handler2.raiseError) throw err;
              }
            }, handler2.awaitHandlers);
          }));
          return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
        }));
      }
      async handleChainStart(chain, inputs, runId = v7_default(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0, _parentRunId = void 0, extra = void 0) {
        await Promise.all(this.handlers.map((handler2) => {
          if (handler2.ignoreChain) return;
          if (isBaseTracer(handler2)) handler2._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName, extra);
          return consumeCallback(async () => {
            try {
              await handler2.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName, extra);
            } catch (err) {
              const logFunction = handler2.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler2.constructor.name}, handleChainStart: ${err}`);
              if (handler2.raiseError) throw err;
            }
          }, handler2.awaitHandlers);
        }));
        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleToolStart(tool2, input, runId = v7_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        await Promise.all(this.handlers.map((handler2) => {
          if (handler2.ignoreAgent) return;
          if (isBaseTracer(handler2)) handler2._createRunForToolStart(tool2, input, runId, this._parentRunId, this.tags, this.metadata, runName);
          return consumeCallback(async () => {
            try {
              await handler2.handleToolStart?.(tool2, input, runId, this._parentRunId, this.tags, this.metadata, runName);
            } catch (err) {
              const logFunction = handler2.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler2.constructor.name}, handleToolStart: ${err}`);
              if (handler2.raiseError) throw err;
            }
          }, handler2.awaitHandlers);
        }));
        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleRetrieverStart(retriever, query, runId = v7_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        await Promise.all(this.handlers.map((handler2) => {
          if (handler2.ignoreRetriever) return;
          if (isBaseTracer(handler2)) handler2._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
          return consumeCallback(async () => {
            try {
              await handler2.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
            } catch (err) {
              const logFunction = handler2.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler2.constructor.name}, handleRetrieverStart: ${err}`);
              if (handler2.raiseError) throw err;
            }
          }, handler2.awaitHandlers);
        }));
        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
        await Promise.all(this.handlers.map((handler2) => consumeCallback(async () => {
          if (!handler2.ignoreCustomEvent) try {
            await handler2.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);
          } catch (err) {
            const logFunction = handler2.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler2.constructor.name}, handleCustomEvent: ${err}`);
            if (handler2.raiseError) throw err;
          }
        }, handler2.awaitHandlers)));
      }
      addHandler(handler2, inherit = true) {
        this.handlers.push(handler2);
        if (inherit) this.inheritableHandlers.push(handler2);
      }
      removeHandler(handler2) {
        this.handlers = this.handlers.filter((_handler) => _handler !== handler2);
        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler2);
      }
      setHandlers(handlers, inherit = true) {
        this.handlers = [];
        this.inheritableHandlers = [];
        for (const handler2 of handlers) this.addHandler(handler2, inherit);
      }
      addTags(tags, inherit = true) {
        this.removeTags(tags);
        this.tags.push(...tags);
        if (inherit) this.inheritableTags.push(...tags);
      }
      removeTags(tags) {
        this.tags = this.tags.filter((tag) => !tags.includes(tag));
        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
      }
      addMetadata(metadata, inherit = true) {
        this.metadata = {
          ...this.metadata,
          ...metadata
        };
        if (inherit) this.inheritableMetadata = {
          ...this.inheritableMetadata,
          ...metadata
        };
      }
      removeMetadata(metadata) {
        for (const key of Object.keys(metadata)) {
          delete this.metadata[key];
          delete this.inheritableMetadata[key];
        }
      }
      copy(additionalHandlers = [], inherit = true) {
        const manager = new CallbackManager2(this._parentRunId);
        for (const handler2 of this.handlers) {
          const inheritable = this.inheritableHandlers.includes(handler2);
          manager.addHandler(handler2, inheritable);
        }
        for (const tag of this.tags) {
          const inheritable = this.inheritableTags.includes(tag);
          manager.addTags([tag], inheritable);
        }
        for (const key of Object.keys(this.metadata)) {
          const inheritable = Object.keys(this.inheritableMetadata).includes(key);
          manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
        }
        for (const handler2 of additionalHandlers) {
          if (manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler2.name)) continue;
          manager.addHandler(handler2, inherit);
        }
        return manager;
      }
      static fromHandlers(handlers) {
        class Handler extends BaseCallbackHandler {
          name = v7_default();
          constructor() {
            super();
            Object.assign(this, handlers);
          }
        }
        const manager = new this();
        manager.addHandler(new Handler());
        return manager;
      }
      static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
      }
      static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
        let callbackManager;
        if (inheritableHandlers || localHandlers) {
          if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
            callbackManager = new CallbackManager2();
            callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);
          } else callbackManager = inheritableHandlers;
          callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);
        }
        const verboseEnabled = getEnvironmentVariable("LANGCHAIN_VERBOSE") === "true" || options?.verbose;
        const tracingV2Enabled = LangChainTracer.getTraceableRunTree()?.tracingEnabled ?? isTracingEnabled2();
        const tracingEnabled2 = tracingV2Enabled || (getEnvironmentVariable("LANGCHAIN_TRACING") ?? false);
        if (verboseEnabled || tracingEnabled2) {
          if (!callbackManager) callbackManager = new CallbackManager2();
          if (verboseEnabled && !callbackManager.handlers.some((handler2) => handler2.name === ConsoleCallbackHandler.prototype.name)) {
            const consoleHandler = new ConsoleCallbackHandler();
            callbackManager.addHandler(consoleHandler, true);
          }
          if (tracingEnabled2 && !callbackManager.handlers.some((handler2) => handler2.name === "langchain_tracer")) {
            if (tracingV2Enabled) {
              const tracerV2 = new LangChainTracer();
              callbackManager.addHandler(tracerV2, true);
            }
          }
          if (tracingV2Enabled) {
            const implicitRunTree = LangChainTracer.getTraceableRunTree();
            if (implicitRunTree && callbackManager._parentRunId === void 0) {
              callbackManager._parentRunId = implicitRunTree.id;
              const tracerV2 = callbackManager.handlers.find((handler2) => handler2.name === "langchain_tracer");
              tracerV2?.updateFromRunTree(implicitRunTree);
            }
          }
        }
        for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()) {
          const createIfNotInContext = envVar && getEnvironmentVariable(envVar) === "true" && handlerClass;
          let handler2;
          const contextVarValue = contextVar !== void 0 ? getContextVariable(contextVar) : void 0;
          if (contextVarValue && isBaseCallbackHandler(contextVarValue)) handler2 = contextVarValue;
          else if (createIfNotInContext) handler2 = new handlerClass({});
          if (handler2 !== void 0) {
            if (!callbackManager) callbackManager = new CallbackManager2();
            if (!callbackManager.handlers.some((h) => h.name === handler2.name)) callbackManager.addHandler(handler2, inheritable);
          }
        }
        if (inheritableTags || localTags) {
          if (callbackManager) {
            callbackManager.addTags(inheritableTags ?? []);
            callbackManager.addTags(localTags ?? [], false);
          }
        }
        if (inheritableMetadata || localMetadata) {
          if (callbackManager) {
            callbackManager.addMetadata(inheritableMetadata ?? {});
            callbackManager.addMetadata(localMetadata ?? {}, false);
          }
        }
        return callbackManager;
      }
    };
  }
});

// node_modules/@langchain/core/dist/singletons/async_local_storage/index.js
var MockAsyncLocalStorage2, mockAsyncLocalStorage2, LC_CHILD_KEY, AsyncLocalStorageProvider2, AsyncLocalStorageProviderSingleton2;
var init_async_local_storage = __esm({
  "node_modules/@langchain/core/dist/singletons/async_local_storage/index.js"() {
    init_globals();
    init_manager();
    init_langsmith();
    MockAsyncLocalStorage2 = class {
      getStore() {
        return void 0;
      }
      run(_store, callback) {
        return callback();
      }
      enterWith(_store) {
        return void 0;
      }
    };
    mockAsyncLocalStorage2 = new MockAsyncLocalStorage2();
    LC_CHILD_KEY = Symbol.for("lc:child_config");
    AsyncLocalStorageProvider2 = class {
      getInstance() {
        return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage2;
      }
      getRunnableConfig() {
        const storage = this.getInstance();
        return storage.getStore()?.extra?.[LC_CHILD_KEY];
      }
      runWithConfig(config2, callback, avoidCreatingRootRunTree) {
        const callbackManager = CallbackManager._configureSync(config2?.callbacks, void 0, config2?.tags, void 0, config2?.metadata);
        const storage = this.getInstance();
        const previousValue = storage.getStore();
        const parentRunId = callbackManager?.getParentRunId();
        const langChainTracer = callbackManager?.handlers?.find((handler2) => handler2?.name === "langchain_tracer");
        let runTree;
        if (langChainTracer && parentRunId) runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);
        else if (!avoidCreatingRootRunTree) runTree = new RunTree({
          name: "<runnable_lambda>",
          tracingEnabled: false
        });
        if (runTree) runTree.extra = {
          ...runTree.extra,
          [LC_CHILD_KEY]: config2
        };
        if (previousValue !== void 0 && previousValue[_CONTEXT_VARIABLES_KEY] !== void 0) {
          if (runTree === void 0) runTree = {};
          runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
        }
        return storage.run(runTree, callback);
      }
      initializeGlobalInstance(instance) {
        if (getGlobalAsyncLocalStorageInstance() === void 0) setGlobalAsyncLocalStorageInstance(instance);
      }
    };
    AsyncLocalStorageProviderSingleton2 = new AsyncLocalStorageProvider2();
  }
});

// node_modules/@langchain/core/dist/singletons/index.js
var singletons_exports;
var init_singletons = __esm({
  "node_modules/@langchain/core/dist/singletons/index.js"() {
    init_rolldown_runtime();
    init_globals();
    init_async_local_storage();
    singletons_exports = {};
    __export2(singletons_exports, {
      AsyncLocalStorageProviderSingleton: () => AsyncLocalStorageProviderSingleton2,
      MockAsyncLocalStorage: () => MockAsyncLocalStorage2,
      _CONTEXT_VARIABLES_KEY: () => _CONTEXT_VARIABLES_KEY
    });
  }
});

// node_modules/@langchain/langgraph/dist/setup/async_local_storage.js
import { AsyncLocalStorage } from "node:async_hooks";
function initializeAsyncLocalStorageSingleton() {
  AsyncLocalStorageProviderSingleton2.initializeGlobalInstance(new AsyncLocalStorage());
}
var init_async_local_storage2 = __esm({
  "node_modules/@langchain/langgraph/dist/setup/async_local_storage.js"() {
    init_singletons();
  }
});

// node_modules/@langchain/langgraph/dist/errors.js
function isParentCommand(e) {
  return e !== void 0 && e.name === ParentCommand.unminifiable_name;
}
function isGraphBubbleUp(e) {
  return e !== void 0 && e.is_bubble_up === true;
}
function isGraphInterrupt(e) {
  return e !== void 0 && [GraphInterrupt.unminifiable_name, NodeInterrupt.unminifiable_name].includes(e.name);
}
var BaseLangGraphError, GraphBubbleUp, GraphRecursionError, GraphValueError, GraphInterrupt, NodeInterrupt, ParentCommand, EmptyInputError, EmptyChannelError, InvalidUpdateError, UnreachableNodeError, StateGraphInputError;
var init_errors3 = __esm({
  "node_modules/@langchain/langgraph/dist/errors.js"() {
    BaseLangGraphError = class extends Error {
      lc_error_code;
      constructor(message, fields) {
        let finalMessage = message ?? "";
        if (fields?.lc_error_code) finalMessage = `${finalMessage}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langgraph/${fields.lc_error_code}/
`;
        super(finalMessage);
        this.lc_error_code = fields?.lc_error_code;
      }
    };
    GraphBubbleUp = class extends BaseLangGraphError {
      get is_bubble_up() {
        return true;
      }
    };
    GraphRecursionError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "GraphRecursionError";
      }
      static get unminifiable_name() {
        return "GraphRecursionError";
      }
    };
    GraphValueError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "GraphValueError";
      }
      static get unminifiable_name() {
        return "GraphValueError";
      }
    };
    GraphInterrupt = class extends GraphBubbleUp {
      interrupts;
      constructor(interrupts, fields) {
        super(JSON.stringify(interrupts, null, 2), fields);
        this.name = "GraphInterrupt";
        this.interrupts = interrupts ?? [];
      }
      static get unminifiable_name() {
        return "GraphInterrupt";
      }
    };
    NodeInterrupt = class extends GraphInterrupt {
      constructor(message, fields) {
        super([{ value: message }], fields);
        this.name = "NodeInterrupt";
      }
      static get unminifiable_name() {
        return "NodeInterrupt";
      }
    };
    ParentCommand = class extends GraphBubbleUp {
      command;
      constructor(command) {
        super();
        this.name = "ParentCommand";
        this.command = command;
      }
      static get unminifiable_name() {
        return "ParentCommand";
      }
    };
    EmptyInputError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "EmptyInputError";
      }
      static get unminifiable_name() {
        return "EmptyInputError";
      }
    };
    EmptyChannelError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "EmptyChannelError";
      }
      static get unminifiable_name() {
        return "EmptyChannelError";
      }
    };
    InvalidUpdateError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "InvalidUpdateError";
      }
      static get unminifiable_name() {
        return "InvalidUpdateError";
      }
    };
    UnreachableNodeError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "UnreachableNodeError";
      }
      static get unminifiable_name() {
        return "UnreachableNodeError";
      }
    };
    StateGraphInputError = class extends BaseLangGraphError {
      /**
      * Create a new StateGraphInputError.
      * @param message - Optional custom error message.
      * @param fields - Optional additional error fields.
      */
      constructor(message, fields) {
        super(message, fields);
        this.name = "StateGraphInputError";
        this.message = "Invalid StateGraph input. Make sure to pass a valid StateDefinition, Annotation.Root, or Zod schema.";
      }
      /**
      * The unminifiable (static, human-readable) error name for this error class.
      */
      static get unminifiable_name() {
        return "StateGraphInputError";
      }
    };
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/regex.js
var regex_default3;
var init_regex3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default3 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js
function validate3(uuid8) {
  return typeof uuid8 === "string" && regex_default3.test(uuid8);
}
var validate_default3;
var init_validate3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex3();
    validate_default3 = validate3;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js
function parse3(uuid8) {
  if (!validate_default3(uuid8)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr3 = new Uint8Array(16);
  arr3[0] = (v = parseInt(uuid8.slice(0, 8), 16)) >>> 24;
  arr3[1] = v >>> 16 & 255;
  arr3[2] = v >>> 8 & 255;
  arr3[3] = v & 255;
  arr3[4] = (v = parseInt(uuid8.slice(9, 13), 16)) >>> 8;
  arr3[5] = v & 255;
  arr3[6] = (v = parseInt(uuid8.slice(14, 18), 16)) >>> 8;
  arr3[7] = v & 255;
  arr3[8] = (v = parseInt(uuid8.slice(19, 23), 16)) >>> 8;
  arr3[9] = v & 255;
  arr3[10] = (v = parseInt(uuid8.slice(24, 36), 16)) / 1099511627776 & 255;
  arr3[11] = v / 4294967296 & 255;
  arr3[12] = v >>> 24 & 255;
  arr3[13] = v >>> 16 & 255;
  arr3[14] = v >>> 8 & 255;
  arr3[15] = v & 255;
  return arr3;
}
var parse_default3;
var init_parse3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate3();
    parse_default3 = parse3;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify3(arr3, offset = 0) {
  return (byteToHex3[arr3[offset + 0]] + byteToHex3[arr3[offset + 1]] + byteToHex3[arr3[offset + 2]] + byteToHex3[arr3[offset + 3]] + "-" + byteToHex3[arr3[offset + 4]] + byteToHex3[arr3[offset + 5]] + "-" + byteToHex3[arr3[offset + 6]] + byteToHex3[arr3[offset + 7]] + "-" + byteToHex3[arr3[offset + 8]] + byteToHex3[arr3[offset + 9]] + "-" + byteToHex3[arr3[offset + 10]] + byteToHex3[arr3[offset + 11]] + byteToHex3[arr3[offset + 12]] + byteToHex3[arr3[offset + 13]] + byteToHex3[arr3[offset + 14]] + byteToHex3[arr3[offset + 15]]).toLowerCase();
}
var byteToHex3;
var init_stringify3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js"() {
    byteToHex3 = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex3.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/rng.js
import crypto8 from "node:crypto";
function rng3() {
  if (poolPtr3 > rnds8Pool3.length - 16) {
    crypto8.randomFillSync(rnds8Pool3);
    poolPtr3 = 0;
  }
  return rnds8Pool3.slice(poolPtr3, poolPtr3 += 16);
}
var rnds8Pool3, poolPtr3;
var init_rng3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool3 = new Uint8Array(256);
    poolPtr3 = rnds8Pool3.length;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node;
  let clockseq = options.clockseq;
  if (!options._v6) {
    if (!node) {
      node = _nodeId;
    }
    if (clockseq == null) {
      clockseq = _clockseq;
    }
  }
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng3)();
    if (node == null) {
      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      if (!_nodeId && !options._v6) {
        node[0] |= 1;
        _nodeId = node;
      }
    }
    if (clockseq == null) {
      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      if (_clockseq === void 0 && !options._v6) {
        _clockseq = clockseq;
      }
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n2 = 0; n2 < 6; ++n2) {
    b[i + n2] = node[n2];
  }
  return buf || unsafeStringify3(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng3();
    init_stringify3();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1ToV6.js
function v1ToV6(uuid8) {
  const v1Bytes = typeof uuid8 === "string" ? parse_default3(uuid8) : uuid8;
  const v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid8 === "string" ? unsafeStringify3(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes, randomize = false) {
  return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}
var init_v1ToV6 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1ToV6.js"() {
    init_parse3();
    init_stringify3();
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes3(str2) {
  str2 = unescape(encodeURIComponent(str2));
  const bytes = [];
  for (let i = 0; i < str2.length; ++i) {
    bytes.push(str2.charCodeAt(i));
  }
  return bytes;
}
function v353(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes3(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default3(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify3(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS3;
  generateUUID.URL = URL4;
  return generateUUID;
}
var DNS3, URL4;
var init_v353 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify3();
    init_parse3();
    DNS3 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL4 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/sha1.js
import crypto9 from "node:crypto";
function sha13(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto9.createHash("sha1").update(bytes).digest();
}
var sha1_default3;
var init_sha13 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/sha1.js"() {
    sha1_default3 = sha13;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v5.js
var v53, v5_default3;
var init_v53 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v353();
    init_sha13();
    v53 = v353("v5", 80, sha1_default3);
    v5_default3 = v53;
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v6.js
function v6(options = {}, buf, offset = 0) {
  let bytes = v1_default({
    ...options,
    _v6: true
  }, new Uint8Array(16));
  bytes = v1ToV6(bytes);
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify3(bytes);
}
var init_v6 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v6.js"() {
    init_stringify3();
    init_v1();
    init_v1ToV6();
  }
});

// node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/index.js
var init_esm_node3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/index.js"() {
    init_v53();
    init_v6();
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/id.js
function uuid6(clockseq) {
  return v6({ clockseq });
}
function uuid5(name, namespace) {
  const namespaceBytes = namespace.replace(/-/g, "").match(/.{2}/g).map((byte) => parseInt(byte, 16));
  return v5_default3(name, new Uint8Array(namespaceBytes));
}
var init_id = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/id.js"() {
    init_esm_node3();
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js
var ERROR2, SCHEDULED, INTERRUPT, RESUME;
var init_types2 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js"() {
    ERROR2 = "__error__";
    SCHEDULED = "__scheduled__";
    INTERRUPT = "__interrupt__";
    RESUME = "__resume__";
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.js
function defaultOptions2() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify(obj, replacer, spacer, options) {
  if (typeof options === "undefined") options = defaultOptions2();
  decirc2(obj, "", 0, [], void 0, 0, options);
  var res;
  try {
    if (replacerStack2.length === 0) res = JSON.stringify(obj, replacer, spacer);
    else res = JSON.stringify(obj, replaceGetterValues2(replacer), spacer);
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr2.length !== 0) {
      var part = arr2.pop();
      if (part.length === 4) Object.defineProperty(part[0], part[1], part[3]);
      else part[0][part[1]] = part[2];
    }
  }
  return res;
}
function setReplace2(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) if (propertyDescriptor.configurable) {
    Object.defineProperty(parent, k, { value: replace });
    arr2.push([
      parent,
      k,
      val,
      propertyDescriptor
    ]);
  } else replacerStack2.push([
    val,
    k,
    replace
  ]);
  else {
    parent[k] = replace;
    arr2.push([
      parent,
      k,
      val
    ]);
  }
}
function decirc2(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) if (stack[i] === val) {
      setReplace2(CIRCULAR_REPLACE_NODE2, val, k, parent);
      return;
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace2(LIMIT_REPLACE_NODE2, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace2(LIMIT_REPLACE_NODE2, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) for (i = 0; i < val.length; i++) decirc2(val[i], i, i, stack, val, depth, options);
    else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc2(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function replaceGetterValues2(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack2.length > 0) for (var i = 0; i < replacerStack2.length; i++) {
      var part = replacerStack2[i];
      if (part[1] === key && part[0] === val) {
        val = part[2];
        replacerStack2.splice(i, 1);
        break;
      }
    }
    return replacer.call(this, key, val);
  };
}
var LIMIT_REPLACE_NODE2, CIRCULAR_REPLACE_NODE2, arr2, replacerStack2;
var init_fast_safe_stringify2 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.js"() {
    LIMIT_REPLACE_NODE2 = "[...]";
    CIRCULAR_REPLACE_NODE2 = "[Circular]";
    arr2 = [];
    replacerStack2 = [];
  }
});

// node_modules/@langchain/core/dist/load/import_constants.js
var optionalImportEntrypoints;
var init_import_constants = __esm({
  "node_modules/@langchain/core/dist/load/import_constants.js"() {
    optionalImportEntrypoints = [];
  }
});

// node_modules/@langchain/core/dist/agents.js
var agents_exports;
var init_agents = __esm({
  "node_modules/@langchain/core/dist/agents.js"() {
    agents_exports = {};
  }
});

// node_modules/@langchain/core/dist/runnables/config.js
async function getCallbackManagerForConfig(config2) {
  return CallbackManager._configureSync(config2?.callbacks, void 0, config2?.tags, void 0, config2?.metadata);
}
function mergeConfigs(...configs) {
  const copy = {};
  for (const options of configs.filter((c) => !!c)) for (const key of Object.keys(options)) if (key === "metadata") copy[key] = {
    ...copy[key],
    ...options[key]
  };
  else if (key === "tags") {
    const baseKeys = copy[key] ?? [];
    copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];
  } else if (key === "configurable") copy[key] = {
    ...copy[key],
    ...options[key]
  };
  else if (key === "timeout") {
    if (copy.timeout === void 0) copy.timeout = options.timeout;
    else if (options.timeout !== void 0) copy.timeout = Math.min(copy.timeout, options.timeout);
  } else if (key === "signal") {
    if (copy.signal === void 0) copy.signal = options.signal;
    else if (options.signal !== void 0) if ("any" in AbortSignal) copy.signal = AbortSignal.any([copy.signal, options.signal]);
    else copy.signal = options.signal;
  } else if (key === "callbacks") {
    const baseCallbacks = copy.callbacks;
    const providedCallbacks = options.callbacks;
    if (Array.isArray(providedCallbacks)) if (!baseCallbacks) copy.callbacks = providedCallbacks;
    else if (Array.isArray(baseCallbacks)) copy.callbacks = baseCallbacks.concat(providedCallbacks);
    else {
      const manager = baseCallbacks.copy();
      for (const callback of providedCallbacks) manager.addHandler(ensureHandler(callback), true);
      copy.callbacks = manager;
    }
    else if (providedCallbacks) if (!baseCallbacks) copy.callbacks = providedCallbacks;
    else if (Array.isArray(baseCallbacks)) {
      const manager = providedCallbacks.copy();
      for (const callback of baseCallbacks) manager.addHandler(ensureHandler(callback), true);
      copy.callbacks = manager;
    } else copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
      handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
      inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
      tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
      inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
      metadata: {
        ...baseCallbacks.metadata,
        ...providedCallbacks.metadata
      }
    });
  } else {
    const typedKey = key;
    copy[typedKey] = options[typedKey] ?? copy[typedKey];
  }
  return copy;
}
function ensureConfig(config2) {
  const implicitConfig = AsyncLocalStorageProviderSingleton2.getRunnableConfig();
  let empty = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (implicitConfig) {
    const { runId, runName, ...rest } = implicitConfig;
    empty = Object.entries(rest).reduce((currentConfig, [key, value]) => {
      if (value !== void 0) currentConfig[key] = value;
      return currentConfig;
    }, empty);
  }
  if (config2) empty = Object.entries(config2).reduce((currentConfig, [key, value]) => {
    if (value !== void 0) currentConfig[key] = value;
    return currentConfig;
  }, empty);
  if (empty?.configurable) {
    for (const key of Object.keys(empty.configurable)) if (PRIMITIVES.has(typeof empty.configurable[key]) && !empty.metadata?.[key]) {
      if (!empty.metadata) empty.metadata = {};
      empty.metadata[key] = empty.configurable[key];
    }
  }
  if (empty.timeout !== void 0) {
    if (empty.timeout <= 0) throw new Error("Timeout must be a positive number");
    const originalTimeoutMs = empty.timeout;
    const timeoutSignal = AbortSignal.timeout(originalTimeoutMs);
    if (!empty.metadata) empty.metadata = {};
    if (empty.metadata.timeoutMs === void 0) empty.metadata.timeoutMs = originalTimeoutMs;
    if (empty.signal !== void 0) {
      if ("any" in AbortSignal) empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);
    } else empty.signal = timeoutSignal;
    delete empty.timeout;
  }
  return empty;
}
function patchConfig(config2 = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
  const newConfig = ensureConfig(config2);
  if (callbacks !== void 0) {
    delete newConfig.runName;
    newConfig.callbacks = callbacks;
  }
  if (recursionLimit !== void 0) newConfig.recursionLimit = recursionLimit;
  if (maxConcurrency !== void 0) newConfig.maxConcurrency = maxConcurrency;
  if (runName !== void 0) newConfig.runName = runName;
  if (configurable !== void 0) newConfig.configurable = {
    ...newConfig.configurable,
    ...configurable
  };
  if (runId !== void 0) delete newConfig.runId;
  return newConfig;
}
function pickRunnableConfigKeys(config2) {
  if (!config2) return void 0;
  return {
    configurable: config2.configurable,
    recursionLimit: config2.recursionLimit,
    callbacks: config2.callbacks,
    tags: config2.tags,
    metadata: config2.metadata,
    maxConcurrency: config2.maxConcurrency,
    timeout: config2.timeout,
    signal: config2.signal,
    store: config2.store
  };
}
var DEFAULT_RECURSION_LIMIT, PRIMITIVES;
var init_config = __esm({
  "node_modules/@langchain/core/dist/runnables/config.js"() {
    init_manager();
    init_async_local_storage();
    init_singletons();
    DEFAULT_RECURSION_LIMIT = 25;
    PRIMITIVES = /* @__PURE__ */ new Set([
      "string",
      "number",
      "boolean"
    ]);
  }
});

// node_modules/@langchain/core/dist/utils/signal.js
async function raceWithSignal(promise2, signal) {
  if (signal === void 0) return promise2;
  let listener;
  return Promise.race([promise2.catch((err) => {
    if (!signal?.aborted) throw err;
    else return void 0;
  }), new Promise((_, reject) => {
    listener = () => {
      reject(getAbortSignalError(signal));
    };
    signal.addEventListener("abort", listener);
    if (signal.aborted) reject(getAbortSignalError(signal));
  })]).finally(() => signal.removeEventListener("abort", listener));
}
function getAbortSignalError(signal) {
  if (signal?.reason instanceof Error) return signal.reason;
  if (typeof signal?.reason === "string") return new Error(signal.reason);
  return /* @__PURE__ */ new Error("Aborted");
}
var init_signal = __esm({
  "node_modules/@langchain/core/dist/utils/signal.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/stream.js
function atee(iter, length = 2) {
  const buffers = Array.from({ length }, () => []);
  return buffers.map(async function* makeIter(buffer) {
    while (true) if (buffer.length === 0) {
      const result = await iter.next();
      for (const buffer$1 of buffers) buffer$1.push(result);
    } else if (buffer[0].done) return;
    else yield buffer.shift().value;
  });
}
function concat(first, second) {
  if (Array.isArray(first) && Array.isArray(second)) return first.concat(second);
  else if (typeof first === "string" && typeof second === "string") return first + second;
  else if (typeof first === "number" && typeof second === "number") return first + second;
  else if ("concat" in first && typeof first.concat === "function") return first.concat(second);
  else if (typeof first === "object" && typeof second === "object") {
    const chunk = { ...first };
    for (const [key, value] of Object.entries(second)) if (key in chunk && !Array.isArray(chunk[key])) chunk[key] = concat(chunk[key], value);
    else chunk[key] = value;
    return chunk;
  } else throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
}
async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
  const gen = new AsyncGeneratorWithSetup({
    generator,
    startSetup,
    signal
  });
  const setup = await gen.setup;
  return {
    output: to(gen, setup, ...args),
    setup
  };
}
var stream_exports, IterableReadableStream, AsyncGeneratorWithSetup;
var init_stream = __esm({
  "node_modules/@langchain/core/dist/utils/stream.js"() {
    init_rolldown_runtime();
    init_async_local_storage();
    init_singletons();
    init_config();
    init_signal();
    stream_exports = {};
    __export2(stream_exports, {
      AsyncGeneratorWithSetup: () => AsyncGeneratorWithSetup,
      IterableReadableStream: () => IterableReadableStream,
      atee: () => atee,
      concat: () => concat,
      pipeGeneratorWithSetup: () => pipeGeneratorWithSetup
    });
    IterableReadableStream = class IterableReadableStream2 extends ReadableStream {
      reader;
      ensureReader() {
        if (!this.reader) this.reader = this.getReader();
      }
      async next() {
        this.ensureReader();
        try {
          const result = await this.reader.read();
          if (result.done) {
            this.reader.releaseLock();
            return {
              done: true,
              value: void 0
            };
          } else return {
            done: false,
            value: result.value
          };
        } catch (e) {
          this.reader.releaseLock();
          throw e;
        }
      }
      async return() {
        this.ensureReader();
        if (this.locked) {
          const cancelPromise = this.reader.cancel();
          this.reader.releaseLock();
          await cancelPromise;
        }
        return {
          done: true,
          value: void 0
        };
      }
      async throw(e) {
        this.ensureReader();
        if (this.locked) {
          const cancelPromise = this.reader.cancel();
          this.reader.releaseLock();
          await cancelPromise;
        }
        throw e;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async [Symbol.asyncDispose]() {
        await this.return();
      }
      static fromReadableStream(stream) {
        const reader = stream.getReader();
        return new IterableReadableStream2({
          start(controller) {
            return pump();
            function pump() {
              return reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                  return;
                }
                controller.enqueue(value);
                return pump();
              });
            }
          },
          cancel() {
            reader.releaseLock();
          }
        });
      }
      static fromAsyncGenerator(generator) {
        return new IterableReadableStream2({
          async pull(controller) {
            const { value, done } = await generator.next();
            if (done) controller.close();
            controller.enqueue(value);
          },
          async cancel(reason) {
            await generator.return(reason);
          }
        });
      }
    };
    AsyncGeneratorWithSetup = class {
      generator;
      setup;
      config;
      signal;
      firstResult;
      firstResultUsed = false;
      constructor(params) {
        this.generator = params.generator;
        this.config = params.config;
        this.signal = params.signal ?? this.config?.signal;
        this.setup = new Promise((resolve, reject) => {
          AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(params.config), async () => {
            this.firstResult = params.generator.next();
            if (params.startSetup) this.firstResult.then(params.startSetup).then(resolve, reject);
            else this.firstResult.then((_result) => resolve(void 0), reject);
          }, true);
        });
      }
      async next(...args) {
        this.signal?.throwIfAborted();
        if (!this.firstResultUsed) {
          this.firstResultUsed = true;
          return this.firstResult;
        }
        return AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(this.config), this.signal ? async () => {
          return raceWithSignal(this.generator.next(...args), this.signal);
        } : async () => {
          return this.generator.next(...args);
        }, true);
      }
      async return(value) {
        return this.generator.return(value);
      }
      async throw(e) {
        return this.generator.throw(e);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async [Symbol.asyncDispose]() {
        await this.return();
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys$1 = new Array(obj.length);
    for (let k = 0; k < keys$1.length; k++) keys$1[k] = "" + k;
    return keys$1;
  }
  if (Object.keys) return Object.keys(obj);
  let keys = [];
  for (let i in obj) if (hasOwnProperty(obj, i)) keys.push(i);
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str2) {
  let i = 0;
  const len = str2.length;
  let charCode;
  while (i < len) {
    charCode = str2.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path3) {
  if (path3.indexOf("/") === -1 && path3.indexOf("~") === -1) return path3;
  return path3.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path3) {
  return path3.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) return true;
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i$1 = 0, len = obj.length; i$1 < len; i$1++) if (hasUndefined(obj[i$1])) return true;
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) if (hasUndefined(obj[objKeys[i]])) return true;
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") messageParts.push(`${key}: ${value}`);
  }
  return messageParts.join("\n");
}
var _hasOwnProperty, PatchError;
var init_helpers = __esm({
  "node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js"() {
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    PatchError = class extends Error {
      constructor(message, name, index2, operation, tree) {
        super(patchErrorMessageFormatter(message, {
          name,
          index: index2,
          operation,
          tree
        }));
        this.name = name;
        this.index = index2;
        this.operation = operation;
        this.tree = tree;
        Object.setPrototypeOf(this, new.target.prototype);
        this.message = patchErrorMessageFormatter(message, {
          name,
          index: index2,
          operation,
          tree
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
function isDangerousKey(key) {
  return Object.getOwnPropertyNames(Object.prototype).includes(key);
}
function getValueByPointer(document, pointer) {
  if (pointer == "") return document;
  var getOriginalDestination = {
    op: "_get",
    path: pointer
  };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index2 = 0) {
  if (validateOperation) if (typeof validateOperation == "function") validateOperation(operation, 0, document, operation.path);
  else validator(operation, 0);
  if (operation.path === "") {
    let returnValue = { newDocument: document };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document, operation.from);
      if (operation.op === "move") returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document);
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else if (validateOperation) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document);
    else return returnValue;
  } else {
    if (!mutateDocument) document = _deepClone(document);
    const path3 = operation.path || "";
    const keys = path3.split("/");
    let obj = document;
    let t = 1;
    let len = keys.length;
    let existingPathFragment = void 0;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function") validateFunction = validateOperation;
    else validateFunction = validator;
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) key = unescapePathComponent(key);
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) existingPathFragment = keys.slice(0, t).join("/");
          else if (t == len - 1) existingPathFragment = operation.path;
          if (existingPathFragment !== void 0) validateFunction(operation, 0, document, existingPathFragment);
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") key = obj.length;
        else if (validateOperation && !isInteger(key)) throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index2, operation, document);
        else if (isInteger(key)) key = ~~key;
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index2, operation, document);
          const returnValue = arrOps[operation.op].call(operation, obj, key, document);
          if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document);
          return returnValue;
        }
      } else if (t >= len) {
        const returnValue = objOps[operation.op].call(operation, obj, key, document);
        if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document);
        return returnValue;
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document);
    }
  }
}
function applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
  if (validateOperation) {
    if (!Array.isArray(patch)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  }
  if (!mutateDocument) document = _deepClone(document);
  const results = new Array(patch.length);
  for (let i = 0, length = patch.length; i < length; i++) {
    results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
    document = results[i].newDocument;
  }
  results.newDocument = document;
  return results;
}
function applyReducer(document, operation, index2) {
  const operationResult = applyOperation(document, operation);
  if (operationResult.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document);
  return operationResult.newDocument;
}
function validator(operation, index2, document, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, document);
  else if (!objOps[operation.op]) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document);
  else if (typeof operation.path !== "string") throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, document);
  else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index2, operation, document);
  else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, document);
  else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, document);
  else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, document);
  else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, document);
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document);
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: void 0
      };
      var error40 = validate4([existingValue], document);
      if (error40 && error40.name === "OPERATION_PATH_UNRESOLVABLE") throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, document);
    }
  }
}
function validate4(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (document) applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);
    else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) externalValidator(sequence[i], i, document, void 0);
    }
  } catch (e) {
    if (e instanceof JsonPatchError) return e;
    else throw e;
  }
}
function _areEquals(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; ) if (!_areEquals(a[i], b[i])) return false;
      return true;
    }
    if (arrA != arrB) return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0; ) if (!b.hasOwnProperty(keys[i])) return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key])) return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
var core_exports, JsonPatchError, deepClone, objOps, arrOps;
var init_core = __esm({
  "node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js"() {
    init_rolldown_runtime();
    init_helpers();
    core_exports = {};
    __export2(core_exports, {
      JsonPatchError: () => JsonPatchError,
      _areEquals: () => _areEquals,
      applyOperation: () => applyOperation,
      applyPatch: () => applyPatch,
      applyReducer: () => applyReducer,
      deepClone: () => deepClone,
      getValueByPointer: () => getValueByPointer,
      validate: () => validate4,
      validator: () => validator
    });
    JsonPatchError = PatchError;
    deepClone = _deepClone;
    objOps = {
      add: function(obj, key, document) {
        if (isDangerousKey(key)) throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
        obj[key] = this.value;
        return { newDocument: document };
      },
      remove: function(obj, key, document) {
        if (isDangerousKey(key)) throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
        var removed = obj[key];
        delete obj[key];
        return {
          newDocument: document,
          removed
        };
      },
      replace: function(obj, key, document) {
        if (isDangerousKey(key)) throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
        var removed = obj[key];
        obj[key] = this.value;
        return {
          newDocument: document,
          removed
        };
      },
      move: function(obj, key, document) {
        let removed = getValueByPointer(document, this.path);
        if (removed) removed = _deepClone(removed);
        const originalValue = applyOperation(document, {
          op: "remove",
          path: this.from
        }).removed;
        applyOperation(document, {
          op: "add",
          path: this.path,
          value: originalValue
        });
        return {
          newDocument: document,
          removed
        };
      },
      copy: function(obj, key, document) {
        const valueToCopy = getValueByPointer(document, this.from);
        applyOperation(document, {
          op: "add",
          path: this.path,
          value: _deepClone(valueToCopy)
        });
        return { newDocument: document };
      },
      test: function(obj, key, document) {
        return {
          newDocument: document,
          test: _areEquals(obj[key], this.value)
        };
      },
      _get: function(obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
      }
    };
    arrOps = {
      add: function(arr3, i, document) {
        if (isInteger(i)) arr3.splice(i, 0, this.value);
        else arr3[i] = this.value;
        return {
          newDocument: document,
          index: i
        };
      },
      remove: function(arr3, i, document) {
        var removedList = arr3.splice(i, 1);
        return {
          newDocument: document,
          removed: removedList[0]
        };
      },
      replace: function(arr3, i, document) {
        var removed = arr3[i];
        arr3[i] = this.value;
        return {
          newDocument: document,
          removed
        };
      },
      move: objOps.move,
      copy: objOps.copy,
      test: objOps.test,
      _get: objOps._get
    };
  }
});

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js
function _generate(mirror, obj, patches, path3, invertible) {
  if (obj === mirror) return;
  if (typeof obj.toJSON === "function") obj = obj.toJSON();
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key = oldKeys[t];
    var oldVal = mirror[key];
    if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) _generate(oldVal, newVal, patches, path3 + "/" + escapePathComponent(key), invertible);
      else if (oldVal !== newVal) {
        changed = true;
        if (invertible) patches.push({
          op: "test",
          path: path3 + "/" + escapePathComponent(key),
          value: _deepClone(oldVal)
        });
        patches.push({
          op: "replace",
          path: path3 + "/" + escapePathComponent(key),
          value: _deepClone(newVal)
        });
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) patches.push({
        op: "test",
        path: path3 + "/" + escapePathComponent(key),
        value: _deepClone(oldVal)
      });
      patches.push({
        op: "remove",
        path: path3 + "/" + escapePathComponent(key)
      });
      deleted = true;
    } else {
      if (invertible) patches.push({
        op: "test",
        path: path3,
        value: mirror
      });
      patches.push({
        op: "replace",
        path: path3,
        value: obj
      });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) return;
  for (var t = 0; t < newKeys.length; t++) {
    var key = newKeys[t];
    if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) patches.push({
      op: "add",
      path: path3 + "/" + escapePathComponent(key),
      value: _deepClone(obj[key])
    });
  }
}
function compare(tree1, tree2, invertible = false) {
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
var init_duplex = __esm({
  "node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js"() {
    init_helpers();
    init_core();
  }
});

// node_modules/@langchain/core/dist/utils/fast-json-patch/index.js
var fast_json_patch_default;
var init_fast_json_patch = __esm({
  "node_modules/@langchain/core/dist/utils/fast-json-patch/index.js"() {
    init_helpers();
    init_core();
    init_duplex();
    fast_json_patch_default = {
      ...core_exports,
      JsonPatchError: PatchError,
      deepClone: _deepClone,
      escapePathComponent,
      unescapePathComponent
    };
  }
});

// node_modules/@langchain/core/dist/tracers/log_stream.js
async function _getStandardizedInputs(run, schemaFormat) {
  if (schemaFormat === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs } = run;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(run.run_type)) return inputs;
  if (Object.keys(inputs).length === 1 && inputs?.input === "") return void 0;
  return inputs.input;
}
async function _getStandardizedOutputs(run, schemaFormat) {
  const { outputs } = run;
  if (schemaFormat === "original") return outputs;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(run.run_type)) return outputs;
  if (outputs !== void 0 && Object.keys(outputs).length === 1 && outputs?.output !== void 0) return outputs.output;
  return outputs;
}
function isChatGenerationChunk(x) {
  return x !== void 0 && x.message !== void 0;
}
var log_stream_exports, RunLogPatch, RunLog, isLogStreamHandler, LogStreamCallbackHandler;
var init_log_stream = __esm({
  "node_modules/@langchain/core/dist/tracers/log_stream.js"() {
    init_rolldown_runtime();
    init_ai();
    init_core();
    init_fast_json_patch();
    init_base3();
    init_stream();
    log_stream_exports = {};
    __export2(log_stream_exports, {
      LogStreamCallbackHandler: () => LogStreamCallbackHandler,
      RunLog: () => RunLog,
      RunLogPatch: () => RunLogPatch,
      isLogStreamHandler: () => isLogStreamHandler
    });
    RunLogPatch = class {
      ops;
      constructor(fields) {
        this.ops = fields.ops ?? [];
      }
      concat(other) {
        const ops = this.ops.concat(other.ops);
        const states = applyPatch({}, ops);
        return new RunLog({
          ops,
          state: states[states.length - 1].newDocument
        });
      }
    };
    RunLog = class RunLog2 extends RunLogPatch {
      state;
      constructor(fields) {
        super(fields);
        this.state = fields.state;
      }
      concat(other) {
        const ops = this.ops.concat(other.ops);
        const states = applyPatch(this.state, other.ops);
        return new RunLog2({
          ops,
          state: states[states.length - 1].newDocument
        });
      }
      static fromRunLogPatch(patch) {
        const states = applyPatch({}, patch.ops);
        return new RunLog2({
          ops: patch.ops,
          state: states[states.length - 1].newDocument
        });
      }
    };
    isLogStreamHandler = (handler2) => handler2.name === "log_stream_tracer";
    LogStreamCallbackHandler = class extends BaseTracer {
      autoClose = true;
      includeNames;
      includeTypes;
      includeTags;
      excludeNames;
      excludeTypes;
      excludeTags;
      _schemaFormat = "original";
      rootId;
      keyMapByRunId = {};
      counterMapByRunName = {};
      transformStream;
      writer;
      receiveStream;
      name = "log_stream_tracer";
      lc_prefer_streaming = true;
      constructor(fields) {
        super({
          _awaitHandler: true,
          ...fields
        });
        this.autoClose = fields?.autoClose ?? true;
        this.includeNames = fields?.includeNames;
        this.includeTypes = fields?.includeTypes;
        this.includeTags = fields?.includeTags;
        this.excludeNames = fields?.excludeNames;
        this.excludeTypes = fields?.excludeTypes;
        this.excludeTags = fields?.excludeTags;
        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;
        this.transformStream = new TransformStream();
        this.writer = this.transformStream.writable.getWriter();
        this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
      }
      [Symbol.asyncIterator]() {
        return this.receiveStream;
      }
      async persistRun(_run) {
      }
      _includeRun(run) {
        if (run.id === this.rootId) return false;
        const runTags = run.tags ?? [];
        let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
        if (this.includeNames !== void 0) include = include || this.includeNames.includes(run.name);
        if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(run.run_type);
        if (this.includeTags !== void 0) include = include || runTags.find((tag) => this.includeTags?.includes(tag)) !== void 0;
        if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(run.name);
        if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(run.run_type);
        if (this.excludeTags !== void 0) include = include && runTags.every((tag) => !this.excludeTags?.includes(tag));
        return include;
      }
      async *tapOutputIterable(runId, output) {
        for await (const chunk of output) {
          if (runId !== this.rootId) {
            const key = this.keyMapByRunId[runId];
            if (key) await this.writer.write(new RunLogPatch({ ops: [{
              op: "add",
              path: `/logs/${key}/streamed_output/-`,
              value: chunk
            }] }));
          }
          yield chunk;
        }
      }
      async onRunCreate(run) {
        if (this.rootId === void 0) {
          this.rootId = run.id;
          await this.writer.write(new RunLogPatch({ ops: [{
            op: "replace",
            path: "",
            value: {
              id: run.id,
              name: run.name,
              type: run.run_type,
              streamed_output: [],
              final_output: void 0,
              logs: {}
            }
          }] }));
        }
        if (!this._includeRun(run)) return;
        if (this.counterMapByRunName[run.name] === void 0) this.counterMapByRunName[run.name] = 0;
        this.counterMapByRunName[run.name] += 1;
        const count = this.counterMapByRunName[run.name];
        this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;
        const logEntry = {
          id: run.id,
          name: run.name,
          type: run.run_type,
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          start_time: new Date(run.start_time).toISOString(),
          streamed_output: [],
          streamed_output_str: [],
          final_output: void 0,
          end_time: void 0
        };
        if (this._schemaFormat === "streaming_events") logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
        await this.writer.write(new RunLogPatch({ ops: [{
          op: "add",
          path: `/logs/${this.keyMapByRunId[run.id]}`,
          value: logEntry
        }] }));
      }
      async onRunUpdate(run) {
        try {
          const runName = this.keyMapByRunId[run.id];
          if (runName === void 0) return;
          const ops = [];
          if (this._schemaFormat === "streaming_events") ops.push({
            op: "replace",
            path: `/logs/${runName}/inputs`,
            value: await _getStandardizedInputs(run, this._schemaFormat)
          });
          ops.push({
            op: "add",
            path: `/logs/${runName}/final_output`,
            value: await _getStandardizedOutputs(run, this._schemaFormat)
          });
          if (run.end_time !== void 0) ops.push({
            op: "add",
            path: `/logs/${runName}/end_time`,
            value: new Date(run.end_time).toISOString()
          });
          const patch = new RunLogPatch({ ops });
          await this.writer.write(patch);
        } finally {
          if (run.id === this.rootId) {
            const patch = new RunLogPatch({ ops: [{
              op: "replace",
              path: "/final_output",
              value: await _getStandardizedOutputs(run, this._schemaFormat)
            }] });
            await this.writer.write(patch);
            if (this.autoClose) await this.writer.close();
          }
        }
      }
      async onLLMNewToken(run, token, kwargs) {
        const runName = this.keyMapByRunId[run.id];
        if (runName === void 0) return;
        const isChatModel2 = run.inputs.messages !== void 0;
        let streamedOutputValue;
        if (isChatModel2) if (isChatGenerationChunk(kwargs?.chunk)) streamedOutputValue = kwargs?.chunk;
        else streamedOutputValue = new AIMessageChunk({
          id: `run-${run.id}`,
          content: token
        });
        else streamedOutputValue = token;
        const patch = new RunLogPatch({ ops: [{
          op: "add",
          path: `/logs/${runName}/streamed_output_str/-`,
          value: token
        }, {
          op: "add",
          path: `/logs/${runName}/streamed_output/-`,
          value: streamedOutputValue
        }] });
        await this.writer.write(patch);
      }
    };
  }
});

// node_modules/@langchain/core/dist/outputs.js
var outputs_exports, RUN_KEY, GenerationChunk, ChatGenerationChunk;
var init_outputs = __esm({
  "node_modules/@langchain/core/dist/outputs.js"() {
    init_rolldown_runtime();
    outputs_exports = {};
    __export2(outputs_exports, {
      ChatGenerationChunk: () => ChatGenerationChunk,
      GenerationChunk: () => GenerationChunk,
      RUN_KEY: () => RUN_KEY
    });
    RUN_KEY = "__run";
    GenerationChunk = class GenerationChunk2 {
      text;
      generationInfo;
      constructor(fields) {
        this.text = fields.text;
        this.generationInfo = fields.generationInfo;
      }
      concat(chunk) {
        return new GenerationChunk2({
          text: this.text + chunk.text,
          generationInfo: {
            ...this.generationInfo,
            ...chunk.generationInfo
          }
        });
      }
    };
    ChatGenerationChunk = class ChatGenerationChunk2 extends GenerationChunk {
      message;
      constructor(fields) {
        super(fields);
        this.message = fields.message;
      }
      concat(chunk) {
        return new ChatGenerationChunk2({
          text: this.text + chunk.text,
          generationInfo: {
            ...this.generationInfo,
            ...chunk.generationInfo
          },
          message: this.message.concat(chunk.message)
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/is-network-error/index.js
function isNetworkError2(error40) {
  const isValid2 = error40 && isError2(error40) && error40.name === "TypeError" && typeof error40.message === "string";
  if (!isValid2) return false;
  const { message, stack } = error40;
  if (message === "Load failed") return stack === void 0 || "__sentry_captured__" in error40;
  if (message.startsWith("error sending request for url")) return true;
  return errorMessages2.has(message);
}
var objectToString2, isError2, errorMessages2;
var init_is_network_error2 = __esm({
  "node_modules/@langchain/core/dist/utils/is-network-error/index.js"() {
    objectToString2 = Object.prototype.toString;
    isError2 = (value) => objectToString2.call(value) === "[object Error]";
    errorMessages2 = /* @__PURE__ */ new Set([
      "network error",
      "Failed to fetch",
      "NetworkError when attempting to fetch resource.",
      "The Internet connection appears to be offline.",
      "Network request failed",
      "fetch failed",
      "terminated",
      " A network error occurred.",
      "Network connection lost"
    ]);
  }
});

// node_modules/@langchain/core/dist/utils/p-retry/index.js
function validateRetries2(retries) {
  if (typeof retries === "number") {
    if (retries < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(retries)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (retries !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function validateNumberOption2(name, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) return;
  if (typeof value !== "number" || Number.isNaN(value)) throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  if (!allowInfinity && !Number.isFinite(value)) throw new TypeError(`Expected \`${name}\` to be a finite number.`);
  if (value < min) throw new TypeError(`Expected \`${name}\` to be \u2265 ${min}.`);
}
function calculateDelay2(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime2(start, max) {
  if (!Number.isFinite(max)) return max;
  return max - (performance.now() - start);
}
async function onAttemptFailure2({ error: error40, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error40 instanceof Error ? error40 : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${error40}". You should only throw errors.`);
  if (normalizedError instanceof AbortError2) throw normalizedError.originalError;
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context2 = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context2);
  if (calculateRemainingTime2(startTime, maxRetryTime) <= 0) throw normalizedError;
  const consumeRetry = await options.shouldConsumeRetry(context2);
  const remainingTime = calculateRemainingTime2(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) throw normalizedError;
  if (normalizedError instanceof TypeError && !isNetworkError2(normalizedError)) {
    if (consumeRetry) throw normalizedError;
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context2)) throw normalizedError;
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay2(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0) await new Promise((resolve, reject) => {
    const onAbort = () => {
      clearTimeout(timeoutToken);
      options.signal?.removeEventListener("abort", onAbort);
      reject(options.signal.reason);
    };
    const timeoutToken = setTimeout(() => {
      options.signal?.removeEventListener("abort", onAbort);
      resolve();
    }, finalDelay);
    if (options.unref) timeoutToken.unref?.();
    options.signal?.addEventListener("abort", onAbort, { once: true });
  });
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry2(input, options = {}) {
  options = { ...options };
  validateRetries2(options.retries);
  if (Object.hasOwn(options, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1e3;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {
  };
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption2("factor", options.factor, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption2("minTimeout", options.minTimeout, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption2("maxTimeout", options.maxTimeout, {
    min: 0,
    allowInfinity: true
  });
  validateNumberOption2("maxRetryTime", options.maxRetryTime, {
    min: 0,
    allowInfinity: true
  });
  if (!(options.factor > 0)) options.factor = 1;
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error40) {
      if (await onAttemptFailure2({
        error: error40,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) retriesConsumed++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var AbortError2;
var init_p_retry2 = __esm({
  "node_modules/@langchain/core/dist/utils/p-retry/index.js"() {
    init_is_network_error2();
    AbortError2 = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/async_caller.js
var import_p_queue3, async_caller_exports, STATUS_NO_RETRY, defaultFailedAttemptHandler, AsyncCaller2;
var init_async_caller2 = __esm({
  "node_modules/@langchain/core/dist/utils/async_caller.js"() {
    init_rolldown_runtime();
    init_signal();
    init_p_retry2();
    import_p_queue3 = __toESM(require_dist(), 1);
    async_caller_exports = {};
    __export2(async_caller_exports, { AsyncCaller: () => AsyncCaller2 });
    STATUS_NO_RETRY = [
      400,
      401,
      402,
      403,
      404,
      405,
      406,
      407,
      409
    ];
    defaultFailedAttemptHandler = (error40) => {
      if (typeof error40 !== "object" || error40 === null) return;
      if ("message" in error40 && typeof error40.message === "string" && (error40.message.startsWith("Cancel") || error40.message.startsWith("AbortError")) || "name" in error40 && typeof error40.name === "string" && error40.name === "AbortError") throw error40;
      if ("code" in error40 && typeof error40.code === "string" && error40.code === "ECONNABORTED") throw error40;
      const responseStatus = "response" in error40 && typeof error40.response === "object" && error40.response !== null && "status" in error40.response && typeof error40.response.status === "number" ? error40.response.status : void 0;
      const directStatus = "status" in error40 && typeof error40.status === "number" ? error40.status : void 0;
      const status = responseStatus ?? directStatus;
      if (status && STATUS_NO_RETRY.includes(+status)) throw error40;
      const code = "error" in error40 && typeof error40.error === "object" && error40.error !== null && "code" in error40.error && typeof error40.error.code === "string" ? error40.error.code : void 0;
      if (code === "insufficient_quota") {
        const err = new Error("message" in error40 && typeof error40.message === "string" ? error40.message : "Insufficient quota");
        err.name = "InsufficientQuotaError";
        throw err;
      }
    };
    AsyncCaller2 = class {
      maxConcurrency;
      maxRetries;
      onFailedAttempt;
      queue;
      constructor(params) {
        this.maxConcurrency = params.maxConcurrency ?? Infinity;
        this.maxRetries = params.maxRetries ?? 6;
        this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
        const PQueue = "default" in import_p_queue3.default ? import_p_queue3.default.default : import_p_queue3.default;
        this.queue = new PQueue({ concurrency: this.maxConcurrency });
      }
      async call(callable, ...args) {
        return this.queue.add(() => pRetry2(() => callable(...args).catch((error40) => {
          if (error40 instanceof Error) throw error40;
          else throw new Error(error40);
        }), {
          onFailedAttempt: ({ error: error40 }) => this.onFailedAttempt?.(error40),
          retries: this.maxRetries,
          randomize: true
        }), { throwOnTimeout: true });
      }
      callWithOptions(options, callable, ...args) {
        if (options.signal) {
          let listener;
          return Promise.race([this.call(callable, ...args), new Promise((_, reject) => {
            listener = () => {
              reject(getAbortSignalError(options.signal));
            };
            options.signal?.addEventListener("abort", listener);
          })]).finally(() => {
            if (options.signal && listener) options.signal.removeEventListener("abort", listener);
          });
        }
        return this.call(callable, ...args);
      }
      fetch(...args) {
        return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
      }
    };
  }
});

// node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a3;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a3 = inst._zod).traits ?? (_a3.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a3;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER2, $brand, $ZodAsyncError, globalConfig;
var init_core2 = __esm({
  "node_modules/zod/v4/core/core.js"() {
    NEVER2 = Object.freeze({
      status: "aborted"
    });
    $brand = Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    globalConfig = {};
  }
});

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  const set2 = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set2) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path3) {
  if (!path3)
    return obj;
  return path3.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str2 = "";
  for (let i = 0; i < length; i++) {
    str2 += chars[Math.floor(Math.random() * chars.length)];
  }
  return str2;
}
function esc(str2) {
  return JSON.stringify(str2);
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path3, issues) {
  return issues.map((iss) => {
    var _a3;
    (_a3 = iss).path ?? (_a3.path = []);
    iss.path.unshift(path3);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var captureStackTrace, allowsEval, getParsedType2, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util2 = __esm({
  "node_modules/zod/v4/core/util.js"() {
    captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/zod/v4/core/errors.js
function flattenError(error40, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error40.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error40, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error41) => {
    for (const issue2 of error41.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error40);
  return fieldErrors;
}
function treeifyError(error40, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error41, path3 = []) => {
    var _a3, _b;
    for (const issue2 of error41.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path3, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a3 = curr.properties)[el] ?? (_a3[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error40);
  return result;
}
function toDotPath(path3) {
  const segs = [];
  for (const seg of path3) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error40) {
  const lines = [];
  const issues = [...error40.issues].sort((a, b) => a.path.length - b.path.length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors4 = __esm({
  "node_modules/zod/v4/core/errors.js"() {
    init_core2();
    init_util2();
    initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      Object.defineProperty(inst, "message", {
        get() {
          return JSON.stringify(def, jsonStringifyReplacer, 2);
        },
        enumerable: true
        // configurable: false,
      });
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  }
});

// node_modules/zod/v4/core/parse.js
var _parse, parse4, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync;
var init_parse4 = __esm({
  "node_modules/zod/v4/core/parse.js"() {
    init_core2();
    init_errors4();
    init_util2();
    _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    parse4 = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  }
});

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  _emoji: () => _emoji,
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid62,
  uuid7: () => uuid72,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex2 = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex2;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time4 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex2 = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid62, uuid72, email, html5Email, rfc5322Email, unicodeEmail, browserEmail, _emoji, ipv4, ipv6, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource, date, string, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase;
var init_regexes = __esm({
  "node_modules/zod/v4/core/regexes.js"() {
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid62 = /* @__PURE__ */ uuid(6);
    uuid72 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
    domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    string = (params) => {
      const regex2 = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex2}$`);
    };
    bigint = /^\d+n?$/;
    integer = /^\d+$/;
    number = /^-?\d+(?:\.\d+)?/i;
    boolean = /true|false/i;
    _null = /null/i;
    _undefined = /undefined/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
  }
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/zod/v4/core/checks.js"() {
    init_core2();
    init_regexes();
    init_util2();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a3;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a3 = inst._zod).onattach ?? (_a3.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a3;
        (_a3 = inst2._zod.bag).multipleOf ?? (_a3.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt2 = def.format?.includes("int");
      const origin = isInt2 ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt2)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt2) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a3, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a3 = inst._zod).check ?? (_a3.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/zod/v4/core/doc.js"() {
    Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm({
  "node_modules/zod/v4/core/versions.js"() {
    version = {
      major: 4,
      minor: 0,
      patch: 0
    };
  }
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final2, index2) {
  if (result.issues.length) {
    final2.issues.push(...prefixIssues(index2, result.issues));
  }
  final2.value[index2] = result.value;
}
function handleObjectResult(result, final2, key) {
  if (result.issues.length) {
    final2.issues.push(...prefixIssues(key, result.issues));
  }
  final2.value[key] = result.value;
}
function handleOptionalObjectResult(result, final2, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final2.value[key] = void 0;
      } else {
        final2.value[key] = result.value;
      }
    } else {
      final2.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final2.value[key] = void 0;
  } else {
    final2.value[key] = result.value;
  }
}
function handleUnionResults(results, final2, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final2.value = result.value;
      return final2;
    }
  }
  final2.issues.push({
    code: "invalid_union",
    input: final2.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final2;
}
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final2, index2) {
  if (result.issues.length) {
    final2.issues.push(...prefixIssues(index2, result.issues));
  }
  final2.value[index2] = result.value;
}
function handleMapResult(keyResult, valueResult, final2, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final2.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final2.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final2.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final2.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final2.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final2) {
  if (result.issues.length) {
    final2.issues.push(...result.issues);
  }
  final2.value.add(result.value);
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodUnion, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodReadonly, $ZodTemplateLiteral, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/zod/v4/core/schemas.js"() {
    init_checks();
    init_core2();
    init_doc();
    init_parse4();
    init_regexes();
    init_util2();
    init_versions();
    init_util2();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a3;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted2 = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted2) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted2)
                  isAborted2 = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted2)
                isAborted2 = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        inst._zod.run = (payload, ctx) => {
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          try {
            const r = safeParse(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const orig = payload.value;
          const url2 = new URL(orig);
          const href = url2.href;
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url2.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (!orig.endsWith("/") && href.endsWith("/")) {
            payload.value = href.slice(0, -1);
          } else {
            payload.value = href;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv4`;
      });
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const [address, prefix] = payload.value.split("/");
        try {
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT2(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const _normalized = cached(() => {
        const keys = Object.keys(def.shape);
        for (const k of keys) {
          if (!(def.shape[k] instanceof $ZodType)) {
            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
          }
        }
        const okeys = optionalKeys(def.shape);
        return {
          shape: def.shape,
          keys,
          keySet: new Set(keys),
          numKeys: keys.length,
          optionalKeys: new Set(okeys)
        };
      });
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {}`);
        for (const key of normalized.keys) {
          if (normalized.optionalKeys.has(key)) {
            const id = ids[key];
            doc.write(`const ${id} = ${parseStr(key)};`);
            const k = esc(key);
            doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
          } else {
            const id = ids[key];
            doc.write(`const ${id} = ${parseStr(key)};`);
            doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
            doc.write(`newResult[${esc(key)}] = ${id}.value`);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject4 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval2 = allowsEval;
      const fastEnabled = jit && allowsEval2.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
        } else {
          payload.value = {};
          const shape = value.shape;
          for (const key of value.keys) {
            const el = shape[key];
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
            if (r instanceof Promise) {
              proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
            } else if (isOptional) {
              handleOptionalObjectResult(r, payload, key, input);
            } else {
              handleObjectResult(r, payload, key);
            }
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        const unrecognized = [];
        const keySet = value.keySet;
        const _catchall = catchall._zod;
        const t = _catchall.def.type;
        for (const key of Object.keys(input)) {
          if (keySet.has(key))
            continue;
          if (t === "never") {
            unrecognized.push(key);
            continue;
          }
          const r = _catchall.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
          } else {
            handleObjectResult(r, payload, key);
          }
        }
        if (unrecognized.length) {
          payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst
          });
        }
        if (!proms.length)
          return payload;
        return Promise.all(proms).then(() => {
          return payload;
        });
      };
    });
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map2 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map2.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map2.set(v, o);
          }
        }
        return map2;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              input,
              inst,
              origin: "array",
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      inst._zod.values = new Set(values);
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const _out = def.transform(payload.value, payload);
        if (_ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def, ctx));
        }
        return handlePipeResult(left, def, ctx);
      };
    });
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (part instanceof $ZodType) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error;
var init_ar = __esm({
  "node_modules/zod/v4/locales/ar.js"() {
    init_util2();
    error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_az = __esm({
  "node_modules/zod/v4/locales/az.js"() {
    init_util2();
    error2 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_be = __esm({
  "node_modules/zod/v4/locales/be.js"() {
    init_util2();
    error3 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error4()
  };
}
var error4;
var init_ca = __esm({
  "node_modules/zod/v4/locales/ca.js"() {
    init_util2();
    error4 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType4(issue2.input)}`;
          // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue2.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error5()
  };
}
var error5;
var init_cs = __esm({
  "node_modules/zod/v4/locales/cs.js"() {
    init_util2();
    error5 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue2.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_de = __esm({
  "node_modules/zod/v4/locales/de.js"() {
    init_util2();
    error6 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue2.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/en.js
function en_default2() {
  return {
    localeError: error7()
  };
}
var parsedType, error7;
var init_en2 = __esm({
  "node_modules/zod/v4/locales/en.js"() {
    init_util2();
    parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error7 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue2.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue2.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error8()
  };
}
var parsedType2, error8;
var init_eo = __esm({
  "node_modules/zod/v4/locales/eo.js"() {
    init_util2();
    parsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error8 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType2(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue2.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue2.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error9()
  };
}
var error9;
var init_es = __esm({
  "node_modules/zod/v4/locales/es.js"() {
    init_util2();
    error9 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "arreglo";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${issue2.expected}, recibido ${parsedType4(issue2.input)}`;
          // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${issue2.origin}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error10()
  };
}
var error10;
var init_fa = __esm({
  "node_modules/zod/v4/locales/fa.js"() {
    init_util2();
    error10 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error11()
  };
}
var error11;
var init_fi = __esm({
  "node_modules/zod/v4/locales/fi.js"() {
    init_util2();
    error11 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_fr = __esm({
  "node_modules/zod/v4/locales/fr.js"() {
    init_util2();
    error12 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} re\xE7u`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fr_CA = __esm({
  "node_modules/zod/v4/locales/fr-CA.js"() {
    init_util2();
    error13 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_he = __esm({
  "node_modules/zod/v4/locales/he.js"() {
    init_util2();
    error14 = () => {
      const Sizable = {
        string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u05E7\u05DC\u05D8",
        email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
        url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
        emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
        date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
        time: "\u05D6\u05DE\u05DF ISO",
        duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
        ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
        ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
        cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
        cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
        base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
        base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
        json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
        e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
        jwt: "JWT",
        template_literal: "\u05E7\u05DC\u05D8"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType4(issue2.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element":
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_hu = __esm({
  "node_modules/zod/v4/locales/hu.js"() {
    init_util2();
    error15 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue2.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_id2 = __esm({
  "node_modules/zod/v4/locales/id.js"() {
    init_util2();
    error16 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue2.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_it = __esm({
  "node_modules/zod/v4/locales/it.js"() {
    init_util2();
    error17 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
          // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue2.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue2.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_ja = __esm({
  "node_modules/zod/v4/locales/ja.js"() {
    init_util2();
    error18 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType4(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return {
    localeError: error19()
  };
}
var error19;
var init_kh = __esm({
  "node_modules/zod/v4/locales/kh.js"() {
    init_util2();
    error19 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error20()
  };
}
var error20;
var init_ko = __esm({
  "node_modules/zod/v4/locales/ko.js"() {
    init_util2();
    error20 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType4(issue2.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_mk = __esm({
  "node_modules/zod/v4/locales/mk.js"() {
    init_util2();
    error21 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType4(issue2.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error22()
  };
}
var error22;
var init_ms = __esm({
  "node_modules/zod/v4/locales/ms.js"() {
    init_util2();
    error22 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue2.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error23()
  };
}
var error23;
var init_nl = __esm({
  "node_modules/zod/v4/locales/nl.js"() {
    init_util2();
    error23 = () => {
      const Sizable = {
        string: { unit: "tekens" },
        file: { unit: "bytes" },
        array: { unit: "elementen" },
        set: { unit: "elementen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
            return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
            }
            return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue2.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue2.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_no = __esm({
  "node_modules/zod/v4/locales/no.js"() {
    init_util2();
    error24 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue2.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error25()
  };
}
var error25;
var init_ota = __esm({
  "node_modules/zod/v4/locales/ota.js"() {
    init_util2();
    error25 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType4(issue2.input)}`;
          // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error26()
  };
}
var error26;
var init_ps = __esm({
  "node_modules/zod/v4/locales/ps.js"() {
    init_util2();
    error26 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType4(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_pl = __esm({
  "node_modules/zod/v4/locales/pl.js"() {
    init_util2();
    error27 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_pt = __esm({
  "node_modules/zod/v4/locales/pt.js"() {
    init_util2();
    error28 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue2.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_ru = __esm({
  "node_modules/zod/v4/locales/ru.js"() {
    init_util2();
    error29 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_sl = __esm({
  "node_modules/zod/v4/locales/sl.js"() {
    init_util2();
    error30 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue2.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_sv = __esm({
  "node_modules/zod/v4/locales/sv.js"() {
    init_util2();
    error31 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_ta = __esm({
  "node_modules/zod/v4/locales/ta.js"() {
    init_util2();
    error32 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_th = __esm({
  "node_modules/zod/v4/locales/th.js"() {
    init_util2();
    error33 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error34()
  };
}
var parsedType3, error34;
var init_tr = __esm({
  "node_modules/zod/v4/locales/tr.js"() {
    init_util2();
    parsedType3 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error34 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_ua = __esm({
  "node_modules/zod/v4/locales/ua.js"() {
    init_util2();
    error35 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType4(issue2.input)}`;
          // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_ur = __esm({
  "node_modules/zod/v4/locales/ur.js"() {
    init_util2();
    error36 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType4(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_vi = __esm({
  "node_modules/zod/v4/locales/vi.js"() {
    init_util2();
    error37 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_zh_CN = __esm({
  "node_modules/zod/v4/locales/zh-CN.js"() {
    init_util2();
    error38 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error39()
  };
}
var error39;
var init_zh_TW = __esm({
  "node_modules/zod/v4/locales/zh-TW.js"() {
    init_util2();
    error39 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType4 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType4(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default2,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/zod/v4/locales/index.js"() {
    init_ar();
    init_az();
    init_be();
    init_ca();
    init_cs();
    init_de();
    init_en2();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_id2();
    init_it();
    init_ja();
    init_kh();
    init_ko();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_ur();
    init_vi();
    init_zh_CN();
    init_zh_TW();
  }
});

// node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/zod/v4/core/registries.js"() {
    $output = Symbol("ZodOutput");
    $input = Symbol("ZodInput");
    $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
          if (this._idmap.has(meta.id)) {
            throw new Error(`ID ${meta.id} already exists in the registry`);
          }
          this._idmap.set(meta.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new Map();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
          this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          return { ...pm, ...this._map.get(schema) };
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    globalRegistry = /* @__PURE__ */ registry();
  }
});

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format2, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format: format2,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/zod/v4/core/api.js"() {
    init_checks();
    init_schemas();
    init_util2();
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/zod/v4/core/function.js
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
var $ZodFunction;
var init_function2 = __esm({
  "node_modules/zod/v4/core/function.js"() {
    init_api();
    init_parse4();
    init_schemas();
    init_schemas();
    $ZodFunction = class {
      constructor(def) {
        this._def = def;
        this.def = def;
      }
      implement(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = (...args) => {
          const parsedArgs = this._def.input ? parse4(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output = func(...parsedArgs);
          return this._def.output ? parse4(this._def.output, output, void 0, { callee: impl }) : output;
        };
        return impl;
      }
      implementAsync(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = async (...args) => {
          const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output = await func(...parsedArgs);
          return this._def.output ? parseAsync(this._def.output, output, void 0, { callee: impl }) : output;
        };
        return impl;
      }
      input(...args) {
        const F = this.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: this._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: this._def.output
        });
      }
      output(output) {
        const F = this.constructor;
        return new F({
          type: "function",
          input: this._def.input,
          output
        });
      }
    };
  }
});

// node_modules/zod/v4/core/to-json-schema.js
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
var JSONSchemaGenerator;
var init_to_json_schema = __esm({
  "node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries();
    init_util2();
    JSONSchemaGenerator = class {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a3;
        const def = schema._zod.def;
        const formatMap = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema, result);
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path
          };
          const parent = schema._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json2 = _json;
                json2.type = "string";
                const { minimum, maximum, format: format2, patterns, contentEncoding } = schema._zod.bag;
                if (typeof minimum === "number")
                  json2.minLength = minimum;
                if (typeof maximum === "number")
                  json2.maxLength = maximum;
                if (format2) {
                  json2.format = formatMap[format2] ?? format2;
                  if (json2.format === "")
                    delete json2.format;
                }
                if (contentEncoding)
                  json2.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json2.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex2) => ({
                        ...this.target === "draft-7" ? { type: "string" } : {},
                        pattern: regex2.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json2 = _json;
                const { minimum, maximum, format: format2, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                if (typeof format2 === "string" && format2.includes("int"))
                  json2.type = "integer";
                else
                  json2.type = "number";
                if (typeof exclusiveMinimum === "number")
                  json2.exclusiveMinimum = exclusiveMinimum;
                if (typeof minimum === "number") {
                  json2.minimum = minimum;
                  if (typeof exclusiveMinimum === "number") {
                    if (exclusiveMinimum >= minimum)
                      delete json2.minimum;
                    else
                      delete json2.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number")
                  json2.exclusiveMaximum = exclusiveMaximum;
                if (typeof maximum === "number") {
                  json2.maximum = maximum;
                  if (typeof exclusiveMaximum === "number") {
                    if (exclusiveMaximum <= maximum)
                      delete json2.maximum;
                    else
                      delete json2.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json2.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json2 = _json;
                json2.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json2 = _json;
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json2.minItems = minimum;
                if (typeof maximum === "number")
                  json2.maxItems = maximum;
                json2.type = "array";
                json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json2 = _json;
                json2.type = "object";
                json2.properties = {};
                const shape = def.shape;
                for (const key in shape) {
                  json2.properties[key] = this.process(shape[key], {
                    ...params,
                    path: [...params.path, "properties", key]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key) => {
                  const v = def.shape[key]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json2.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json2.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json2.additionalProperties = false;
                } else if (def.catchall) {
                  json2.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json2 = _json;
                json2.anyOf = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, "anyOf", i]
                }));
                break;
              }
              case "intersection": {
                const json2 = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json2.allOf = allOf;
                break;
              }
              case "tuple": {
                const json2 = _json;
                json2.type = "array";
                const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
                if (this.target === "draft-2020-12") {
                  json2.prefixItems = prefixItems;
                } else {
                  json2.items = prefixItems;
                }
                if (def.rest) {
                  const rest = this.process(def.rest, {
                    ...params,
                    path: [...params.path, "items"]
                  });
                  if (this.target === "draft-2020-12") {
                    json2.items = rest;
                  } else {
                    json2.additionalItems = rest;
                  }
                }
                if (def.rest) {
                  json2.items = this.process(def.rest, {
                    ...params,
                    path: [...params.path, "items"]
                  });
                }
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json2.minItems = minimum;
                if (typeof maximum === "number")
                  json2.maxItems = maximum;
                break;
              }
              case "record": {
                const json2 = _json;
                json2.type = "object";
                json2.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
                json2.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json2 = _json;
                const values = getEnumValues(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json2.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json2.type = "string";
                json2.enum = values;
                break;
              }
              case "literal": {
                const json2 = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json2.type = val === null ? "null" : typeof val;
                  json2.const = val;
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json2.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json2.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json2.type = "string";
                  if (vals.every((v) => v === null))
                    json2.type = "null";
                  json2.enum = vals;
                }
                break;
              }
              case "file": {
                const json2 = _json;
                const file2 = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema._zod.bag;
                if (minimum !== void 0)
                  file2.minLength = minimum;
                if (maximum !== void 0)
                  file2.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file2.contentMediaType = mime[0];
                    Object.assign(json2, file2);
                  } else {
                    json2.anyOf = mime.map((m) => {
                      const mFile = { ...file2, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json2, file2);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                _json.anyOf = [inner, { type: "null" }];
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json2 = _json;
                json2.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json2 = _json;
                const pattern = schema._zod.pattern;
                if (!pattern)
                  throw new Error("Pattern not found in template literal");
                json2.type = "string";
                json2.pattern = pattern.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              // passthrough types
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta = this.metadataRegistry.get(schema);
        if (meta)
          Object.assign(result.schema, meta);
        if (this.io === "input" && isTransforming(schema)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a3 = result.schema).default ?? (_a3.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key in schema2) {
            delete schema2[key];
          }
          schema2.$ref = ref;
        };
        if (params.cycles === "throw") {
          for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry[0])?.id;
            if (schema !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry[0])?.id;
          if (id) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema2 = seen.def ?? seen.schema;
          const _cached = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref = seen.ref;
          seen.ref = null;
          if (ref) {
            flattenRef(ref, params2);
            const refSchema = this.seen.get(ref).schema;
            if (refSchema.$ref && params2.target === "draft-7") {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema2,
              path: seen.path ?? []
            });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
  }
});

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/zod/v4/core/index.js
var core_exports3 = {};
__export(core_exports3, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT2,
  locales: () => locales_exports,
  parse: () => parse4,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});
var init_core3 = __esm({
  "node_modules/zod/v4/core/index.js"() {
    init_core2();
    init_parse4();
    init_errors4();
    init_schemas();
    init_checks();
    init_versions();
    init_util2();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_function2();
    init_api();
    init_to_json_schema();
    init_json_schema();
  }
});

// node_modules/@langchain/core/dist/utils/types/zod.js
function isZodSchemaV4(schema) {
  if (typeof schema !== "object" || schema === null) return false;
  const obj = schema;
  if (!("_zod" in obj)) return false;
  const zod = obj._zod;
  return typeof zod === "object" && zod !== null && "def" in zod;
}
function isZodSchemaV3(schema) {
  if (typeof schema !== "object" || schema === null) return false;
  const obj = schema;
  if (!("_def" in obj) || "_zod" in obj) return false;
  const def = obj._def;
  return typeof def === "object" && def != null && "typeName" in def;
}
function isZodSchema(schema) {
  if (isZodSchemaV4(schema)) console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.");
  return isZodSchemaV3(schema);
}
function isInteropZodSchema(input) {
  if (!input) return false;
  if (typeof input !== "object") return false;
  if (Array.isArray(input)) return false;
  if (isZodSchemaV4(input) || isZodSchemaV3(input)) return true;
  return false;
}
function isZodLiteralV3(obj) {
  if (typeof obj === "object" && obj !== null && "_def" in obj && typeof obj._def === "object" && obj._def !== null && "typeName" in obj._def && obj._def.typeName === "ZodLiteral") return true;
  return false;
}
function isZodLiteralV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "literal") return true;
  return false;
}
function isInteropZodLiteral(obj) {
  if (isZodLiteralV3(obj)) return true;
  if (isZodLiteralV4(obj)) return true;
  return false;
}
async function interopSafeParseAsync(schema, input) {
  if (isZodSchemaV4(schema)) try {
    const data = await parseAsync(schema, input);
    return {
      success: true,
      data
    };
  } catch (error40) {
    return {
      success: false,
      error: error40
    };
  }
  if (isZodSchemaV3(schema)) return await schema.safeParseAsync(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
async function interopParseAsync(schema, input) {
  if (isZodSchemaV4(schema)) return await parseAsync(schema, input);
  if (isZodSchemaV3(schema)) return await schema.parseAsync(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopSafeParse(schema, input) {
  if (isZodSchemaV4(schema)) try {
    const data = parse4(schema, input);
    return {
      success: true,
      data
    };
  } catch (error40) {
    return {
      success: false,
      error: error40
    };
  }
  if (isZodSchemaV3(schema)) return schema.safeParse(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopParse(schema, input) {
  if (isZodSchemaV4(schema)) return parse4(schema, input);
  if (isZodSchemaV3(schema)) return schema.parse(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function getSchemaDescription(schema) {
  if (isZodSchemaV4(schema)) return globalRegistry.get(schema)?.description;
  if (isZodSchemaV3(schema)) return schema.description;
  if ("description" in schema && typeof schema.description === "string") return schema.description;
  return void 0;
}
function isShapelessZodSchema(schema) {
  if (!isInteropZodSchema(schema)) return false;
  if (isZodSchemaV3(schema)) {
    const def = schema._def;
    if (def.typeName === "ZodObject") {
      const obj = schema;
      return !obj.shape || Object.keys(obj.shape).length === 0;
    }
    if (def.typeName === "ZodRecord") return true;
  }
  if (isZodSchemaV4(schema)) {
    const def = schema._zod.def;
    if (def.type === "object") {
      const obj = schema;
      return !obj.shape || Object.keys(obj.shape).length === 0;
    }
    if (def.type === "record") return true;
  }
  if (typeof schema === "object" && schema !== null && !("shape" in schema)) return true;
  return false;
}
function isSimpleStringZodSchema(schema) {
  if (!isInteropZodSchema(schema)) return false;
  if (isZodSchemaV3(schema)) {
    const def = schema._def;
    return def.typeName === "ZodString";
  }
  if (isZodSchemaV4(schema)) {
    const def = schema._zod.def;
    return def.type === "string";
  }
  return false;
}
function isZodObjectV3(obj) {
  if (typeof obj === "object" && obj !== null && "_def" in obj && typeof obj._def === "object" && obj._def !== null && "typeName" in obj._def && obj._def.typeName === "ZodObject") return true;
  return false;
}
function isZodObjectV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "object") return true;
  return false;
}
function isZodArrayV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "array") return true;
  return false;
}
function isZodOptionalV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "optional") return true;
  return false;
}
function isZodNullableV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "nullable") return true;
  return false;
}
function isInteropZodObject(obj) {
  if (isZodObjectV3(obj)) return true;
  if (isZodObjectV4(obj)) return true;
  return false;
}
function getInteropZodObjectShape(schema) {
  if (isZodSchemaV3(schema)) return schema.shape;
  if (isZodSchemaV4(schema)) return schema._zod.def.shape;
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function extendInteropZodObject(schema, extension) {
  if (isZodSchemaV3(schema)) return schema.extend(extension);
  if (isZodSchemaV4(schema)) return util_exports.extend(schema, extension);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function interopZodObjectPartial(schema) {
  if (isZodSchemaV3(schema)) return schema.partial();
  if (isZodSchemaV4(schema)) return util_exports.partial($ZodOptional, schema, void 0);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function interopZodObjectStrict(schema, recursive = false) {
  if (isZodSchemaV3(schema)) return schema.strict();
  if (isZodObjectV4(schema)) {
    const outputShape = schema._zod.def.shape;
    if (recursive) for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
      if (isZodObjectV4(keySchema)) {
        const outputSchema = interopZodObjectStrict(keySchema, recursive);
        outputShape[key] = outputSchema;
      } else if (isZodArrayV4(keySchema)) {
        let elementSchema = keySchema._zod.def.element;
        if (isZodObjectV4(elementSchema)) elementSchema = interopZodObjectStrict(elementSchema, recursive);
        outputShape[key] = clone(keySchema, {
          ...keySchema._zod.def,
          element: elementSchema
        });
      } else outputShape[key] = keySchema;
      const meta$1 = globalRegistry.get(keySchema);
      if (meta$1) globalRegistry.add(outputShape[key], meta$1);
    }
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape,
      catchall: _never($ZodNever)
    });
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(modifiedSchema, meta);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function interopZodObjectPassthrough(schema, recursive = false) {
  if (isZodObjectV3(schema)) return schema.passthrough();
  if (isZodObjectV4(schema)) {
    const outputShape = schema._zod.def.shape;
    if (recursive) for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
      if (isZodObjectV4(keySchema)) {
        const outputSchema = interopZodObjectPassthrough(keySchema, recursive);
        outputShape[key] = outputSchema;
      } else if (isZodArrayV4(keySchema)) {
        let elementSchema = keySchema._zod.def.element;
        if (isZodObjectV4(elementSchema)) elementSchema = interopZodObjectPassthrough(elementSchema, recursive);
        outputShape[key] = clone(keySchema, {
          ...keySchema._zod.def,
          element: elementSchema
        });
      } else outputShape[key] = keySchema;
      const meta$1 = globalRegistry.get(keySchema);
      if (meta$1) globalRegistry.add(outputShape[key], meta$1);
    }
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape,
      catchall: _unknown($ZodUnknown)
    });
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(modifiedSchema, meta);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function getInteropZodDefaultGetter(schema) {
  if (isZodSchemaV3(schema)) try {
    const defaultValue = schema.parse(void 0);
    return () => defaultValue;
  } catch {
    return void 0;
  }
  if (isZodSchemaV4(schema)) try {
    const defaultValue = parse4(schema, void 0);
    return () => defaultValue;
  } catch {
    return void 0;
  }
  return void 0;
}
function isZodTransformV3(schema) {
  return isZodSchemaV3(schema) && "typeName" in schema._def && schema._def.typeName === "ZodEffects";
}
function isZodTransformV4(schema) {
  return isZodSchemaV4(schema) && schema._zod.def.type === "pipe";
}
function interopZodTransformInputSchemaImpl(schema, recursive, cache2) {
  const cached2 = cache2.get(schema);
  if (cached2 !== void 0) return cached2;
  if (isZodSchemaV3(schema)) {
    if (isZodTransformV3(schema)) return interopZodTransformInputSchemaImpl(schema._def.schema, recursive, cache2);
    return schema;
  }
  if (isZodSchemaV4(schema)) {
    let outputSchema = schema;
    if (isZodTransformV4(schema)) outputSchema = interopZodTransformInputSchemaImpl(schema._zod.def.in, recursive, cache2);
    if (recursive) {
      if (isZodObjectV4(outputSchema)) {
        const outputShape = {};
        for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) outputShape[key] = interopZodTransformInputSchemaImpl(keySchema, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          shape: outputShape
        });
      } else if (isZodArrayV4(outputSchema)) {
        const elementSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.element, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          element: elementSchema
        });
      } else if (isZodOptionalV4(outputSchema)) {
        const innerSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.innerType, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          innerType: innerSchema
        });
      } else if (isZodNullableV4(outputSchema)) {
        const innerSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.innerType, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          innerType: innerSchema
        });
      }
    }
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(outputSchema, meta);
    cache2.set(schema, outputSchema);
    return outputSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopZodTransformInputSchema(schema, recursive = false) {
  const cache2 = /* @__PURE__ */ new WeakMap();
  return interopZodTransformInputSchemaImpl(schema, recursive, cache2);
}
function interopZodObjectMakeFieldsOptional(schema, predicate) {
  if (isZodSchemaV3(schema)) {
    const shape = getInteropZodObjectShape(schema);
    const modifiedShape = {};
    for (const [key, value] of Object.entries(shape)) if (predicate(key, value)) modifiedShape[key] = value.optional();
    else modifiedShape[key] = value;
    return schema.extend(modifiedShape);
  }
  if (isZodSchemaV4(schema)) {
    const shape = getInteropZodObjectShape(schema);
    const outputShape = { ...schema._zod.def.shape };
    for (const [key, value] of Object.entries(shape)) if (predicate(key, value)) outputShape[key] = new $ZodOptional({
      type: "optional",
      innerType: value
    });
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape
    });
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(modifiedSchema, meta);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function isInteropZodError(e) {
  return e instanceof Error && (e.constructor.name === "ZodError" || e.constructor.name === "$ZodError");
}
var init_zod2 = __esm({
  "node_modules/@langchain/core/dist/utils/types/zod.js"() {
    init_core3();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/Options.js
var ignoreOverride, defaultOptions3, getDefaultOptions;
var init_Options = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/Options.js"() {
    ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    defaultOptions3 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref",
      openAiAnyTypeName: "OpenAiAnyType"
    };
    getDefaultOptions = (options) => typeof options === "string" ? {
      ...defaultOptions3,
      name: options
    } : {
      ...defaultOptions3,
      ...options
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/Refs.js
var getRefs;
var init_Refs = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/Refs.js"() {
    init_Options();
    getRefs = (options) => {
      const _options = getDefaultOptions(options);
      const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
      ] : _options.basePath;
      return {
        ..._options,
        flags: { hasReferencedOpenAiAnyType: false },
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [def._def, {
          def: def._def,
          path: [
            ..._options.basePath,
            _options.definitionPath,
            name
          ],
          jsonSchema: void 0
        }]))
      };
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/getRelativePath.js
var getRelativePath;
var init_getRelativePath = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/getRelativePath.js"() {
    getRelativePath = (pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) if (pathA[i] !== pathB[i]) break;
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") return {};
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return { $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/") };
}
var init_any = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/any.js"() {
    init_getRelativePath();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages) return;
  if (errorMessage) res.errorMessage = {
    ...res.errorMessage,
    [key]: errorMessage
  };
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
var init_errorMessages = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/errorMessages.js"() {
  }
});

// node_modules/zod/v3/index.js
var init_v3 = __esm({
  "node_modules/zod/v3/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/array.js
function parseArrayDef(def, refs) {
  const res = { type: "array" };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) res.items = parseDef(def.type._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  if (def.minLength) setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  if (def.maxLength) setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
var init_array = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/array.js"() {
    init_errorMessages();
    init_parseDef();
    init_v3();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check2 of def.checks) switch (check2.kind) {
    case "min":
      if (refs.target === "jsonSchema7") if (check2.inclusive) setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
      else setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
      else {
        if (!check2.inclusive) res.exclusiveMinimum = true;
        setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
      }
      break;
    case "max":
      if (refs.target === "jsonSchema7") if (check2.inclusive) setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
      else setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
      else {
        if (!check2.inclusive) res.exclusiveMaximum = true;
        setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
      }
      break;
    case "multipleOf":
      setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
      break;
  }
  return res;
}
var init_bigint = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/bigint.js"() {
    init_errorMessages();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/boolean.js
function parseBooleanDef() {
  return { type: "boolean" };
}
var init_boolean = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/boolean.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var init_branded = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/branded.js"() {
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/catch.js
var parseCatchDef;
var init_catch = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/catch.js"() {
    init_parseDef();
    parseCatchDef = (def, refs) => {
      return parseDef(def.innerType._def, refs);
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) return { anyOf: strategy.map((item) => parseDateDef(def, refs, item)) };
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser;
var init_date = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/date.js"() {
    init_errorMessages();
    integerDateParser = (def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      if (refs.target === "openApi3") return res;
      for (const check2 of def.checks) switch (check2.kind) {
        case "min":
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          break;
      }
      return res;
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
var init_default = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/default.js"() {
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}
var init_effects = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/effects.js"() {
    init_any();
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var init_enum = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/enum.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/intersection.js
function parseIntersectionDef(def, refs) {
  const allOf = [parseDef(def.left._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "0"
    ]
  }), parseDef(def.right._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "1"
    ]
  })].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) unevaluatedProperties = void 0;
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else unevaluatedProperties = void 0;
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
var isJsonSchema7AllOfType;
var init_intersection = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/intersection.js"() {
    init_parseDef();
    isJsonSchema7AllOfType = (type) => {
      if ("type" in type && type.type === "string") return false;
      return "allOf" in type;
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType4 = typeof def.value;
  if (parsedType4 !== "bigint" && parsedType4 !== "number" && parsedType4 !== "boolean" && parsedType4 !== "string") return { type: Array.isArray(def.value) ? "array" : "object" };
  if (refs.target === "openApi3") return {
    type: parsedType4 === "bigint" ? "integer" : parsedType4,
    enum: [def.value]
  };
  return {
    type: parsedType4 === "bigint" ? "integer" : parsedType4,
    const: def.value
  };
}
var init_literal = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/literal.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/string.js
function parseStringDef(def, refs) {
  const res = { type: "string" };
  if (def.checks) for (const check2 of def.checks) switch (check2.kind) {
    case "min":
      setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
      break;
    case "max":
      setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
      break;
    case "email":
      switch (refs.emailStrategy) {
        case "format:email":
          addFormat(res, "email", check2.message, refs);
          break;
        case "format:idn-email":
          addFormat(res, "idn-email", check2.message, refs);
          break;
        case "pattern:zod":
          addPattern(res, zodPatterns.email, check2.message, refs);
          break;
      }
      break;
    case "url":
      addFormat(res, "uri", check2.message, refs);
      break;
    case "uuid":
      addFormat(res, "uuid", check2.message, refs);
      break;
    case "regex":
      addPattern(res, check2.regex, check2.message, refs);
      break;
    case "cuid":
      addPattern(res, zodPatterns.cuid, check2.message, refs);
      break;
    case "cuid2":
      addPattern(res, zodPatterns.cuid2, check2.message, refs);
      break;
    case "startsWith":
      addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);
      break;
    case "endsWith":
      addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);
      break;
    case "datetime":
      addFormat(res, "date-time", check2.message, refs);
      break;
    case "date":
      addFormat(res, "date", check2.message, refs);
      break;
    case "time":
      addFormat(res, "time", check2.message, refs);
      break;
    case "duration":
      addFormat(res, "duration", check2.message, refs);
      break;
    case "length":
      setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
      setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
      break;
    case "includes":
      addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);
      break;
    case "ip":
      if (check2.version !== "v6") addFormat(res, "ipv4", check2.message, refs);
      if (check2.version !== "v4") addFormat(res, "ipv6", check2.message, refs);
      break;
    case "base64url":
      addPattern(res, zodPatterns.base64url, check2.message, refs);
      break;
    case "jwt":
      addPattern(res, zodPatterns.jwt, check2.message, refs);
      break;
    case "cidr":
      if (check2.version !== "v6") addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
      if (check2.version !== "v4") addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
      break;
    case "emoji":
      addPattern(res, zodPatterns.emoji(), check2.message, refs);
      break;
    case "ulid":
      addPattern(res, zodPatterns.ulid, check2.message, refs);
      break;
    case "base64":
      switch (refs.base64Strategy) {
        case "format:binary":
          addFormat(res, "binary", check2.message, refs);
          break;
        case "contentEncoding:base64":
          setResponseValueAndErrors(res, "contentEncoding", "base64", check2.message, refs);
          break;
        case "pattern:zod":
          addPattern(res, zodPatterns.base64, check2.message, refs);
          break;
      }
      break;
    case "nanoid":
      addPattern(res, zodPatterns.nanoid, check2.message, refs);
      break;
    case "toLowerCase":
    case "toUpperCase":
    case "trim":
      break;
    default:
      /* @__PURE__ */ ((_) => {
      })(check2);
  }
  return res;
}
function escapeLiteralCheckValue(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
}
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) result += "\\";
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) schema.anyOf = [];
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && { errorMessage: { format: schema.errorMessage.format } }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) delete schema.errorMessage;
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else setResponseValueAndErrors(schema, "format", value, message, refs);
}
function addPattern(schema, regex2, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) schema.allOf = [];
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && { errorMessage: { pattern: schema.errorMessage.pattern } }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) delete schema.errorMessage;
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex2, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex2, refs), message, refs);
}
function stringifyRegExpWithFlags(regex2, refs) {
  if (!refs.applyRegexFlags || !regex2.flags) return regex2.source;
  const flags = {
    i: regex2.flags.includes("i"),
    m: regex2.flags.includes("m"),
    s: regex2.flags.includes("s")
  };
  const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else pattern += `${source[i]}${source[i].toUpperCase()}`;
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") isEscaped = true;
    else if (inCharGroup && source[i] === "]") inCharGroup = false;
    else if (!inCharGroup && source[i] === "[") inCharGroup = true;
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex2.source;
  }
  return pattern;
}
var emojiRegex2, zodPatterns, ALPHA_NUMERIC;
var init_string = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/string.js"() {
    init_errorMessages();
    emojiRegex2 = void 0;
    zodPatterns = {
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      emoji: () => {
        if (emojiRegex2 === void 0) emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        return emojiRegex2;
      },
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    ALPHA_NUMERIC = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) return {
    type: "object",
    required: def.keyType._def.values,
    properties: def.keyType._def.values.reduce((acc, key) => ({
      ...acc,
      [key]: parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "properties",
          key
        ]
      }) ?? parseAnyDef(refs)
    }), {}),
    additionalProperties: refs.rejectedAdditionalProperties
  };
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") return schema;
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) return {
    ...schema,
    propertyNames: { enum: def.keyType._def.values }
  };
  else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
var init_record = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/record.js"() {
    init_any();
    init_branded();
    init_string();
    init_parseDef();
    init_v3();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") return parseRecordDef(def, refs);
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
var init_map = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/map.js"() {
    init_any();
    init_record();
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
var init_nativeEnum = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nativeEnum.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : { not: parseAnyDef({
    ...refs,
    currentPath: [...refs.currentPath, "not"]
  }) };
}
var init_never = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/never.js"() {
    init_any();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : { type: "null" };
}
var init_null = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/null.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/union.js
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3") return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types$1, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types$1.includes(type) ? [...types$1, type] : types$1;
    }, []);
    return { type: types.length > 1 ? types : types[0] };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null) return [...acc, "null"];
          return acc;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) return {
    type: "string",
    enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x$1) => !acc.includes(x$1))], [])
  };
  return asAnyOf(def, refs);
}
var primitiveMappings, asAnyOf;
var init_union = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/union.js"() {
    init_parseDef();
    primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "anyOf",
          `${i}`
        ]
      })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nullable.js
function parseNullableDef(def, refs) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") return {
      type: primitiveMappings[def.innerType._def.typeName],
      nullable: true
    };
    return { type: [primitiveMappings[def.innerType._def.typeName], "null"] };
  }
  if (refs.target === "openApi3") {
    const base$1 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base$1 && "$ref" in base$1) return {
      allOf: [base$1],
      nullable: true
    };
    return base$1 && {
      ...base$1,
      nullable: true
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      "0"
    ]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
var init_nullable = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nullable.js"() {
    init_union();
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/number.js
function parseNumberDef(def, refs) {
  const res = { type: "number" };
  if (!def.checks) return res;
  for (const check2 of def.checks) switch (check2.kind) {
    case "int":
      res.type = "integer";
      addErrorMessage(res, "type", check2.message, refs);
      break;
    case "min":
      if (refs.target === "jsonSchema7") if (check2.inclusive) setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
      else setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
      else {
        if (!check2.inclusive) res.exclusiveMinimum = true;
        setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
      }
      break;
    case "max":
      if (refs.target === "jsonSchema7") if (check2.inclusive) setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
      else setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
      else {
        if (!check2.inclusive) res.exclusiveMaximum = true;
        setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
      }
      break;
    case "multipleOf":
      setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
      break;
  }
  return res;
}
var init_number = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/number.js"() {
    init_errorMessages();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName2 in shape) {
    let propDef = shape[propName2];
    if (propDef === void 0 || propDef._def === void 0) continue;
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") propDef = propDef._def.innerType;
      if (!propDef.isNullable()) propDef = propDef.nullable();
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "properties",
        propName2
      ],
      propertyPath: [
        ...refs.currentPath,
        "properties",
        propName2
      ]
    });
    if (parsedDef === void 0) continue;
    result.properties[propName2] = parsedDef;
    if (!propOptional) required2.push(propName2);
  }
  if (required2.length) result.required = required2;
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) result.additionalProperties = additionalProperties;
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") return parseDef(def.catchall._def, {
    ...refs,
    currentPath: [...refs.currentPath, "additionalProperties"]
  });
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var init_object = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/object.js"() {
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/optional.js
var parseOptionalDef;
var init_optional = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/optional.js"() {
    init_any();
    init_parseDef();
    parseOptionalDef = (def, refs) => {
      if (refs.currentPath.toString() === refs.propertyPath?.toString()) return parseDef(def.innerType._def, refs);
      const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "anyOf",
          "1"
        ]
      });
      return innerSchema ? { anyOf: [{ not: parseAnyDef(refs) }, innerSchema] } : parseAnyDef(refs);
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/pipeline.js
var parsePipelineDef;
var init_pipeline = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/pipeline.js"() {
    init_parseDef();
    parsePipelineDef = (def, refs) => {
      if (refs.pipeStrategy === "input") return parseDef(def.in._def, refs);
      else if (refs.pipeStrategy === "output") return parseDef(def.out._def, refs);
      const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          "0"
        ]
      });
      const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          a ? "1" : "0"
        ]
      });
      return { allOf: [a, b].filter((x) => x !== void 0) };
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
var init_promise = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/promise.js"() {
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  if (def.maxSize) setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  return schema;
}
var init_set = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/set.js"() {
    init_errorMessages();
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) return {
    type: "array",
    minItems: def.items.length,
    items: def.items.map((x, i) => parseDef(x._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items",
        `${i}`
      ]
    })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
    additionalItems: parseDef(def.rest._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalItems"]
    })
  };
  else return {
    type: "array",
    minItems: def.items.length,
    maxItems: def.items.length,
    items: def.items.map((x, i) => parseDef(x._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items",
        `${i}`
      ]
    })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
  };
}
var init_tuple = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/tuple.js"() {
    init_parseDef();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/undefined.js
function parseUndefinedDef(refs) {
  return { not: parseAnyDef(refs) };
}
var init_undefined = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/undefined.js"() {
    init_any();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}
var init_unknown = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/unknown.js"() {
    init_any();
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/readonly.js
var parseReadonlyDef;
var init_readonly = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/readonly.js"() {
    init_parseDef();
    parseReadonlyDef = (def, refs) => {
      return parseDef(def.innerType._def, refs);
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/selectParser.js
var selectParser;
var init_selectParser = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/selectParser.js"() {
    init_any();
    init_array();
    init_bigint();
    init_boolean();
    init_branded();
    init_catch();
    init_date();
    init_default();
    init_effects();
    init_enum();
    init_intersection();
    init_literal();
    init_string();
    init_record();
    init_map();
    init_nativeEnum();
    init_never();
    init_null();
    init_union();
    init_nullable();
    init_number();
    init_object();
    init_optional();
    init_pipeline();
    init_promise();
    init_set();
    init_tuple();
    init_undefined();
    init_unknown();
    init_readonly();
    init_v3();
    selectParser = (def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef(def, refs);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef(refs);
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef(refs);
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef(def, refs);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return () => def.getter()._def;
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef(refs);
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef(refs);
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef(refs);
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) return overrideResult;
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) return seenSchema;
  }
  const newItem = {
    def,
    path: refs.currentPath,
    jsonSchema: void 0
  };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) addMeta(def, refs, jsonSchema);
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref, addMeta;
var init_parseDef = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/parseDef.js"() {
    init_Options();
    init_getRelativePath();
    init_any();
    init_selectParser();
    get$ref = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen":
          if (item.path.length < refs.currentPath.length && item.path.every((value, index2) => refs.currentPath[index2] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return parseAnyDef(refs);
          }
          return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
      }
    };
    addMeta = (def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) jsonSchema.markdownDescription = def.description;
      }
      return jsonSchema;
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/zodToJsonSchema.js
var zodToJsonSchema;
var init_zodToJsonSchema = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/zodToJsonSchema.js"() {
    init_Refs();
    init_any();
    init_parseDef();
    zodToJsonSchema = (schema, options) => {
      const refs = getRefs(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name$1, schema$1]) => ({
        ...acc,
        [name$1]: parseDef(schema$1._def, {
          ...refs,
          currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name$1
          ]
        }, true) ?? parseAnyDef(refs)
      }), {}) : void 0;
      const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
      const main = parseDef(schema._def, name === void 0 ? refs : {
        ...refs,
        currentPath: [
          ...refs.basePath,
          refs.definitionPath,
          name
        ]
      }, false) ?? parseAnyDef(refs);
      const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title !== void 0) main.title = title;
      if (refs.flags.hasReferencedOpenAiAnyType) {
        if (!definitions) definitions = {};
        if (!definitions[refs.openAiAnyTypeName]) definitions[refs.openAiAnyTypeName] = {
          type: [
            "string",
            "number",
            "integer",
            "boolean",
            "array",
            "null"
          ],
          items: { $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/") }
        };
      }
      const combined = name === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name]: main
        }
      };
      if (refs.target === "jsonSchema7") combined.$schema = "http://json-schema.org/draft-07/schema#";
      else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
      return combined;
    };
  }
});

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/index.js
var init_zod_to_json_schema = __esm({
  "node_modules/@langchain/core/dist/utils/zod-to-json-schema/index.js"() {
    init_Options();
    init_Refs();
    init_errorMessages();
    init_getRelativePath();
    init_any();
    init_array();
    init_bigint();
    init_boolean();
    init_branded();
    init_catch();
    init_date();
    init_default();
    init_effects();
    init_enum();
    init_intersection();
    init_literal();
    init_string();
    init_record();
    init_map();
    init_nativeEnum();
    init_never();
    init_null();
    init_union();
    init_nullable();
    init_number();
    init_object();
    init_optional();
    init_pipeline();
    init_promise();
    init_set();
    init_tuple();
    init_undefined();
    init_unknown();
    init_readonly();
    init_selectParser();
    init_parseDef();
    init_zodToJsonSchema();
  }
});

// node_modules/@cfworker/json-schema/dist/esm/deep-compare-strict.js
function deepCompareStrict(a, b) {
  const typeofa = typeof a;
  if (typeofa !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    const length = a.length;
    if (length !== b.length) {
      return false;
    }
    for (let i = 0; i < length; i++) {
      if (!deepCompareStrict(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (typeofa === "object") {
    if (!a || !b) {
      return a === b;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const length = aKeys.length;
    if (length !== bKeys.length) {
      return false;
    }
    for (const k of aKeys) {
      if (!deepCompareStrict(a[k], b[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}
var init_deep_compare_strict = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/deep-compare-strict.js"() {
  }
});

// node_modules/@cfworker/json-schema/dist/esm/pointer.js
function encodePointer(p) {
  return encodeURI(escapePointer(p));
}
function escapePointer(p) {
  return p.replace(/~/g, "~0").replace(/\//g, "~1");
}
var init_pointer = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/pointer.js"() {
  }
});

// node_modules/@cfworker/json-schema/dist/esm/dereference.js
function dereference(schema, lookup2 = /* @__PURE__ */ Object.create(null), baseURI = initialBaseURI, basePointer = "") {
  if (schema && typeof schema === "object" && !Array.isArray(schema)) {
    const id = schema.$id || schema.id;
    if (id) {
      const url2 = new URL(id, baseURI.href);
      if (url2.hash.length > 1) {
        lookup2[url2.href] = schema;
      } else {
        url2.hash = "";
        if (basePointer === "") {
          baseURI = url2;
        } else {
          dereference(schema, lookup2, baseURI);
        }
      }
    }
  } else if (schema !== true && schema !== false) {
    return lookup2;
  }
  const schemaURI = baseURI.href + (basePointer ? "#" + basePointer : "");
  if (lookup2[schemaURI] !== void 0) {
    throw new Error(`Duplicate schema URI "${schemaURI}".`);
  }
  lookup2[schemaURI] = schema;
  if (schema === true || schema === false) {
    return lookup2;
  }
  if (schema.__absolute_uri__ === void 0) {
    Object.defineProperty(schema, "__absolute_uri__", {
      enumerable: false,
      value: schemaURI
    });
  }
  if (schema.$ref && schema.__absolute_ref__ === void 0) {
    const url2 = new URL(schema.$ref, baseURI.href);
    url2.hash = url2.hash;
    Object.defineProperty(schema, "__absolute_ref__", {
      enumerable: false,
      value: url2.href
    });
  }
  if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === void 0) {
    const url2 = new URL(schema.$recursiveRef, baseURI.href);
    url2.hash = url2.hash;
    Object.defineProperty(schema, "__absolute_recursive_ref__", {
      enumerable: false,
      value: url2.href
    });
  }
  if (schema.$anchor) {
    const url2 = new URL("#" + schema.$anchor, baseURI.href);
    lookup2[url2.href] = schema;
  }
  for (let key in schema) {
    if (ignoredKeyword[key]) {
      continue;
    }
    const keyBase = `${basePointer}/${encodePointer(key)}`;
    const subSchema = schema[key];
    if (Array.isArray(subSchema)) {
      if (schemaArrayKeyword[key]) {
        const length = subSchema.length;
        for (let i = 0; i < length; i++) {
          dereference(subSchema[i], lookup2, baseURI, `${keyBase}/${i}`);
        }
      }
    } else if (schemaMapKeyword[key]) {
      for (let subKey in subSchema) {
        dereference(subSchema[subKey], lookup2, baseURI, `${keyBase}/${encodePointer(subKey)}`);
      }
    } else {
      dereference(subSchema, lookup2, baseURI, keyBase);
    }
  }
  return lookup2;
}
var schemaArrayKeyword, schemaMapKeyword, ignoredKeyword, initialBaseURI;
var init_dereference = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/dereference.js"() {
    init_pointer();
    schemaArrayKeyword = {
      prefixItems: true,
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    schemaMapKeyword = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependentSchemas: true
    };
    ignoredKeyword = {
      id: true,
      $id: true,
      $ref: true,
      $schema: true,
      $anchor: true,
      $vocabulary: true,
      $comment: true,
      default: true,
      enum: true,
      const: true,
      required: true,
      type: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    initialBaseURI = typeof self !== "undefined" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
  }
});

// node_modules/@cfworker/json-schema/dist/esm/format.js
function bind(r) {
  return r.test.bind(r);
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date2(str2) {
  const matches = str2.match(DATE);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time2(full, str2) {
  const matches = str2.match(TIME);
  if (!matches)
    return false;
  const hour = +matches[1];
  const minute = +matches[2];
  const second = +matches[3];
  const timeZone = !!matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
function date_time(str2) {
  const dateTime = str2.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date2(dateTime[0]) && time2(true, dateTime[1]);
}
function uri(str2) {
  return NOT_URI_FRAGMENT.test(str2) && URI_PATTERN.test(str2);
}
function regex(str2) {
  if (Z_ANCHOR.test(str2))
    return false;
  try {
    new RegExp(str2, "u");
    return true;
  } catch (e) {
    return false;
  }
}
var DATE, DAYS, TIME, HOSTNAME, URIREF, URITEMPLATE, URL_, UUID, JSON_POINTER, JSON_POINTER_URI_FRAGMENT, RELATIVE_JSON_POINTER, EMAIL, IPV4, IPV6, DURATION, format, DATE_TIME_SEPARATOR, NOT_URI_FRAGMENT, URI_PATTERN, Z_ANCHOR;
var init_format2 = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/format.js"() {
    DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
    UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    EMAIL = (input) => {
      if (input[0] === '"')
        return false;
      const [name, host, ...rest] = input.split("@");
      if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
        return false;
      if (name[0] === "." || name.endsWith(".") || name.includes(".."))
        return false;
      if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
        return false;
      return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
    };
    IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
    IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
    DURATION = (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input));
    format = {
      date: date2,
      time: time2.bind(void 0, false),
      "date-time": date_time,
      duration: DURATION,
      uri,
      "uri-reference": bind(URIREF),
      "uri-template": bind(URITEMPLATE),
      url: bind(URL_),
      email: EMAIL,
      hostname: bind(HOSTNAME),
      ipv4: bind(IPV4),
      ipv6: bind(IPV6),
      regex,
      uuid: bind(UUID),
      "json-pointer": bind(JSON_POINTER),
      "json-pointer-uri-fragment": bind(JSON_POINTER_URI_FRAGMENT),
      "relative-json-pointer": bind(RELATIVE_JSON_POINTER)
    };
    DATE_TIME_SEPARATOR = /t|\s/i;
    NOT_URI_FRAGMENT = /\/|:/;
    URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    Z_ANCHOR = /[^\\]\\Z/;
  }
});

// node_modules/@cfworker/json-schema/dist/esm/types.js
var OutputFormat;
var init_types3 = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/types.js"() {
    (function(OutputFormat2) {
      OutputFormat2[OutputFormat2["Flag"] = 1] = "Flag";
      OutputFormat2[OutputFormat2["Basic"] = 2] = "Basic";
      OutputFormat2[OutputFormat2["Detailed"] = 4] = "Detailed";
    })(OutputFormat || (OutputFormat = {}));
  }
});

// node_modules/@cfworker/json-schema/dist/esm/ucs2-length.js
function ucs2length(s) {
  let result = 0;
  let length = s.length;
  let index2 = 0;
  let charCode;
  while (index2 < length) {
    result++;
    charCode = s.charCodeAt(index2++);
    if (charCode >= 55296 && charCode <= 56319 && index2 < length) {
      charCode = s.charCodeAt(index2);
      if ((charCode & 64512) == 56320) {
        index2++;
      }
    }
  }
  return result;
}
var init_ucs2_length = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/ucs2-length.js"() {
  }
});

// node_modules/@cfworker/json-schema/dist/esm/validate.js
function validate5(instance, schema, draft = "2019-09", lookup2 = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = "#", schemaLocation = "#", evaluated = /* @__PURE__ */ Object.create(null)) {
  if (schema === true) {
    return { valid: true, errors: [] };
  }
  if (schema === false) {
    return {
      valid: false,
      errors: [
        {
          instanceLocation,
          keyword: "false",
          keywordLocation: instanceLocation,
          error: "False boolean schema."
        }
      ]
    };
  }
  const rawInstanceType = typeof instance;
  let instanceType;
  switch (rawInstanceType) {
    case "boolean":
    case "number":
    case "string":
      instanceType = rawInstanceType;
      break;
    case "object":
      if (instance === null) {
        instanceType = "null";
      } else if (Array.isArray(instance)) {
        instanceType = "array";
      } else {
        instanceType = "object";
      }
      break;
    default:
      throw new Error(`Instances of "${rawInstanceType}" type are not supported.`);
  }
  const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;
  const errors = [];
  if ($recursiveAnchor === true && recursiveAnchor === null) {
    recursiveAnchor = schema;
  }
  if ($recursiveRef === "#") {
    const refSchema = recursiveAnchor === null ? lookup2[__absolute_recursive_ref__] : recursiveAnchor;
    const keywordLocation = `${schemaLocation}/$recursiveRef`;
    const result = validate5(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup2, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors.push({
        instanceLocation,
        keyword: "$recursiveRef",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
  }
  if ($ref !== void 0) {
    const uri2 = __absolute_ref__ || $ref;
    const refSchema = lookup2[uri2];
    if (refSchema === void 0) {
      let message = `Unresolved $ref "${$ref}".`;
      if (__absolute_ref__ && __absolute_ref__ !== $ref) {
        message += `  Absolute URI "${__absolute_ref__}".`;
      }
      message += `
Known schemas:
- ${Object.keys(lookup2).join("\n- ")}`;
      throw new Error(message);
    }
    const keywordLocation = `${schemaLocation}/$ref`;
    const result = validate5(instance, refSchema, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors.push({
        instanceLocation,
        keyword: "$ref",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
    if (draft === "4" || draft === "7") {
      return { valid: errors.length === 0, errors };
    }
  }
  if (Array.isArray($type)) {
    let length = $type.length;
    let valid = false;
    for (let i = 0; i < length; i++) {
      if (instanceType === $type[i] || $type[i] === "integer" && instanceType === "number" && instance % 1 === 0 && instance === instance) {
        valid = true;
        break;
      }
    }
    if (!valid) {
      errors.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type.join('", "')}".`
      });
    }
  } else if ($type === "integer") {
    if (instanceType !== "number" || instance % 1 || instance !== instance) {
      errors.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
      });
    }
  } else if ($type !== void 0 && instanceType !== $type) {
    errors.push({
      instanceLocation,
      keyword: "type",
      keywordLocation: `${schemaLocation}/type`,
      error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
    });
  }
  if ($const !== void 0) {
    if (instanceType === "object" || instanceType === "array") {
      if (!deepCompareStrict(instance, $const)) {
        errors.push({
          instanceLocation,
          keyword: "const",
          keywordLocation: `${schemaLocation}/const`,
          error: `Instance does not match ${JSON.stringify($const)}.`
        });
      }
    } else if (instance !== $const) {
      errors.push({
        instanceLocation,
        keyword: "const",
        keywordLocation: `${schemaLocation}/const`,
        error: `Instance does not match ${JSON.stringify($const)}.`
      });
    }
  }
  if ($enum !== void 0) {
    if (instanceType === "object" || instanceType === "array") {
      if (!$enum.some((value) => deepCompareStrict(instance, value))) {
        errors.push({
          instanceLocation,
          keyword: "enum",
          keywordLocation: `${schemaLocation}/enum`,
          error: `Instance does not match any of ${JSON.stringify($enum)}.`
        });
      }
    } else if (!$enum.some((value) => instance === value)) {
      errors.push({
        instanceLocation,
        keyword: "enum",
        keywordLocation: `${schemaLocation}/enum`,
        error: `Instance does not match any of ${JSON.stringify($enum)}.`
      });
    }
  }
  if ($not !== void 0) {
    const keywordLocation = `${schemaLocation}/not`;
    const result = validate5(instance, $not, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);
    if (result.valid) {
      errors.push({
        instanceLocation,
        keyword: "not",
        keywordLocation,
        error: 'Instance matched "not" schema.'
      });
    }
  }
  let subEvaluateds = [];
  if ($anyOf !== void 0) {
    const keywordLocation = `${schemaLocation}/anyOf`;
    const errorsLength = errors.length;
    let anyValid = false;
    for (let i = 0; i < $anyOf.length; i++) {
      const subSchema = $anyOf[i];
      const subEvaluated = Object.create(evaluated);
      const result = validate5(instance, subSchema, draft, lookup2, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors.push(...result.errors);
      anyValid = anyValid || result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (anyValid) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "anyOf",
        keywordLocation,
        error: "Instance does not match any subschemas."
      });
    }
  }
  if ($allOf !== void 0) {
    const keywordLocation = `${schemaLocation}/allOf`;
    const errorsLength = errors.length;
    let allValid = true;
    for (let i = 0; i < $allOf.length; i++) {
      const subSchema = $allOf[i];
      const subEvaluated = Object.create(evaluated);
      const result = validate5(instance, subSchema, draft, lookup2, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors.push(...result.errors);
      allValid = allValid && result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (allValid) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "allOf",
        keywordLocation,
        error: `Instance does not match every subschema.`
      });
    }
  }
  if ($oneOf !== void 0) {
    const keywordLocation = `${schemaLocation}/oneOf`;
    const errorsLength = errors.length;
    const matches = $oneOf.filter((subSchema, i) => {
      const subEvaluated = Object.create(evaluated);
      const result = validate5(instance, subSchema, draft, lookup2, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors.push(...result.errors);
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
      return result.valid;
    }).length;
    if (matches === 1) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "oneOf",
        keywordLocation,
        error: `Instance does not match exactly one subschema (${matches} matches).`
      });
    }
  }
  if (instanceType === "object" || instanceType === "array") {
    Object.assign(evaluated, ...subEvaluateds);
  }
  if ($if !== void 0) {
    const keywordLocation = `${schemaLocation}/if`;
    const conditionResult = validate5(instance, $if, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;
    if (conditionResult) {
      if ($then !== void 0) {
        const thenResult = validate5(instance, $then, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);
        if (!thenResult.valid) {
          errors.push({
            instanceLocation,
            keyword: "if",
            keywordLocation,
            error: `Instance does not match "then" schema.`
          }, ...thenResult.errors);
        }
      }
    } else if ($else !== void 0) {
      const elseResult = validate5(instance, $else, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);
      if (!elseResult.valid) {
        errors.push({
          instanceLocation,
          keyword: "if",
          keywordLocation,
          error: `Instance does not match "else" schema.`
        }, ...elseResult.errors);
      }
    }
  }
  if (instanceType === "object") {
    if ($required !== void 0) {
      for (const key of $required) {
        if (!(key in instance)) {
          errors.push({
            instanceLocation,
            keyword: "required",
            keywordLocation: `${schemaLocation}/required`,
            error: `Instance does not have required property "${key}".`
          });
        }
      }
    }
    const keys = Object.keys(instance);
    if ($minProperties !== void 0 && keys.length < $minProperties) {
      errors.push({
        instanceLocation,
        keyword: "minProperties",
        keywordLocation: `${schemaLocation}/minProperties`,
        error: `Instance does not have at least ${$minProperties} properties.`
      });
    }
    if ($maxProperties !== void 0 && keys.length > $maxProperties) {
      errors.push({
        instanceLocation,
        keyword: "maxProperties",
        keywordLocation: `${schemaLocation}/maxProperties`,
        error: `Instance does not have at least ${$maxProperties} properties.`
      });
    }
    if ($propertyNames !== void 0) {
      const keywordLocation = `${schemaLocation}/propertyNames`;
      for (const key in instance) {
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate5(key, $propertyNames, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "propertyNames",
            keywordLocation,
            error: `Property name "${key}" does not match schema.`
          }, ...result.errors);
        }
      }
    }
    if ($dependentRequired !== void 0) {
      const keywordLocation = `${schemaLocation}/dependantRequired`;
      for (const key in $dependentRequired) {
        if (key in instance) {
          const required2 = $dependentRequired[key];
          for (const dependantKey of required2) {
            if (!(dependantKey in instance)) {
              errors.push({
                instanceLocation,
                keyword: "dependentRequired",
                keywordLocation,
                error: `Instance has "${key}" but does not have "${dependantKey}".`
              });
            }
          }
        }
      }
    }
    if ($dependentSchemas !== void 0) {
      for (const key in $dependentSchemas) {
        const keywordLocation = `${schemaLocation}/dependentSchemas`;
        if (key in instance) {
          const result = validate5(instance, $dependentSchemas[key], draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);
          if (!result.valid) {
            errors.push({
              instanceLocation,
              keyword: "dependentSchemas",
              keywordLocation,
              error: `Instance has "${key}" but does not match dependant schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($dependencies !== void 0) {
      const keywordLocation = `${schemaLocation}/dependencies`;
      for (const key in $dependencies) {
        if (key in instance) {
          const propsOrSchema = $dependencies[key];
          if (Array.isArray(propsOrSchema)) {
            for (const dependantKey of propsOrSchema) {
              if (!(dependantKey in instance)) {
                errors.push({
                  instanceLocation,
                  keyword: "dependencies",
                  keywordLocation,
                  error: `Instance has "${key}" but does not have "${dependantKey}".`
                });
              }
            }
          } else {
            const result = validate5(instance, propsOrSchema, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);
            if (!result.valid) {
              errors.push({
                instanceLocation,
                keyword: "dependencies",
                keywordLocation,
                error: `Instance has "${key}" but does not match dependant schema.`
              }, ...result.errors);
            }
          }
        }
      }
    }
    const thisEvaluated = /* @__PURE__ */ Object.create(null);
    let stop = false;
    if ($properties !== void 0) {
      const keywordLocation = `${schemaLocation}/properties`;
      for (const key in $properties) {
        if (!(key in instance)) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate5(instance[key], $properties[key], draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);
        if (result.valid) {
          evaluated[key] = thisEvaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "properties",
            keywordLocation,
            error: `Property "${key}" does not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if (!stop && $patternProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/patternProperties`;
      for (const pattern in $patternProperties) {
        const regex2 = new RegExp(pattern, "u");
        const subSchema = $patternProperties[pattern];
        for (const key in instance) {
          if (!regex2.test(key)) {
            continue;
          }
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate5(instance[key], subSchema, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);
          if (result.valid) {
            evaluated[key] = thisEvaluated[key] = true;
          } else {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "patternProperties",
              keywordLocation,
              error: `Property "${key}" matches pattern "${pattern}" but does not match associated schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if (!stop && $additionalProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/additionalProperties`;
      for (const key in instance) {
        if (thisEvaluated[key]) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate5(instance[key], $additionalProperties, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (result.valid) {
          evaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "additionalProperties",
            keywordLocation,
            error: `Property "${key}" does not match additional properties schema.`
          }, ...result.errors);
        }
      }
    } else if (!stop && $unevaluatedProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;
      for (const key in instance) {
        if (!evaluated[key]) {
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate5(instance[key], $unevaluatedProperties, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
          if (result.valid) {
            evaluated[key] = true;
          } else {
            errors.push({
              instanceLocation,
              keyword: "unevaluatedProperties",
              keywordLocation,
              error: `Property "${key}" does not match unevaluated properties schema.`
            }, ...result.errors);
          }
        }
      }
    }
  } else if (instanceType === "array") {
    if ($maxItems !== void 0 && instance.length > $maxItems) {
      errors.push({
        instanceLocation,
        keyword: "maxItems",
        keywordLocation: `${schemaLocation}/maxItems`,
        error: `Array has too many items (${instance.length} > ${$maxItems}).`
      });
    }
    if ($minItems !== void 0 && instance.length < $minItems) {
      errors.push({
        instanceLocation,
        keyword: "minItems",
        keywordLocation: `${schemaLocation}/minItems`,
        error: `Array has too few items (${instance.length} < ${$minItems}).`
      });
    }
    const length = instance.length;
    let i = 0;
    let stop = false;
    if ($prefixItems !== void 0) {
      const keywordLocation = `${schemaLocation}/prefixItems`;
      const length2 = Math.min($prefixItems.length, length);
      for (; i < length2; i++) {
        const result = validate5(instance[i], $prefixItems[i], draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
        evaluated[i] = true;
        if (!result.valid) {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "prefixItems",
            keywordLocation,
            error: `Items did not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if ($items !== void 0) {
      const keywordLocation = `${schemaLocation}/items`;
      if (Array.isArray($items)) {
        const length2 = Math.min($items.length, length);
        for (; i < length2; i++) {
          const result = validate5(instance[i], $items[i], draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      } else {
        for (; i < length; i++) {
          const result = validate5(instance[i], $items, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      }
      if (!stop && $additionalItems !== void 0) {
        const keywordLocation2 = `${schemaLocation}/additionalItems`;
        for (; i < length; i++) {
          const result = validate5(instance[i], $additionalItems, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation2);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "additionalItems",
              keywordLocation: keywordLocation2,
              error: `Items did not match additional items schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($contains !== void 0) {
      if (length === 0 && $minContains === void 0) {
        errors.push({
          instanceLocation,
          keyword: "contains",
          keywordLocation: `${schemaLocation}/contains`,
          error: `Array is empty. It must contain at least one item matching the schema.`
        });
      } else if ($minContains !== void 0 && length < $minContains) {
        errors.push({
          instanceLocation,
          keyword: "minContains",
          keywordLocation: `${schemaLocation}/minContains`,
          error: `Array has less items (${length}) than minContains (${$minContains}).`
        });
      } else {
        const keywordLocation = `${schemaLocation}/contains`;
        const errorsLength = errors.length;
        let contained = 0;
        for (let j = 0; j < length; j++) {
          const result = validate5(instance[j], $contains, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);
          if (result.valid) {
            evaluated[j] = true;
            contained++;
          } else {
            errors.push(...result.errors);
          }
        }
        if (contained >= ($minContains || 0)) {
          errors.length = errorsLength;
        }
        if ($minContains === void 0 && $maxContains === void 0 && contained === 0) {
          errors.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "contains",
            keywordLocation,
            error: `Array does not contain item matching schema.`
          });
        } else if ($minContains !== void 0 && contained < $minContains) {
          errors.push({
            instanceLocation,
            keyword: "minContains",
            keywordLocation: `${schemaLocation}/minContains`,
            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`
          });
        } else if ($maxContains !== void 0 && contained > $maxContains) {
          errors.push({
            instanceLocation,
            keyword: "maxContains",
            keywordLocation: `${schemaLocation}/maxContains`,
            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`
          });
        }
      }
    }
    if (!stop && $unevaluatedItems !== void 0) {
      const keywordLocation = `${schemaLocation}/unevaluatedItems`;
      for (i; i < length; i++) {
        if (evaluated[i]) {
          continue;
        }
        const result = validate5(instance[i], $unevaluatedItems, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
        evaluated[i] = true;
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "unevaluatedItems",
            keywordLocation,
            error: `Items did not match unevaluated items schema.`
          }, ...result.errors);
        }
      }
    }
    if ($uniqueItems) {
      for (let j = 0; j < length; j++) {
        const a = instance[j];
        const ao = typeof a === "object" && a !== null;
        for (let k = 0; k < length; k++) {
          if (j === k) {
            continue;
          }
          const b = instance[k];
          const bo = typeof b === "object" && b !== null;
          if (a === b || ao && bo && deepCompareStrict(a, b)) {
            errors.push({
              instanceLocation,
              keyword: "uniqueItems",
              keywordLocation: `${schemaLocation}/uniqueItems`,
              error: `Duplicate items at indexes ${j} and ${k}.`
            });
            j = Number.MAX_SAFE_INTEGER;
            k = Number.MAX_SAFE_INTEGER;
          }
        }
      }
    }
  } else if (instanceType === "number") {
    if (draft === "4") {
      if ($minimum !== void 0 && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {
        errors.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$exclusiveMinimum ? "or equal to " : ""} ${$minimum}.`
        });
      }
      if ($maximum !== void 0 && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {
        errors.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$exclusiveMaximum ? "or equal to " : ""} ${$maximum}.`
        });
      }
    } else {
      if ($minimum !== void 0 && instance < $minimum) {
        errors.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$minimum}.`
        });
      }
      if ($maximum !== void 0 && instance > $maximum) {
        errors.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$maximum}.`
        });
      }
      if ($exclusiveMinimum !== void 0 && instance <= $exclusiveMinimum) {
        errors.push({
          instanceLocation,
          keyword: "exclusiveMinimum",
          keywordLocation: `${schemaLocation}/exclusiveMinimum`,
          error: `${instance} is less than ${$exclusiveMinimum}.`
        });
      }
      if ($exclusiveMaximum !== void 0 && instance >= $exclusiveMaximum) {
        errors.push({
          instanceLocation,
          keyword: "exclusiveMaximum",
          keywordLocation: `${schemaLocation}/exclusiveMaximum`,
          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`
        });
      }
    }
    if ($multipleOf !== void 0) {
      const remainder = instance % $multipleOf;
      if (Math.abs(0 - remainder) >= 11920929e-14 && Math.abs($multipleOf - remainder) >= 11920929e-14) {
        errors.push({
          instanceLocation,
          keyword: "multipleOf",
          keywordLocation: `${schemaLocation}/multipleOf`,
          error: `${instance} is not a multiple of ${$multipleOf}.`
        });
      }
    }
  } else if (instanceType === "string") {
    const length = $minLength === void 0 && $maxLength === void 0 ? 0 : ucs2length(instance);
    if ($minLength !== void 0 && length < $minLength) {
      errors.push({
        instanceLocation,
        keyword: "minLength",
        keywordLocation: `${schemaLocation}/minLength`,
        error: `String is too short (${length} < ${$minLength}).`
      });
    }
    if ($maxLength !== void 0 && length > $maxLength) {
      errors.push({
        instanceLocation,
        keyword: "maxLength",
        keywordLocation: `${schemaLocation}/maxLength`,
        error: `String is too long (${length} > ${$maxLength}).`
      });
    }
    if ($pattern !== void 0 && !new RegExp($pattern, "u").test(instance)) {
      errors.push({
        instanceLocation,
        keyword: "pattern",
        keywordLocation: `${schemaLocation}/pattern`,
        error: `String does not match pattern.`
      });
    }
    if ($format !== void 0 && format[$format] && !format[$format](instance)) {
      errors.push({
        instanceLocation,
        keyword: "format",
        keywordLocation: `${schemaLocation}/format`,
        error: `String does not match format "${$format}".`
      });
    }
  }
  return { valid: errors.length === 0, errors };
}
var init_validate4 = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/validate.js"() {
    init_deep_compare_strict();
    init_dereference();
    init_format2();
    init_pointer();
    init_ucs2_length();
  }
});

// node_modules/@cfworker/json-schema/dist/esm/validator.js
var Validator;
var init_validator = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/validator.js"() {
    init_dereference();
    init_validate4();
    Validator = class {
      schema;
      draft;
      shortCircuit;
      lookup;
      constructor(schema, draft = "2019-09", shortCircuit = true) {
        this.schema = schema;
        this.draft = draft;
        this.shortCircuit = shortCircuit;
        this.lookup = dereference(schema);
      }
      validate(instance) {
        return validate5(instance, this.schema, this.draft, this.lookup, this.shortCircuit);
      }
      addSchema(schema, id) {
        if (id) {
          schema = { ...schema, $id: id };
        }
        dereference(schema, this.lookup);
      }
    };
  }
});

// node_modules/@cfworker/json-schema/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@cfworker/json-schema/dist/esm/index.js"() {
    init_deep_compare_strict();
    init_dereference();
    init_format2();
    init_pointer();
    init_types3();
    init_ucs2_length();
    init_validate4();
    init_validator();
  }
});

// node_modules/@langchain/core/dist/utils/json_schema.js
function toJsonSchema(schema, params) {
  if (isZodSchemaV4(schema)) {
    const inputSchema7 = interopZodTransformInputSchema(schema, true);
    if (isZodObjectV4(inputSchema7)) {
      const strictSchema = interopZodObjectStrict(inputSchema7, true);
      return toJSONSchema(strictSchema, params);
    } else return toJSONSchema(schema, params);
  }
  if (isZodSchemaV3(schema)) return zodToJsonSchema(schema);
  return schema;
}
function validatesOnlyStrings(schema) {
  if (!schema || typeof schema !== "object" || Object.keys(schema).length === 0 || Array.isArray(schema)) return false;
  if ("type" in schema) {
    if (typeof schema.type === "string") return schema.type === "string";
    if (Array.isArray(schema.type)) return schema.type.every((t) => t === "string");
    return false;
  }
  if ("enum" in schema) return Array.isArray(schema.enum) && schema.enum.length > 0 && schema.enum.every((val) => typeof val === "string");
  if ("const" in schema) return typeof schema.const === "string";
  if ("allOf" in schema && Array.isArray(schema.allOf)) return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));
  if ("anyOf" in schema && Array.isArray(schema.anyOf) || "oneOf" in schema && Array.isArray(schema.oneOf)) {
    const subschemas = "anyOf" in schema ? schema.anyOf : schema.oneOf;
    return subschemas.length > 0 && subschemas.every((subschema) => validatesOnlyStrings(subschema));
  }
  if ("not" in schema) return false;
  if ("$ref" in schema && typeof schema.$ref === "string") {
    const ref = schema.$ref;
    const resolved = dereference(schema);
    if (resolved[ref]) return validatesOnlyStrings(resolved[ref]);
    return false;
  }
  return false;
}
var json_schema_exports2;
var init_json_schema2 = __esm({
  "node_modules/@langchain/core/dist/utils/json_schema.js"() {
    init_rolldown_runtime();
    init_zod2();
    init_zodToJsonSchema();
    init_zod_to_json_schema();
    init_core3();
    init_esm();
    json_schema_exports2 = {};
    __export2(json_schema_exports2, {
      Validator: () => Validator,
      deepCompareStrict: () => deepCompareStrict,
      toJsonSchema: () => toJsonSchema,
      validatesOnlyStrings: () => validatesOnlyStrings
    });
  }
});

// node_modules/@langchain/core/dist/runnables/utils.js
function isRunnableInterface(thing) {
  return thing ? thing.lc_runnable : false;
}
var _RootEventFilter, toBase64Url;
var init_utils4 = __esm({
  "node_modules/@langchain/core/dist/runnables/utils.js"() {
    _RootEventFilter = class {
      includeNames;
      includeTypes;
      includeTags;
      excludeNames;
      excludeTypes;
      excludeTags;
      constructor(fields) {
        this.includeNames = fields.includeNames;
        this.includeTypes = fields.includeTypes;
        this.includeTags = fields.includeTags;
        this.excludeNames = fields.excludeNames;
        this.excludeTypes = fields.excludeTypes;
        this.excludeTags = fields.excludeTags;
      }
      includeEvent(event, rootType) {
        let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
        const eventTags = event.tags ?? [];
        if (this.includeNames !== void 0) include = include || this.includeNames.includes(event.name);
        if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(rootType);
        if (this.includeTags !== void 0) include = include || eventTags.some((tag) => this.includeTags?.includes(tag));
        if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(event.name);
        if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(rootType);
        if (this.excludeTags !== void 0) include = include && eventTags.every((tag) => !this.excludeTags?.includes(tag));
        return include;
      }
    };
    toBase64Url = (str2) => {
      const encoded = btoa(str2);
      return encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    };
  }
});

// node_modules/@langchain/core/dist/runnables/graph_mermaid.js
function _escapeNodeLabel(nodeLabel) {
  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
}
function _generateMermaidGraphStyles(nodeColors) {
  let styles2 = "";
  for (const [className, color2] of Object.entries(nodeColors)) styles2 += `	classDef ${className} ${color2};
`;
  return styles2;
}
function drawMermaid(nodes, edges, config2) {
  const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config2 ?? {};
  let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : "graph TD;\n";
  if (withStyles) {
    const defaultClassLabel = "default";
    const formatDict = { [defaultClassLabel]: "{0}({1})" };
    if (firstNode !== void 0) formatDict[firstNode] = "{0}([{1}]):::first";
    if (lastNode !== void 0) formatDict[lastNode] = "{0}([{1}]):::last";
    for (const [key, node] of Object.entries(nodes)) {
      const nodeName = node.name.split(":").pop() ?? "";
      const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
      let finalLabel = label;
      if (Object.keys(node.metadata ?? {}).length) finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {}).map(([k, v]) => `${k} = ${v}`).join("\n")}</em></small>`;
      const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
      mermaidGraph += `	${nodeLabel}
`;
    }
  }
  const edgeGroups = {};
  for (const edge of edges) {
    const srcParts = edge.source.split(":");
    const tgtParts = edge.target.split(":");
    const commonPrefix = srcParts.filter((src, i) => src === tgtParts[i]).join(":");
    if (!edgeGroups[commonPrefix]) edgeGroups[commonPrefix] = [];
    edgeGroups[commonPrefix].push(edge);
  }
  const seenSubgraphs = /* @__PURE__ */ new Set();
  function sortPrefixesByDepth(prefixes) {
    return [...prefixes].sort((a, b) => {
      return a.split(":").length - b.split(":").length;
    });
  }
  function addSubgraph(edges$1, prefix) {
    const selfLoop = edges$1.length === 1 && edges$1[0].source === edges$1[0].target;
    if (prefix && !selfLoop) {
      const subgraph = prefix.split(":").pop();
      if (seenSubgraphs.has(prefix)) throw new Error(`Found duplicate subgraph '${subgraph}' at '${prefix} -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      seenSubgraphs.add(prefix);
      mermaidGraph += `	subgraph ${subgraph}
`;
    }
    const nestedPrefixes = sortPrefixesByDepth(Object.keys(edgeGroups).filter((nestedPrefix) => nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix && nestedPrefix.split(":").length === prefix.split(":").length + 1));
    for (const nestedPrefix of nestedPrefixes) addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
    for (const edge of edges$1) {
      const { source, target, data, conditional } = edge;
      let edgeLabel = "";
      if (data !== void 0) {
        let edgeData = data;
        const words = edgeData.split(" ");
        if (words.length > wrapLabelNWords) edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words.slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
        edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
      } else edgeLabel = conditional ? " -.-> " : " --> ";
      mermaidGraph += `	${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};
`;
    }
    if (prefix && !selfLoop) mermaidGraph += "	end\n";
  }
  addSubgraph(edgeGroups[""] ?? [], "");
  for (const prefix in edgeGroups) if (!prefix.includes(":") && prefix !== "") addSubgraph(edgeGroups[prefix], prefix);
  if (withStyles) mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});
  return mermaidGraph;
}
async function drawMermaidImage(mermaidSyntax, config2) {
  let backgroundColor = config2?.backgroundColor ?? "white";
  const imageType = config2?.imageType ?? "png";
  const mermaidSyntaxEncoded = toBase64Url(mermaidSyntax);
  if (backgroundColor !== void 0) {
    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
    if (!hexColorPattern.test(backgroundColor)) backgroundColor = `!${backgroundColor}`;
  }
  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;
  const res = await fetch(imageUrl);
  if (!res.ok) throw new Error([
    `Failed to render the graph using the Mermaid.INK API.`,
    `Status code: ${res.status}`,
    `Status text: ${res.statusText}`
  ].join("\n"));
  const content = await res.blob();
  return content;
}
var MARKDOWN_SPECIAL_CHARS;
var init_graph_mermaid = __esm({
  "node_modules/@langchain/core/dist/runnables/graph_mermaid.js"() {
    init_utils4();
    MARKDOWN_SPECIAL_CHARS = [
      "*",
      "_",
      "`"
    ];
  }
});

// node_modules/@langchain/core/dist/runnables/graph.js
function nodeDataStr(id, data) {
  if (id !== void 0 && !validate_default(id)) return id;
  else if (isRunnableInterface(data)) try {
    let dataStr = data.getName();
    dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
    return dataStr;
  } catch {
    return data.getName();
  }
  else return data.name ?? "UnknownSchema";
}
function nodeDataJson(node) {
  if (isRunnableInterface(node.data)) return {
    type: "runnable",
    data: {
      id: node.data.lc_id,
      name: node.data.getName()
    }
  };
  else return {
    type: "schema",
    data: {
      ...toJsonSchema(node.data.schema),
      title: node.data.name
    }
  };
}
function _firstNode(graph, exclude = []) {
  const targets = new Set(graph.edges.filter((edge) => !exclude.includes(edge.source)).map((edge) => edge.target));
  const found = [];
  for (const node of Object.values(graph.nodes)) if (!exclude.includes(node.id) && !targets.has(node.id)) found.push(node);
  return found.length === 1 ? found[0] : void 0;
}
function _lastNode(graph, exclude = []) {
  const sources = new Set(graph.edges.filter((edge) => !exclude.includes(edge.target)).map((edge) => edge.source));
  const found = [];
  for (const node of Object.values(graph.nodes)) if (!exclude.includes(node.id) && !sources.has(node.id)) found.push(node);
  return found.length === 1 ? found[0] : void 0;
}
var graph_exports, Graph;
var init_graph = __esm({
  "node_modules/@langchain/core/dist/runnables/graph.js"() {
    init_rolldown_runtime();
    init_utils4();
    init_graph_mermaid();
    init_json_schema2();
    init_esm_node();
    graph_exports = {};
    __export2(graph_exports, { Graph: () => Graph });
    Graph = class Graph2 {
      nodes = {};
      edges = [];
      constructor(params) {
        this.nodes = params?.nodes ?? this.nodes;
        this.edges = params?.edges ?? this.edges;
      }
      toJSON() {
        const stableNodeIds = {};
        Object.values(this.nodes).forEach((node, i) => {
          stableNodeIds[node.id] = validate_default(node.id) ? i : node.id;
        });
        return {
          nodes: Object.values(this.nodes).map((node) => ({
            id: stableNodeIds[node.id],
            ...nodeDataJson(node)
          })),
          edges: this.edges.map((edge) => {
            const item = {
              source: stableNodeIds[edge.source],
              target: stableNodeIds[edge.target]
            };
            if (typeof edge.data !== "undefined") item.data = edge.data;
            if (typeof edge.conditional !== "undefined") item.conditional = edge.conditional;
            return item;
          })
        };
      }
      addNode(data, id, metadata) {
        if (id !== void 0 && this.nodes[id] !== void 0) throw new Error(`Node with id ${id} already exists`);
        const nodeId = id ?? v4_default();
        const node = {
          id: nodeId,
          data,
          name: nodeDataStr(id, data),
          metadata
        };
        this.nodes[nodeId] = node;
        return node;
      }
      removeNode(node) {
        delete this.nodes[node.id];
        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
      }
      addEdge(source, target, data, conditional) {
        if (this.nodes[source.id] === void 0) throw new Error(`Source node ${source.id} not in graph`);
        if (this.nodes[target.id] === void 0) throw new Error(`Target node ${target.id} not in graph`);
        const edge = {
          source: source.id,
          target: target.id,
          data,
          conditional
        };
        this.edges.push(edge);
        return edge;
      }
      firstNode() {
        return _firstNode(this);
      }
      lastNode() {
        return _lastNode(this);
      }
      /**
      * Add all nodes and edges from another graph.
      * Note this doesn't check for duplicates, nor does it connect the graphs.
      */
      extend(graph, prefix = "") {
        let finalPrefix = prefix;
        const nodeIds = Object.values(graph.nodes).map((node) => node.id);
        if (nodeIds.every(validate_default)) finalPrefix = "";
        const prefixed = (id) => {
          return finalPrefix ? `${finalPrefix}:${id}` : id;
        };
        Object.entries(graph.nodes).forEach(([key, value]) => {
          this.nodes[prefixed(key)] = {
            ...value,
            id: prefixed(key)
          };
        });
        const newEdges = graph.edges.map((edge) => {
          return {
            ...edge,
            source: prefixed(edge.source),
            target: prefixed(edge.target)
          };
        });
        this.edges = [...this.edges, ...newEdges];
        const first = graph.firstNode();
        const last = graph.lastNode();
        return [first ? {
          id: prefixed(first.id),
          data: first.data
        } : void 0, last ? {
          id: prefixed(last.id),
          data: last.data
        } : void 0];
      }
      trimFirstNode() {
        const firstNode = this.firstNode();
        if (firstNode && _firstNode(this, [firstNode.id])) this.removeNode(firstNode);
      }
      trimLastNode() {
        const lastNode = this.lastNode();
        if (lastNode && _lastNode(this, [lastNode.id])) this.removeNode(lastNode);
      }
      /**
      * Return a new graph with all nodes re-identified,
      * using their unique, readable names where possible.
      */
      reid() {
        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));
        const nodeLabelCounts = /* @__PURE__ */ new Map();
        Object.values(nodeLabels).forEach((label) => {
          nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
        });
        const getNodeId = (nodeId) => {
          const label = nodeLabels[nodeId];
          if (validate_default(nodeId) && nodeLabelCounts.get(label) === 1) return label;
          else return nodeId;
        };
        return new Graph2({
          nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [getNodeId(id), {
            ...node,
            id: getNodeId(id)
          }])),
          edges: this.edges.map((edge) => ({
            ...edge,
            source: getNodeId(edge.source),
            target: getNodeId(edge.target)
          }))
        });
      }
      drawMermaid(params) {
        const { withStyles, curveStyle, nodeColors = {
          default: "fill:#f2f0ff,line-height:1.2",
          first: "fill-opacity:0",
          last: "fill:#bfb6fc"
        }, wrapLabelNWords } = params ?? {};
        const graph = this.reid();
        const firstNode = graph.firstNode();
        const lastNode = graph.lastNode();
        return drawMermaid(graph.nodes, graph.edges, {
          firstNode: firstNode?.id,
          lastNode: lastNode?.id,
          withStyles,
          curveStyle,
          nodeColors,
          wrapLabelNWords
        });
      }
      async drawMermaidPng(params) {
        const mermaidSyntax = this.drawMermaid(params);
        return drawMermaidImage(mermaidSyntax, { backgroundColor: params?.backgroundColor });
      }
    };
  }
});

// node_modules/@langchain/core/dist/tracers/event_stream.js
function assignName({ name, serialized }) {
  if (name !== void 0) return name;
  if (serialized?.name !== void 0) return serialized.name;
  else if (serialized?.id !== void 0 && Array.isArray(serialized?.id)) return serialized.id[serialized.id.length - 1];
  return "Unnamed";
}
var isStreamEventsHandler, EventStreamCallbackHandler;
var init_event_stream = __esm({
  "node_modules/@langchain/core/dist/tracers/event_stream.js"() {
    init_ai();
    init_base3();
    init_stream();
    init_outputs();
    isStreamEventsHandler = (handler2) => handler2.name === "event_stream_tracer";
    EventStreamCallbackHandler = class extends BaseTracer {
      autoClose = true;
      includeNames;
      includeTypes;
      includeTags;
      excludeNames;
      excludeTypes;
      excludeTags;
      runInfoMap = /* @__PURE__ */ new Map();
      tappedPromises = /* @__PURE__ */ new Map();
      transformStream;
      writer;
      receiveStream;
      readableStreamClosed = false;
      name = "event_stream_tracer";
      lc_prefer_streaming = true;
      constructor(fields) {
        super({
          _awaitHandler: true,
          ...fields
        });
        this.autoClose = fields?.autoClose ?? true;
        this.includeNames = fields?.includeNames;
        this.includeTypes = fields?.includeTypes;
        this.includeTags = fields?.includeTags;
        this.excludeNames = fields?.excludeNames;
        this.excludeTypes = fields?.excludeTypes;
        this.excludeTags = fields?.excludeTags;
        this.transformStream = new TransformStream({ flush: () => {
          this.readableStreamClosed = true;
        } });
        this.writer = this.transformStream.writable.getWriter();
        this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
      }
      [Symbol.asyncIterator]() {
        return this.receiveStream;
      }
      async persistRun(_run) {
      }
      _includeRun(run) {
        const runTags = run.tags ?? [];
        let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
        if (this.includeNames !== void 0) include = include || this.includeNames.includes(run.name);
        if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(run.runType);
        if (this.includeTags !== void 0) include = include || runTags.find((tag) => this.includeTags?.includes(tag)) !== void 0;
        if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(run.name);
        if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(run.runType);
        if (this.excludeTags !== void 0) include = include && runTags.every((tag) => !this.excludeTags?.includes(tag));
        return include;
      }
      async *tapOutputIterable(runId, outputStream) {
        const firstChunk = await outputStream.next();
        if (firstChunk.done) return;
        const runInfo = this.runInfoMap.get(runId);
        if (runInfo === void 0) {
          yield firstChunk.value;
          return;
        }
        function _formatOutputChunk(eventType, data) {
          if (eventType === "llm" && typeof data === "string") return new GenerationChunk({ text: data });
          return data;
        }
        let tappedPromise = this.tappedPromises.get(runId);
        if (tappedPromise === void 0) {
          let tappedPromiseResolver;
          tappedPromise = new Promise((resolve) => {
            tappedPromiseResolver = resolve;
          });
          this.tappedPromises.set(runId, tappedPromise);
          try {
            const event = {
              event: `on_${runInfo.runType}_stream`,
              run_id: runId,
              name: runInfo.name,
              tags: runInfo.tags,
              metadata: runInfo.metadata,
              data: {}
            };
            await this.send({
              ...event,
              data: { chunk: _formatOutputChunk(runInfo.runType, firstChunk.value) }
            }, runInfo);
            yield firstChunk.value;
            for await (const chunk of outputStream) {
              if (runInfo.runType !== "tool" && runInfo.runType !== "retriever") await this.send({
                ...event,
                data: { chunk: _formatOutputChunk(runInfo.runType, chunk) }
              }, runInfo);
              yield chunk;
            }
          } finally {
            tappedPromiseResolver?.();
          }
        } else {
          yield firstChunk.value;
          for await (const chunk of outputStream) yield chunk;
        }
      }
      async send(payload, run) {
        if (this.readableStreamClosed) return;
        if (this._includeRun(run)) await this.writer.write(payload);
      }
      async sendEndEvent(payload, run) {
        const tappedPromise = this.tappedPromises.get(payload.run_id);
        if (tappedPromise !== void 0) tappedPromise.then(() => {
          this.send(payload, run);
        });
        else await this.send(payload, run);
      }
      async onLLMStart(run) {
        const runName = assignName(run);
        const runType = run.inputs.messages !== void 0 ? "chat_model" : "llm";
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType,
          inputs: run.inputs
        };
        this.runInfoMap.set(run.id, runInfo);
        const eventName = `on_${runType}_start`;
        await this.send({
          event: eventName,
          data: { input: run.inputs },
          name: runName,
          tags: run.tags ?? [],
          run_id: run.id,
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onLLMNewToken(run, token, kwargs) {
        const runInfo = this.runInfoMap.get(run.id);
        let chunk;
        let eventName;
        if (runInfo === void 0) throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
        if (this.runInfoMap.size === 1) return;
        if (runInfo.runType === "chat_model") {
          eventName = "on_chat_model_stream";
          if (kwargs?.chunk === void 0) chunk = new AIMessageChunk({
            content: token,
            id: `run-${run.id}`
          });
          else chunk = kwargs.chunk.message;
        } else if (runInfo.runType === "llm") {
          eventName = "on_llm_stream";
          if (kwargs?.chunk === void 0) chunk = new GenerationChunk({ text: token });
          else chunk = kwargs.chunk;
        } else throw new Error(`Unexpected run type ${runInfo.runType}`);
        await this.send({
          event: eventName,
          data: { chunk },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onLLMEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        let eventName;
        if (runInfo === void 0) throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
        const generations = run.outputs?.generations;
        let output;
        if (runInfo.runType === "chat_model") {
          for (const generation of generations ?? []) {
            if (output !== void 0) break;
            output = generation[0]?.message;
          }
          eventName = "on_chat_model_end";
        } else if (runInfo.runType === "llm") {
          output = {
            generations: generations?.map((generation) => {
              return generation.map((chunk) => {
                return {
                  text: chunk.text,
                  generationInfo: chunk.generationInfo
                };
              });
            }),
            llmOutput: run.outputs?.llmOutput ?? {}
          };
          eventName = "on_llm_end";
        } else throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
        await this.sendEndEvent({
          event: eventName,
          data: {
            output,
            input: runInfo.inputs
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onChainStart(run) {
        const runName = assignName(run);
        const runType = run.run_type ?? "chain";
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType: run.run_type
        };
        let eventData = {};
        if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
          eventData = {};
          runInfo.inputs = {};
        } else if (run.inputs.input !== void 0) {
          eventData.input = run.inputs.input;
          runInfo.inputs = run.inputs.input;
        } else {
          eventData.input = run.inputs;
          runInfo.inputs = run.inputs;
        }
        this.runInfoMap.set(run.id, runInfo);
        await this.send({
          event: `on_${runType}_start`,
          data: eventData,
          name: runName,
          tags: run.tags ?? [],
          run_id: run.id,
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onChainEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
        const eventName = `on_${run.run_type}_end`;
        const inputs = run.inputs ?? runInfo.inputs ?? {};
        const outputs = run.outputs?.output ?? run.outputs;
        const data = {
          output: outputs,
          input: inputs
        };
        if (inputs.input && Object.keys(inputs).length === 1) {
          data.input = inputs.input;
          runInfo.inputs = inputs.input;
        }
        await this.sendEndEvent({
          event: eventName,
          data,
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata ?? {}
        }, runInfo);
      }
      async onToolStart(run) {
        const runName = assignName(run);
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType: "tool",
          inputs: run.inputs ?? {}
        };
        this.runInfoMap.set(run.id, runInfo);
        await this.send({
          event: "on_tool_start",
          data: { input: run.inputs ?? {} },
          name: runName,
          run_id: run.id,
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onToolEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
        if (runInfo.inputs === void 0) throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
        const output = run.outputs?.output === void 0 ? run.outputs : run.outputs.output;
        await this.sendEndEvent({
          event: "on_tool_end",
          data: {
            output,
            input: runInfo.inputs
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onToolError(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
        if (runInfo.inputs === void 0) throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
        await this.sendEndEvent({
          event: "on_tool_error",
          data: {
            input: runInfo.inputs,
            error: run.error
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onRetrieverStart(run) {
        const runName = assignName(run);
        const runType = "retriever";
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType,
          inputs: { query: run.inputs.query }
        };
        this.runInfoMap.set(run.id, runInfo);
        await this.send({
          event: "on_retriever_start",
          data: { input: { query: run.inputs.query } },
          name: runName,
          tags: run.tags ?? [],
          run_id: run.id,
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onRetrieverEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
        await this.sendEndEvent({
          event: "on_retriever_end",
          data: {
            output: run.outputs?.documents ?? run.outputs,
            input: runInfo.inputs
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async handleCustomEvent(eventName, data, runId) {
        const runInfo = this.runInfoMap.get(runId);
        if (runInfo === void 0) throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
        await this.send({
          event: "on_custom_event",
          run_id: runId,
          name: eventName,
          tags: runInfo.tags,
          metadata: runInfo.metadata,
          data
        }, runInfo);
      }
      async finish() {
        const pendingPromises = [...this.tappedPromises.values()];
        Promise.all(pendingPromises).finally(() => {
          this.writer.close();
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/tracers/root_listener.js
var RootListenersTracer;
var init_root_listener = __esm({
  "node_modules/@langchain/core/dist/tracers/root_listener.js"() {
    init_base3();
    RootListenersTracer = class extends BaseTracer {
      name = "RootListenersTracer";
      /** The Run's ID. Type UUID */
      rootId;
      config;
      argOnStart;
      argOnEnd;
      argOnError;
      constructor({ config: config2, onStart, onEnd, onError }) {
        super({ _awaitHandler: true });
        this.config = config2;
        this.argOnStart = onStart;
        this.argOnEnd = onEnd;
        this.argOnError = onError;
      }
      /**
      * This is a legacy method only called once for an entire run tree
      * therefore not useful here
      * @param {Run} _ Not used
      */
      persistRun(_) {
        return Promise.resolve();
      }
      async onRunCreate(run) {
        if (this.rootId) return;
        this.rootId = run.id;
        if (this.argOnStart) await this.argOnStart(run, this.config);
      }
      async onRunUpdate(run) {
        if (run.id !== this.rootId) return;
        if (!run.error) {
          if (this.argOnEnd) await this.argOnEnd(run, this.config);
        } else if (this.argOnError) await this.argOnError(run, this.config);
      }
    };
  }
});

// node_modules/@langchain/core/dist/runnables/wrappers.js
function convertToHttpEventStream(stream) {
  const encoder2 = new TextEncoder();
  const finalStream = new ReadableStream({ async start(controller) {
    for await (const chunk of stream) controller.enqueue(encoder2.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
    controller.enqueue(encoder2.encode("event: end\n\n"));
    controller.close();
  } });
  return IterableReadableStream.fromReadableStream(finalStream);
}
var init_wrappers = __esm({
  "node_modules/@langchain/core/dist/runnables/wrappers.js"() {
    init_stream();
  }
});

// node_modules/@langchain/core/dist/runnables/iter.js
function isIterableIterator(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && typeof thing.next === "function";
}
function isAsyncIterable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
}
function* consumeIteratorInContext(context2, iter) {
  while (true) {
    const { value, done } = AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(context2), iter.next.bind(iter), true);
    if (done) break;
    else yield value;
  }
}
async function* consumeAsyncIterableInContext(context2, iter) {
  const iterator = iter[Symbol.asyncIterator]();
  while (true) {
    const { value, done } = await AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(context2), iterator.next.bind(iter), true);
    if (done) break;
    else yield value;
  }
}
var isIterator;
var init_iter = __esm({
  "node_modules/@langchain/core/dist/runnables/iter.js"() {
    init_async_local_storage();
    init_singletons();
    init_config();
    isIterator = (x) => x != null && typeof x === "object" && "next" in x && typeof x.next === "function";
  }
});

// node_modules/@langchain/core/dist/runnables/base.js
function _coerceToDict2(value, defaultKey) {
  return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
}
function assertNonTraceableFunction(func) {
  if (isTraceableFunction(func)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function") return new RunnableLambda({ func: coerceable });
  else if (Runnable.isRunnable(coerceable)) return coerceable;
  else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
    const runnables = {};
    for (const [key, value] of Object.entries(coerceable)) runnables[key] = _coerceToRunnable(value);
    return new RunnableMap({ steps: runnables });
  } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
function convertRunnableToTool(runnable, fields) {
  const name = fields.name ?? runnable.getName();
  const description = fields.description ?? getSchemaDescription(fields.schema);
  if (isSimpleStringZodSchema(fields.schema)) return new RunnableToolLike({
    name,
    description,
    schema: external_exports.object({ input: external_exports.string() }).transform((input) => input.input),
    bound: runnable
  });
  return new RunnableToolLike({
    name,
    description,
    schema: fields.schema,
    bound: runnable
  });
}
var Runnable, RunnableBinding, RunnableEach, RunnableRetry, RunnableSequence, RunnableMap, RunnableTraceable, RunnableLambda, RunnableParallel, RunnableWithFallbacks, RunnableAssign, RunnablePick, RunnableToolLike;
var init_base4 = __esm({
  "node_modules/@langchain/core/dist/runnables/base.js"() {
    init_serializable();
    init_utils2();
    init_async_local_storage();
    init_singletons();
    init_config();
    init_signal();
    init_stream();
    init_log_stream();
    init_event_stream();
    init_p_retry2();
    init_async_caller2();
    init_root_listener();
    init_utils4();
    init_zod2();
    init_graph();
    init_wrappers();
    init_iter();
    init_v3();
    init_esm_node();
    init_traceable2();
    Runnable = class extends Serializable {
      lc_runnable = true;
      name;
      getName(suffix) {
        const name = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
        return suffix ? `${name}${suffix}` : name;
      }
      /**
      * Add retry logic to an existing runnable.
      * @param fields.stopAfterAttempt The number of attempts to retry.
      * @param fields.onFailedAttempt A function that is called when a retry fails.
      * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
      */
      withRetry(fields) {
        return new RunnableRetry({
          bound: this,
          kwargs: {},
          config: {},
          maxAttemptNumber: fields?.stopAfterAttempt,
          ...fields
        });
      }
      /**
      * Bind config to a Runnable, returning a new Runnable.
      * @param config New configuration parameters to attach to the new runnable.
      * @returns A new RunnableBinding with a config matching what's passed.
      */
      withConfig(config2) {
        return new RunnableBinding({
          bound: this,
          config: config2,
          kwargs: {}
        });
      }
      /**
      * Create a new runnable from the current one that will try invoking
      * other passed fallback runnables if the initial invocation fails.
      * @param fields.fallbacks Other runnables to call if the runnable errors.
      * @returns A new RunnableWithFallbacks.
      */
      withFallbacks(fields) {
        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
        return new RunnableWithFallbacks({
          runnable: this,
          fallbacks
        });
      }
      _getOptionsList(options, length = 0) {
        if (Array.isArray(options) && options.length !== length) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
        if (Array.isArray(options)) return options.map(ensureConfig);
        if (length > 1 && !Array.isArray(options) && options.runId) {
          console.warn("Provided runId will be used only for the first element of the batch.");
          const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== "runId"));
          return Array.from({ length }, (_, i) => ensureConfig(i === 0 ? options : subsequent));
        }
        return Array.from({ length }, () => ensureConfig(options));
      }
      async batch(inputs, options, batchOptions) {
        const configList = this._getOptionsList(options ?? {}, inputs.length);
        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;
        const caller2 = new AsyncCaller2({
          maxConcurrency,
          onFailedAttempt: (e) => {
            throw e;
          }
        });
        const batchCalls = inputs.map((input, i) => caller2.call(async () => {
          try {
            const result = await this.invoke(input, configList[i]);
            return result;
          } catch (e) {
            if (batchOptions?.returnExceptions) return e;
            throw e;
          }
        }));
        return Promise.all(batchCalls);
      }
      /**
      * Default streaming implementation.
      * Subclasses should override this method if they support streaming output.
      * @param input
      * @param options
      */
      async *_streamIterator(input, options) {
        yield this.invoke(input, options);
      }
      /**
      * Stream output in chunks.
      * @param input
      * @param options
      * @returns A readable stream that is also an iterable.
      */
      async stream(input, options) {
        const config2 = ensureConfig(options);
        const wrappedGenerator = new AsyncGeneratorWithSetup({
          generator: this._streamIterator(input, config2),
          config: config2
        });
        await wrappedGenerator.setup;
        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
      _separateRunnableConfigFromCallOptions(options) {
        let runnableConfig;
        if (options === void 0) runnableConfig = ensureConfig(options);
        else runnableConfig = ensureConfig({
          callbacks: options.callbacks,
          tags: options.tags,
          metadata: options.metadata,
          runName: options.runName,
          configurable: options.configurable,
          recursionLimit: options.recursionLimit,
          maxConcurrency: options.maxConcurrency,
          runId: options.runId,
          timeout: options.timeout,
          signal: options.signal
        });
        const callOptions = { ...options };
        delete callOptions.callbacks;
        delete callOptions.tags;
        delete callOptions.metadata;
        delete callOptions.runName;
        delete callOptions.configurable;
        delete callOptions.recursionLimit;
        delete callOptions.maxConcurrency;
        delete callOptions.runId;
        delete callOptions.timeout;
        delete callOptions.signal;
        return [runnableConfig, callOptions];
      }
      async _callWithConfig(func, input, options) {
        const config2 = ensureConfig(options);
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config2.runId, config2?.runType, void 0, void 0, config2?.runName ?? this.getName());
        delete config2.runId;
        let output;
        try {
          const promise2 = func.call(this, input, config2, runManager);
          output = await raceWithSignal(promise2, options?.signal);
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict2(output, "output"));
        return output;
      }
      /**
      * Internal method that handles batching and configuration for a runnable
      * It takes a function, input values, and optional configuration, and
      * returns a promise that resolves to the output values.
      * @param func The function to be executed for each input value.
      * @param input The input values to be processed.
      * @param config Optional configuration for the function execution.
      * @returns A promise that resolves to the output values.
      */
      async _batchWithConfig(func, inputs, options, batchOptions) {
        const optionsList = this._getOptionsList(options ?? {}, inputs.length);
        const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
          const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), optionsList[i].runId, optionsList[i].runType, void 0, void 0, optionsList[i].runName ?? this.getName());
          delete optionsList[i].runId;
          return handleStartRes;
        }));
        let outputs;
        try {
          const promise2 = func.call(this, inputs, optionsList, runManagers, batchOptions);
          outputs = await raceWithSignal(promise2, optionsList?.[0]?.signal);
        } catch (e) {
          await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));
          throw e;
        }
        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict2(outputs, "output"))));
        return outputs;
      }
      /** @internal */
      _concatOutputChunks(first, second) {
        return concat(first, second);
      }
      /**
      * Helper method to transform an Iterator of Input values into an Iterator of
      * Output values, with callbacks.
      * Use this to implement `stream()` or `transform()` in Runnable subclasses.
      */
      async *_transformStreamWithConfig(inputGenerator, transformer, options) {
        let finalInput;
        let finalInputSupported = true;
        let finalOutput;
        let finalOutputSupported = true;
        const config2 = ensureConfig(options);
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const outerThis = this;
        async function* wrapInputForTracing() {
          for await (const chunk of inputGenerator) {
            if (finalInputSupported) if (finalInput === void 0) finalInput = chunk;
            else try {
              finalInput = outerThis._concatOutputChunks(finalInput, chunk);
            } catch {
              finalInput = void 0;
              finalInputSupported = false;
            }
            yield chunk;
          }
        }
        let runManager;
        try {
          const pipe2 = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: "" }, config2.runId, config2.runType, void 0, void 0, config2.runName ?? this.getName(), void 0, { lc_defers_inputs: true }), options?.signal, config2);
          delete config2.runId;
          runManager = pipe2.setup;
          const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);
          let iterator = pipe2.output;
          if (streamEventsHandler !== void 0 && runManager !== void 0) iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
          const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);
          if (streamLogHandler !== void 0 && runManager !== void 0) iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
          for await (const chunk of iterator) {
            yield chunk;
            if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
            else try {
              finalOutput = this._concatOutputChunks(finalOutput, chunk);
            } catch {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e, void 0, void 0, void 0, { inputs: _coerceToDict2(finalInput, "input") });
          throw e;
        }
        await runManager?.handleChainEnd(finalOutput ?? {}, void 0, void 0, void 0, { inputs: _coerceToDict2(finalInput, "input") });
      }
      getGraph(_) {
        const graph = new Graph();
        const inputNode = graph.addNode({
          name: `${this.getName()}Input`,
          schema: external_exports.any()
        });
        const runnableNode = graph.addNode(this);
        const outputNode = graph.addNode({
          name: `${this.getName()}Output`,
          schema: external_exports.any()
        });
        graph.addEdge(inputNode, runnableNode);
        graph.addEdge(runnableNode, outputNode);
        return graph;
      }
      /**
      * Create a new runnable sequence that runs each individual runnable in series,
      * piping the output of one runnable into another runnable or runnable-like.
      * @param coerceable A runnable, function, or object whose values are functions or runnables.
      * @returns A new runnable sequence.
      */
      pipe(coerceable) {
        return new RunnableSequence({
          first: this,
          last: _coerceToRunnable(coerceable)
        });
      }
      /**
      * Pick keys from the dict output of this runnable. Returns a new runnable.
      */
      pick(keys) {
        return this.pipe(new RunnablePick(keys));
      }
      /**
      * Assigns new fields to the dict output of this runnable. Returns a new runnable.
      */
      assign(mapping) {
        return this.pipe(new RunnableAssign(new RunnableMap({ steps: mapping })));
      }
      /**
      * Default implementation of transform, which buffers input and then calls stream.
      * Subclasses should override this method if they can start producing output while
      * input is still being generated.
      * @param generator
      * @param options
      */
      async *transform(generator, options) {
        let finalChunk;
        for await (const chunk of generator) if (finalChunk === void 0) finalChunk = chunk;
        else finalChunk = this._concatOutputChunks(finalChunk, chunk);
        yield* this._streamIterator(finalChunk, ensureConfig(options));
      }
      /**
      * Stream all output from a runnable, as reported to the callback system.
      * This includes all inner runs of LLMs, Retrievers, Tools, etc.
      * Output is streamed as Log objects, which include a list of
      * jsonpatch ops that describe how the state of the run has changed in each
      * step, and the final state of the run.
      * The jsonpatch ops can be applied in order to construct state.
      * @param input
      * @param options
      * @param streamOptions
      */
      async *streamLog(input, options, streamOptions) {
        const logStreamCallbackHandler = new LogStreamCallbackHandler({
          ...streamOptions,
          autoClose: false,
          _schemaFormat: "original"
        });
        const config2 = ensureConfig(options);
        yield* this._streamLog(input, logStreamCallbackHandler, config2);
      }
      async *_streamLog(input, logStreamCallbackHandler, config2) {
        const { callbacks } = config2;
        if (callbacks === void 0) config2.callbacks = [logStreamCallbackHandler];
        else if (Array.isArray(callbacks)) config2.callbacks = callbacks.concat([logStreamCallbackHandler]);
        else {
          const copiedCallbacks = callbacks.copy();
          copiedCallbacks.addHandler(logStreamCallbackHandler, true);
          config2.callbacks = copiedCallbacks;
        }
        const runnableStreamPromise = this.stream(input, config2);
        async function consumeRunnableStream() {
          try {
            const runnableStream = await runnableStreamPromise;
            for await (const chunk of runnableStream) {
              const patch = new RunLogPatch({ ops: [{
                op: "add",
                path: "/streamed_output/-",
                value: chunk
              }] });
              await logStreamCallbackHandler.writer.write(patch);
            }
          } finally {
            await logStreamCallbackHandler.writer.close();
          }
        }
        const runnableStreamConsumePromise = consumeRunnableStream();
        try {
          for await (const log of logStreamCallbackHandler) yield log;
        } finally {
          await runnableStreamConsumePromise;
        }
      }
      streamEvents(input, options, streamOptions) {
        let stream;
        if (options.version === "v1") stream = this._streamEventsV1(input, options, streamOptions);
        else if (options.version === "v2") stream = this._streamEventsV2(input, options, streamOptions);
        else throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
        if (options.encoding === "text/event-stream") return convertToHttpEventStream(stream);
        else return IterableReadableStream.fromAsyncGenerator(stream);
      }
      async *_streamEventsV2(input, options, streamOptions) {
        const eventStreamer = new EventStreamCallbackHandler({
          ...streamOptions,
          autoClose: false
        });
        const config2 = ensureConfig(options);
        const runId = config2.runId ?? v4_default();
        config2.runId = runId;
        const callbacks = config2.callbacks;
        if (callbacks === void 0) config2.callbacks = [eventStreamer];
        else if (Array.isArray(callbacks)) config2.callbacks = callbacks.concat(eventStreamer);
        else {
          const copiedCallbacks = callbacks.copy();
          copiedCallbacks.addHandler(eventStreamer, true);
          config2.callbacks = copiedCallbacks;
        }
        const abortController = new AbortController();
        const outerThis = this;
        async function consumeRunnableStream() {
          let signal;
          let listener = null;
          try {
            if (options?.signal) if ("any" in AbortSignal) signal = AbortSignal.any([abortController.signal, options.signal]);
            else {
              signal = options.signal;
              listener = () => {
                abortController.abort();
              };
              options.signal.addEventListener("abort", listener, { once: true });
            }
            else signal = abortController.signal;
            const runnableStream = await outerThis.stream(input, {
              ...config2,
              signal
            });
            const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
            for await (const _ of tappedStream) if (abortController.signal.aborted) break;
          } finally {
            await eventStreamer.finish();
            if (signal && listener) signal.removeEventListener("abort", listener);
          }
        }
        const runnableStreamConsumePromise = consumeRunnableStream();
        let firstEventSent = false;
        let firstEventRunId;
        try {
          for await (const event of eventStreamer) {
            if (!firstEventSent) {
              event.data.input = input;
              firstEventSent = true;
              firstEventRunId = event.run_id;
              yield event;
              continue;
            }
            if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
              if (event.data?.input) delete event.data.input;
            }
            yield event;
          }
        } finally {
          abortController.abort();
          await runnableStreamConsumePromise;
        }
      }
      async *_streamEventsV1(input, options, streamOptions) {
        let runLog;
        let hasEncounteredStartEvent = false;
        const config2 = ensureConfig(options);
        const rootTags = config2.tags ?? [];
        const rootMetadata = config2.metadata ?? {};
        const rootName = config2.runName ?? this.getName();
        const logStreamCallbackHandler = new LogStreamCallbackHandler({
          ...streamOptions,
          autoClose: false,
          _schemaFormat: "streaming_events"
        });
        const rootEventFilter = new _RootEventFilter({ ...streamOptions });
        const logStream = this._streamLog(input, logStreamCallbackHandler, config2);
        for await (const log of logStream) {
          if (!runLog) runLog = RunLog.fromRunLogPatch(log);
          else runLog = runLog.concat(log);
          if (runLog.state === void 0) throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
          if (!hasEncounteredStartEvent) {
            hasEncounteredStartEvent = true;
            const state$2 = { ...runLog.state };
            const event = {
              run_id: state$2.id,
              event: `on_${state$2.type}_start`,
              name: rootName,
              tags: rootTags,
              metadata: rootMetadata,
              data: { input }
            };
            if (rootEventFilter.includeEvent(event, state$2.type)) yield event;
          }
          const paths = log.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
          const dedupedPaths = [...new Set(paths)];
          for (const path3 of dedupedPaths) {
            let eventType;
            let data = {};
            const logEntry = runLog.state.logs[path3];
            if (logEntry.end_time === void 0) if (logEntry.streamed_output.length > 0) eventType = "stream";
            else eventType = "start";
            else eventType = "end";
            if (eventType === "start") {
              if (logEntry.inputs !== void 0) data.input = logEntry.inputs;
            } else if (eventType === "end") {
              if (logEntry.inputs !== void 0) data.input = logEntry.inputs;
              data.output = logEntry.final_output;
            } else if (eventType === "stream") {
              const chunkCount = logEntry.streamed_output.length;
              if (chunkCount !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
              data = { chunk: logEntry.streamed_output[0] };
              logEntry.streamed_output = [];
            }
            yield {
              event: `on_${logEntry.type}_${eventType}`,
              name: logEntry.name,
              run_id: logEntry.id,
              tags: logEntry.tags,
              metadata: logEntry.metadata,
              data
            };
          }
          const { state: state$1 } = runLog;
          if (state$1.streamed_output.length > 0) {
            const chunkCount = state$1.streamed_output.length;
            if (chunkCount !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state$1.name}"`);
            const data = { chunk: state$1.streamed_output[0] };
            state$1.streamed_output = [];
            const event = {
              event: `on_${state$1.type}_stream`,
              run_id: state$1.id,
              tags: rootTags,
              metadata: rootMetadata,
              name: rootName,
              data
            };
            if (rootEventFilter.includeEvent(event, state$1.type)) yield event;
          }
        }
        const state = runLog?.state;
        if (state !== void 0) {
          const event = {
            event: `on_${state.type}_end`,
            name: rootName,
            run_id: state.id,
            tags: rootTags,
            metadata: rootMetadata,
            data: { output: state.final_output }
          };
          if (rootEventFilter.includeEvent(event, state.type)) yield event;
        }
      }
      static isRunnable(thing) {
        return isRunnableInterface(thing);
      }
      /**
      * Bind lifecycle listeners to a Runnable, returning a new Runnable.
      * The Run object contains information about the run, including its id,
      * type, input, output, error, startTime, endTime, and any tags or metadata
      * added to the run.
      *
      * @param {Object} params - The object containing the callback functions.
      * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
      * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
      * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
      */
      withListeners({ onStart, onEnd, onError }) {
        return new RunnableBinding({
          bound: this,
          config: {},
          configFactories: [(config2) => ({ callbacks: [new RootListenersTracer({
            config: config2,
            onStart,
            onEnd,
            onError
          })] })]
        });
      }
      /**
      * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
      * which contains the runnable, name, description and schema.
      *
      * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
      *
      * @param fields
      * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
      * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
      * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
      * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
      */
      asTool(fields) {
        return convertRunnableToTool(this, fields);
      }
    };
    RunnableBinding = class RunnableBinding2 extends Runnable {
      static lc_name() {
        return "RunnableBinding";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      bound;
      config;
      kwargs;
      configFactories;
      constructor(fields) {
        super(fields);
        this.bound = fields.bound;
        this.kwargs = fields.kwargs;
        this.config = fields.config;
        this.configFactories = fields.configFactories;
      }
      getName(suffix) {
        return this.bound.getName(suffix);
      }
      async _mergeConfig(...options) {
        const config2 = mergeConfigs(this.config, ...options);
        return mergeConfigs(config2, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config2))) : []);
      }
      withConfig(config2) {
        return new this.constructor({
          bound: this.bound,
          kwargs: this.kwargs,
          config: {
            ...this.config,
            ...config2
          }
        });
      }
      withRetry(fields) {
        return new RunnableRetry({
          bound: this.bound,
          kwargs: this.kwargs,
          config: this.config,
          maxAttemptNumber: fields?.stopAfterAttempt,
          ...fields
        });
      }
      async invoke(input, options) {
        return this.bound.invoke(input, await this._mergeConfig(options, this.kwargs));
      }
      async batch(inputs, options, batchOptions) {
        const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);
        return this.bound.batch(inputs, mergedOptions, batchOptions);
      }
      /** @internal */
      _concatOutputChunks(first, second) {
        return this.bound._concatOutputChunks(first, second);
      }
      async *_streamIterator(input, options) {
        yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
      }
      async stream(input, options) {
        return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
      }
      async *transform(generator, options) {
        yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));
      }
      streamEvents(input, options, streamOptions) {
        const outerThis = this;
        const generator = async function* () {
          yield* outerThis.bound.streamEvents(input, {
            ...await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs),
            version: options.version
          }, streamOptions);
        };
        return IterableReadableStream.fromAsyncGenerator(generator());
      }
      static isRunnableBinding(thing) {
        return thing.bound && Runnable.isRunnable(thing.bound);
      }
      /**
      * Bind lifecycle listeners to a Runnable, returning a new Runnable.
      * The Run object contains information about the run, including its id,
      * type, input, output, error, startTime, endTime, and any tags or metadata
      * added to the run.
      *
      * @param {Object} params - The object containing the callback functions.
      * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
      * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
      * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
      */
      withListeners({ onStart, onEnd, onError }) {
        return new RunnableBinding2({
          bound: this.bound,
          kwargs: this.kwargs,
          config: this.config,
          configFactories: [(config2) => ({ callbacks: [new RootListenersTracer({
            config: config2,
            onStart,
            onEnd,
            onError
          })] })]
        });
      }
    };
    RunnableEach = class RunnableEach2 extends Runnable {
      static lc_name() {
        return "RunnableEach";
      }
      lc_serializable = true;
      lc_namespace = ["langchain_core", "runnables"];
      bound;
      constructor(fields) {
        super(fields);
        this.bound = fields.bound;
      }
      /**
      * Invokes the runnable with the specified input and configuration.
      * @param input The input to invoke the runnable with.
      * @param config The configuration to invoke the runnable with.
      * @returns A promise that resolves to the output of the runnable.
      */
      async invoke(inputs, config2) {
        return this._callWithConfig(this._invoke.bind(this), inputs, config2);
      }
      /**
      * A helper method that is used to invoke the runnable with the specified input and configuration.
      * @param input The input to invoke the runnable with.
      * @param config The configuration to invoke the runnable with.
      * @returns A promise that resolves to the output of the runnable.
      */
      async _invoke(inputs, config2, runManager) {
        return this.bound.batch(inputs, patchConfig(config2, { callbacks: runManager?.getChild() }));
      }
      /**
      * Bind lifecycle listeners to a Runnable, returning a new Runnable.
      * The Run object contains information about the run, including its id,
      * type, input, output, error, startTime, endTime, and any tags or metadata
      * added to the run.
      *
      * @param {Object} params - The object containing the callback functions.
      * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
      * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
      * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
      */
      withListeners({ onStart, onEnd, onError }) {
        return new RunnableEach2({ bound: this.bound.withListeners({
          onStart,
          onEnd,
          onError
        }) });
      }
    };
    RunnableRetry = class extends RunnableBinding {
      static lc_name() {
        return "RunnableRetry";
      }
      lc_namespace = ["langchain_core", "runnables"];
      maxAttemptNumber = 3;
      onFailedAttempt = () => {
      };
      constructor(fields) {
        super(fields);
        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
      }
      _patchConfigForRetry(attempt, config2, runManager) {
        const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
        return patchConfig(config2, { callbacks: runManager?.getChild(tag) });
      }
      async _invoke(input, config2, runManager) {
        return pRetry2((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config2, runManager)), {
          onFailedAttempt: ({ error: error40 }) => this.onFailedAttempt(error40, input),
          retries: Math.max(this.maxAttemptNumber - 1, 0),
          randomize: true
        });
      }
      /**
      * Method that invokes the runnable with the specified input, run manager,
      * and config. It handles the retry logic by catching any errors and
      * recursively invoking itself with the updated config for the next retry
      * attempt.
      * @param input The input for the runnable.
      * @param runManager The run manager for the runnable.
      * @param config The config for the runnable.
      * @returns A promise that resolves to the output of the runnable.
      */
      async invoke(input, config2) {
        return this._callWithConfig(this._invoke.bind(this), input, config2);
      }
      async _batch(inputs, configs, runManagers, batchOptions) {
        const resultsMap = {};
        try {
          await pRetry2(async (attemptNumber) => {
            const remainingIndexes = inputs.map((_, i) => i).filter((i) => resultsMap[i.toString()] === void 0 || resultsMap[i.toString()] instanceof Error);
            const remainingInputs = remainingIndexes.map((i) => inputs[i]);
            const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));
            const results = await super.batch(remainingInputs, patchedConfigs, {
              ...batchOptions,
              returnExceptions: true
            });
            let firstException;
            for (let i = 0; i < results.length; i += 1) {
              const result = results[i];
              const resultMapIndex = remainingIndexes[i];
              if (result instanceof Error) {
                if (firstException === void 0) {
                  firstException = result;
                  firstException.input = remainingInputs[i];
                }
              }
              resultsMap[resultMapIndex.toString()] = result;
            }
            if (firstException) throw firstException;
            return results;
          }, {
            onFailedAttempt: ({ error: error40 }) => this.onFailedAttempt(error40, error40.input),
            retries: Math.max(this.maxAttemptNumber - 1, 0),
            randomize: true
          });
        } catch (e) {
          if (batchOptions?.returnExceptions !== true) throw e;
        }
        return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
      }
      async batch(inputs, options, batchOptions) {
        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
      }
    };
    RunnableSequence = class RunnableSequence2 extends Runnable {
      static lc_name() {
        return "RunnableSequence";
      }
      first;
      middle = [];
      last;
      omitSequenceTags = false;
      lc_serializable = true;
      lc_namespace = ["langchain_core", "runnables"];
      constructor(fields) {
        super(fields);
        this.first = fields.first;
        this.middle = fields.middle ?? this.middle;
        this.last = fields.last;
        this.name = fields.name;
        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;
      }
      get steps() {
        return [
          this.first,
          ...this.middle,
          this.last
        ];
      }
      async invoke(input, options) {
        const config2 = ensureConfig(options);
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config2.runId, void 0, void 0, void 0, config2?.runName);
        delete config2.runId;
        let nextStepInput = input;
        let finalOutput;
        try {
          const initialSteps = [this.first, ...this.middle];
          for (let i = 0; i < initialSteps.length; i += 1) {
            const step = initialSteps[i];
            const promise2 = step.invoke(nextStepInput, patchConfig(config2, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`) }));
            nextStepInput = await raceWithSignal(promise2, options?.signal);
          }
          if (options?.signal?.aborted) throw getAbortSignalError(options.signal);
          finalOutput = await this.last.invoke(nextStepInput, patchConfig(config2, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict2(finalOutput, "output"));
        return finalOutput;
      }
      async batch(inputs, options, batchOptions) {
        const configList = this._getOptionsList(options ?? {}, inputs.length);
        const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
          const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName);
          delete configList[i].runId;
          return handleStartRes;
        }));
        let nextStepInputs = inputs;
        try {
          for (let i = 0; i < this.steps.length; i += 1) {
            const step = this.steps[i];
            const promise2 = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
              const childRunManager = runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`);
              return patchConfig(configList[j], { callbacks: childRunManager });
            }), batchOptions);
            nextStepInputs = await raceWithSignal(promise2, configList[0]?.signal);
          }
        } catch (e) {
          await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));
          throw e;
        }
        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict2(nextStepInputs, "output"))));
        return nextStepInputs;
      }
      /** @internal */
      _concatOutputChunks(first, second) {
        return this.last._concatOutputChunks(first, second);
      }
      async *_streamIterator(input, options) {
        const callbackManager_ = await getCallbackManagerForConfig(options);
        const { runId, ...otherOptions } = options ?? {};
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, void 0, void 0, void 0, otherOptions?.runName);
        const steps = [
          this.first,
          ...this.middle,
          this.last
        ];
        let concatSupported = true;
        let finalOutput;
        async function* inputGenerator() {
          yield input;
        }
        try {
          let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:1`) }));
          for (let i = 1; i < steps.length; i += 1) {
            const step = steps[i];
            finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`) }));
          }
          for await (const chunk of finalGenerator) {
            options?.signal?.throwIfAborted();
            yield chunk;
            if (concatSupported) if (finalOutput === void 0) finalOutput = chunk;
            else try {
              finalOutput = this._concatOutputChunks(finalOutput, chunk);
            } catch {
              finalOutput = void 0;
              concatSupported = false;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict2(finalOutput, "output"));
      }
      getGraph(config2) {
        const graph = new Graph();
        let currentLastNode = null;
        this.steps.forEach((step, index2) => {
          const stepGraph = step.getGraph(config2);
          if (index2 !== 0) stepGraph.trimFirstNode();
          if (index2 !== this.steps.length - 1) stepGraph.trimLastNode();
          graph.extend(stepGraph);
          const stepFirstNode = stepGraph.firstNode();
          if (!stepFirstNode) throw new Error(`Runnable ${step} has no first node`);
          if (currentLastNode) graph.addEdge(currentLastNode, stepFirstNode);
          currentLastNode = stepGraph.lastNode();
        });
        return graph;
      }
      pipe(coerceable) {
        if (RunnableSequence2.isRunnableSequence(coerceable)) return new RunnableSequence2({
          first: this.first,
          middle: this.middle.concat([
            this.last,
            coerceable.first,
            ...coerceable.middle
          ]),
          last: coerceable.last,
          name: this.name ?? coerceable.name
        });
        else return new RunnableSequence2({
          first: this.first,
          middle: [...this.middle, this.last],
          last: _coerceToRunnable(coerceable),
          name: this.name
        });
      }
      static isRunnableSequence(thing) {
        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
      }
      static from([first, ...runnables], nameOrFields) {
        let extra = {};
        if (typeof nameOrFields === "string") extra.name = nameOrFields;
        else if (nameOrFields !== void 0) extra = nameOrFields;
        return new RunnableSequence2({
          ...extra,
          first: _coerceToRunnable(first),
          middle: runnables.slice(0, -1).map(_coerceToRunnable),
          last: _coerceToRunnable(runnables[runnables.length - 1])
        });
      }
    };
    RunnableMap = class RunnableMap2 extends Runnable {
      static lc_name() {
        return "RunnableMap";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      steps;
      getStepsKeys() {
        return Object.keys(this.steps);
      }
      constructor(fields) {
        super(fields);
        this.steps = {};
        for (const [key, value] of Object.entries(fields.steps)) this.steps[key] = _coerceToRunnable(value);
      }
      static from(steps) {
        return new RunnableMap2({ steps });
      }
      async invoke(input, options) {
        const config2 = ensureConfig(options);
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), { input }, config2.runId, void 0, void 0, void 0, config2?.runName);
        delete config2.runId;
        const output = {};
        try {
          const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
            output[key] = await runnable.invoke(input, patchConfig(config2, { callbacks: runManager?.getChild(`map:key:${key}`) }));
          });
          await raceWithSignal(Promise.all(promises), options?.signal);
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(output);
        return output;
      }
      async *_transform(generator, runManager, options) {
        const steps = { ...this.steps };
        const inputCopies = atee(generator, Object.keys(steps).length);
        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {
          const gen = runnable.transform(inputCopies[i], patchConfig(options, { callbacks: runManager?.getChild(`map:key:${key}`) }));
          return [key, gen.next().then((result) => ({
            key,
            gen,
            result
          }))];
        }));
        while (tasks.size) {
          const promise2 = Promise.race(tasks.values());
          const { key, result, gen } = await raceWithSignal(promise2, options?.signal);
          tasks.delete(key);
          if (!result.done) {
            yield { [key]: result.value };
            tasks.set(key, gen.next().then((result$1) => ({
              key,
              gen,
              result: result$1
            })));
          }
        }
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config2 = ensureConfig(options);
        const wrappedGenerator = new AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config2),
          config: config2
        });
        await wrappedGenerator.setup;
        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    RunnableTraceable = class RunnableTraceable2 extends Runnable {
      lc_serializable = false;
      lc_namespace = ["langchain_core", "runnables"];
      func;
      constructor(fields) {
        super(fields);
        if (!isTraceableFunction(fields.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
        this.func = fields.func;
      }
      async invoke(input, options) {
        const [config2] = this._getOptionsList(options ?? {}, 1);
        const callbacks = await getCallbackManagerForConfig(config2);
        const promise2 = this.func(patchConfig(config2, { callbacks }), input);
        return raceWithSignal(promise2, config2?.signal);
      }
      async *_streamIterator(input, options) {
        const [config2] = this._getOptionsList(options ?? {}, 1);
        const result = await this.invoke(input, options);
        if (isAsyncIterable(result)) {
          for await (const item of result) {
            config2?.signal?.throwIfAborted();
            yield item;
          }
          return;
        }
        if (isIterator(result)) {
          while (true) {
            config2?.signal?.throwIfAborted();
            const state = result.next();
            if (state.done) break;
            yield state.value;
          }
          return;
        }
        yield result;
      }
      static from(func) {
        return new RunnableTraceable2({ func });
      }
    };
    RunnableLambda = class RunnableLambda2 extends Runnable {
      static lc_name() {
        return "RunnableLambda";
      }
      lc_namespace = ["langchain_core", "runnables"];
      func;
      constructor(fields) {
        if (isTraceableFunction(fields.func)) return RunnableTraceable.from(fields.func);
        super(fields);
        assertNonTraceableFunction(fields.func);
        this.func = fields.func;
      }
      static from(func) {
        return new RunnableLambda2({ func });
      }
      async _invoke(input, config2, runManager) {
        return new Promise((resolve, reject) => {
          const childConfig = patchConfig(config2, {
            callbacks: runManager?.getChild(),
            recursionLimit: (config2?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
          });
          AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
            try {
              let output = await this.func(input, { ...childConfig });
              if (output && Runnable.isRunnable(output)) {
                if (config2?.recursionLimit === 0) throw new Error("Recursion limit reached.");
                output = await output.invoke(input, {
                  ...childConfig,
                  recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
                });
              } else if (isAsyncIterable(output)) {
                let finalOutput;
                for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
                  config2?.signal?.throwIfAborted();
                  if (finalOutput === void 0) finalOutput = chunk;
                  else try {
                    finalOutput = this._concatOutputChunks(finalOutput, chunk);
                  } catch {
                    finalOutput = chunk;
                  }
                }
                output = finalOutput;
              } else if (isIterableIterator(output)) {
                let finalOutput;
                for (const chunk of consumeIteratorInContext(childConfig, output)) {
                  config2?.signal?.throwIfAborted();
                  if (finalOutput === void 0) finalOutput = chunk;
                  else try {
                    finalOutput = this._concatOutputChunks(finalOutput, chunk);
                  } catch {
                    finalOutput = chunk;
                  }
                }
                output = finalOutput;
              }
              resolve(output);
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async invoke(input, options) {
        return this._callWithConfig(this._invoke.bind(this), input, options);
      }
      async *_transform(generator, runManager, config2) {
        let finalChunk;
        for await (const chunk of generator) if (finalChunk === void 0) finalChunk = chunk;
        else try {
          finalChunk = this._concatOutputChunks(finalChunk, chunk);
        } catch {
          finalChunk = chunk;
        }
        const childConfig = patchConfig(config2, {
          callbacks: runManager?.getChild(),
          recursionLimit: (config2?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
        });
        const output = await new Promise((resolve, reject) => {
          AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
            try {
              const res = await this.func(finalChunk, {
                ...childConfig,
                config: childConfig
              });
              resolve(res);
            } catch (e) {
              reject(e);
            }
          });
        });
        if (output && Runnable.isRunnable(output)) {
          if (config2?.recursionLimit === 0) throw new Error("Recursion limit reached.");
          const stream = await output.stream(finalChunk, childConfig);
          for await (const chunk of stream) yield chunk;
        } else if (isAsyncIterable(output)) for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
          config2?.signal?.throwIfAborted();
          yield chunk;
        }
        else if (isIterableIterator(output)) for (const chunk of consumeIteratorInContext(childConfig, output)) {
          config2?.signal?.throwIfAborted();
          yield chunk;
        }
        else yield output;
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config2 = ensureConfig(options);
        const wrappedGenerator = new AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config2),
          config: config2
        });
        await wrappedGenerator.setup;
        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    RunnableParallel = class extends RunnableMap {
    };
    RunnableWithFallbacks = class extends Runnable {
      static lc_name() {
        return "RunnableWithFallbacks";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      runnable;
      fallbacks;
      constructor(fields) {
        super(fields);
        this.runnable = fields.runnable;
        this.fallbacks = fields.fallbacks;
      }
      *runnables() {
        yield this.runnable;
        for (const fallback of this.fallbacks) yield fallback;
      }
      async invoke(input, options) {
        const config2 = ensureConfig(options);
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const { runId, ...otherConfigFields } = config2;
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, void 0, void 0, void 0, otherConfigFields?.runName);
        const childConfig = patchConfig(otherConfigFields, { callbacks: runManager?.getChild() });
        const res = await AsyncLocalStorageProviderSingleton2.runWithConfig(childConfig, async () => {
          let firstError;
          for (const runnable of this.runnables()) {
            config2?.signal?.throwIfAborted();
            try {
              const output = await runnable.invoke(input, childConfig);
              await runManager?.handleChainEnd(_coerceToDict2(output, "output"));
              return output;
            } catch (e) {
              if (firstError === void 0) firstError = e;
            }
          }
          if (firstError === void 0) throw new Error("No error stored at end of fallback.");
          await runManager?.handleChainError(firstError);
          throw firstError;
        });
        return res;
      }
      async *_streamIterator(input, options) {
        const config2 = ensureConfig(options);
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const { runId, ...otherConfigFields } = config2;
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, void 0, void 0, void 0, otherConfigFields?.runName);
        let firstError;
        let stream;
        for (const runnable of this.runnables()) {
          config2?.signal?.throwIfAborted();
          const childConfig = patchConfig(otherConfigFields, { callbacks: runManager?.getChild() });
          try {
            const originalStream = await runnable.stream(input, childConfig);
            stream = consumeAsyncIterableInContext(childConfig, originalStream);
            break;
          } catch (e) {
            if (firstError === void 0) firstError = e;
          }
        }
        if (stream === void 0) {
          const error40 = firstError ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
          await runManager?.handleChainError(error40);
          throw error40;
        }
        let output;
        try {
          for await (const chunk of stream) {
            yield chunk;
            try {
              output = output === void 0 ? output : this._concatOutputChunks(output, chunk);
            } catch {
              output = void 0;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict2(output, "output"));
      }
      async batch(inputs, options, batchOptions) {
        if (batchOptions?.returnExceptions) throw new Error("Not implemented.");
        const configList = this._getOptionsList(options ?? {}, inputs.length);
        const callbackManagers = await Promise.all(configList.map((config2) => getCallbackManagerForConfig(config2)));
        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
          const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName);
          delete configList[i].runId;
          return handleStartRes;
        }));
        let firstError;
        for (const runnable of this.runnables()) {
          configList[0].signal?.throwIfAborted();
          try {
            const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], { callbacks: runManager?.getChild() })), batchOptions);
            await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict2(outputs[i], "output"))));
            return outputs;
          } catch (e) {
            if (firstError === void 0) firstError = e;
          }
        }
        if (!firstError) throw new Error("No error stored at end of fallbacks.");
        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));
        throw firstError;
      }
    };
    RunnableAssign = class extends Runnable {
      static lc_name() {
        return "RunnableAssign";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      mapper;
      constructor(fields) {
        if (fields instanceof RunnableMap) fields = { mapper: fields };
        super(fields);
        this.mapper = fields.mapper;
      }
      async invoke(input, options) {
        const mapperResult = await this.mapper.invoke(input, options);
        return {
          ...input,
          ...mapperResult
        };
      }
      async *_transform(generator, runManager, options) {
        const mapperKeys = this.mapper.getStepsKeys();
        const [forPassthrough, forMapper] = atee(generator);
        const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));
        const firstMapperChunkPromise = mapperOutput.next();
        for await (const chunk of forPassthrough) {
          if (typeof chunk !== "object" || Array.isArray(chunk)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
          const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
          if (Object.keys(filtered).length > 0) yield filtered;
        }
        yield (await firstMapperChunkPromise).value;
        for await (const chunk of mapperOutput) yield chunk;
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config2 = ensureConfig(options);
        const wrappedGenerator = new AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config2),
          config: config2
        });
        await wrappedGenerator.setup;
        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    RunnablePick = class extends Runnable {
      static lc_name() {
        return "RunnablePick";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      keys;
      constructor(fields) {
        if (typeof fields === "string" || Array.isArray(fields)) fields = { keys: fields };
        super(fields);
        this.keys = fields.keys;
      }
      async _pick(input) {
        if (typeof this.keys === "string") return input[this.keys];
        else {
          const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== void 0);
          return picked.length === 0 ? void 0 : Object.fromEntries(picked);
        }
      }
      async invoke(input, options) {
        return this._callWithConfig(this._pick.bind(this), input, options);
      }
      async *_transform(generator) {
        for await (const chunk of generator) {
          const picked = await this._pick(chunk);
          if (picked !== void 0) yield picked;
        }
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config2 = ensureConfig(options);
        const wrappedGenerator = new AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config2),
          config: config2
        });
        await wrappedGenerator.setup;
        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    RunnableToolLike = class extends RunnableBinding {
      name;
      description;
      schema;
      constructor(fields) {
        const sequence = RunnableSequence.from([RunnableLambda.from(async (input) => {
          let toolInput;
          if (_isToolCall(input)) try {
            toolInput = await interopParseAsync(this.schema, input.args);
          } catch {
            throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
          }
          else toolInput = input;
          return toolInput;
        }).withConfig({ runName: `${fields.name}:parse_input` }), fields.bound]).withConfig({ runName: fields.name });
        super({
          bound: sequence,
          config: fields.config ?? {}
        });
        this.name = fields.name;
        this.description = fields.description;
        this.schema = fields.schema;
      }
      static lc_name() {
        return "RunnableToolLike";
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/transformers.js
function filterMessages(messagesOrOptions, options) {
  if (Array.isArray(messagesOrOptions)) return _filterMessages(messagesOrOptions, options);
  return RunnableLambda.from((input) => {
    return _filterMessages(input, messagesOrOptions);
  });
}
function _filterMessages(messages, options = {}) {
  const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds } = options;
  const filtered = [];
  for (const msg of messages) {
    if (excludeNames && msg.name && excludeNames.includes(msg.name)) continue;
    else if (excludeTypes && _isMessageType(msg, excludeTypes)) continue;
    else if (excludeIds && msg.id && excludeIds.includes(msg.id)) continue;
    if (!(includeTypes || includeIds || includeNames)) filtered.push(msg);
    else if (includeNames && msg.name && includeNames.some((iName) => iName === msg.name)) filtered.push(msg);
    else if (includeTypes && _isMessageType(msg, includeTypes)) filtered.push(msg);
    else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) filtered.push(msg);
  }
  return filtered;
}
function mergeMessageRuns(messages) {
  if (Array.isArray(messages)) return _mergeMessageRuns(messages);
  return RunnableLambda.from(_mergeMessageRuns);
}
function _mergeMessageRuns(messages) {
  if (!messages.length) return [];
  const merged = [];
  for (const msg of messages) {
    const curr = msg;
    const last = merged.pop();
    if (!last) merged.push(curr);
    else if (curr.getType() === "tool" || !(curr.getType() === last.getType())) merged.push(last, curr);
    else {
      const lastChunk = convertToChunk(last);
      const currChunk = convertToChunk(curr);
      const mergedChunks = lastChunk.concat(currChunk);
      if (typeof lastChunk.content === "string" && typeof currChunk.content === "string") mergedChunks.content = `${lastChunk.content}
${currChunk.content}`;
      merged.push(_chunkToMsg(mergedChunks));
    }
  }
  return merged;
}
function trimMessages(messagesOrOptions, options) {
  if (Array.isArray(messagesOrOptions)) {
    const messages = messagesOrOptions;
    if (!options) throw new Error("Options parameter is required when providing messages.");
    return _trimMessagesHelper(messages, options);
  } else {
    const trimmerOptions = messagesOrOptions;
    return RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({ runName: "trim_messages" });
  }
}
async function _trimMessagesHelper(messages, options) {
  const { maxTokens, tokenCounter, strategy = "last", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter } = options;
  if (startOn && strategy === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
  if (includeSystem && strategy === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
  let listTokenCounter;
  if ("getNumTokens" in tokenCounter) listTokenCounter = async (msgs) => {
    const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));
    return tokenCounts.reduce((sum, count) => sum + count, 0);
  };
  else listTokenCounter = async (msgs) => tokenCounter(msgs);
  let textSplitterFunc = defaultTextSplitter;
  if (textSplitter) if ("splitText" in textSplitter) textSplitterFunc = textSplitter.splitText;
  else textSplitterFunc = async (text2) => textSplitter(text2);
  if (strategy === "first") return _firstMaxTokens(messages, {
    maxTokens,
    tokenCounter: listTokenCounter,
    textSplitter: textSplitterFunc,
    partialStrategy: allowPartial ? "first" : void 0,
    endOn
  });
  else if (strategy === "last") return _lastMaxTokens(messages, {
    maxTokens,
    tokenCounter: listTokenCounter,
    textSplitter: textSplitterFunc,
    allowPartial,
    includeSystem,
    startOn,
    endOn
  });
  else throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);
}
async function _firstMaxTokens(messages, options) {
  const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;
  let messagesCopy = [...messages];
  let idx = 0;
  for (let i = 0; i < messagesCopy.length; i += 1) {
    const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;
    if (await tokenCounter(remainingMessages) <= maxTokens) {
      idx = messagesCopy.length - i;
      break;
    }
  }
  if (idx < messagesCopy.length && partialStrategy) {
    let includedPartial = false;
    if (Array.isArray(messagesCopy[idx].content)) {
      const excluded = messagesCopy[idx];
      if (typeof excluded.content === "string") throw new Error("Expected content to be an array.");
      const numBlock = excluded.content.length;
      const reversedContent = partialStrategy === "last" ? [...excluded.content].reverse() : excluded.content;
      for (let i = 1; i <= numBlock; i += 1) {
        const partialContent = partialStrategy === "first" ? reversedContent.slice(0, i) : reversedContent.slice(-i);
        const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== "type" && !k.startsWith("lc_")));
        const updatedMessage = _switchTypeToMessage(excluded.getType(), {
          ...fields,
          content: partialContent
        });
        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];
        if (await tokenCounter(slicedMessages) <= maxTokens) {
          messagesCopy = slicedMessages;
          idx += 1;
          includedPartial = true;
        } else break;
      }
      if (includedPartial && partialStrategy === "last") excluded.content = [...reversedContent].reverse();
    }
    if (!includedPartial) {
      const excluded = messagesCopy[idx];
      let text2;
      if (Array.isArray(excluded.content) && excluded.content.some((block) => typeof block === "string" || block.type === "text")) {
        const textBlock = excluded.content.find((block) => block.type === "text" && block.text);
        text2 = textBlock?.text;
      } else if (typeof excluded.content === "string") text2 = excluded.content;
      if (text2) {
        const splitTexts = await textSplitter(text2);
        const numSplits = splitTexts.length;
        if (partialStrategy === "last") splitTexts.reverse();
        for (let _ = 0; _ < numSplits - 1; _ += 1) {
          splitTexts.pop();
          excluded.content = splitTexts.join("");
          if (await tokenCounter([...messagesCopy.slice(0, idx), excluded]) <= maxTokens) {
            if (partialStrategy === "last") excluded.content = [...splitTexts].reverse().join("");
            messagesCopy = [...messagesCopy.slice(0, idx), excluded];
            idx += 1;
            break;
          }
        }
      }
    }
  }
  if (endOn) {
    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];
    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) idx -= 1;
  }
  return messagesCopy.slice(0, idx);
}
async function _lastMaxTokens(messages, options) {
  const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;
  let messagesCopy = messages.map((message) => {
    const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== "type" && !k.startsWith("lc_")));
    return _switchTypeToMessage(message.getType(), fields, isBaseMessageChunk(message));
  });
  if (endOn) {
    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];
    while (messagesCopy.length > 0 && !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) messagesCopy = messagesCopy.slice(0, -1);
  }
  const swappedSystem = includeSystem && messagesCopy[0]?.getType() === "system";
  let reversed_ = swappedSystem ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse()) : messagesCopy.reverse();
  reversed_ = await _firstMaxTokens(reversed_, {
    ...rest,
    partialStrategy: allowPartial ? "last" : void 0,
    endOn: startOn
  });
  if (swappedSystem) return [reversed_[0], ...reversed_.slice(1).reverse()];
  else return reversed_.reverse();
}
function _switchTypeToMessage(messageType, fields, returnChunk) {
  let chunk;
  let msg;
  switch (messageType) {
    case "human":
      if (returnChunk) chunk = new HumanMessageChunk(fields);
      else msg = new HumanMessage(fields);
      break;
    case "ai":
      if (returnChunk) {
        let aiChunkFields = { ...fields };
        if ("tool_calls" in aiChunkFields) aiChunkFields = {
          ...aiChunkFields,
          tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({
            ...tc,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(tc.args)
          }))
        };
        chunk = new AIMessageChunk(aiChunkFields);
      } else msg = new AIMessage(fields);
      break;
    case "system":
      if (returnChunk) chunk = new SystemMessageChunk(fields);
      else msg = new SystemMessage(fields);
      break;
    case "developer":
      if (returnChunk) chunk = new SystemMessageChunk({
        ...fields,
        additional_kwargs: {
          ...fields.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      else msg = new SystemMessage({
        ...fields,
        additional_kwargs: {
          ...fields.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      break;
    case "tool":
      if ("tool_call_id" in fields) if (returnChunk) chunk = new ToolMessageChunk(fields);
      else msg = new ToolMessage(fields);
      else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
      break;
    case "function":
      if (returnChunk) chunk = new FunctionMessageChunk(fields);
      else {
        if (!fields.name) throw new Error("FunctionMessage must have a 'name' field");
        msg = new FunctionMessage(fields);
      }
      break;
    case "generic":
      if ("role" in fields) if (returnChunk) chunk = new ChatMessageChunk(fields);
      else msg = new ChatMessage(fields);
      else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
      break;
    default:
      throw new Error(`Unrecognized message type ${messageType}`);
  }
  if (returnChunk && chunk) return chunk;
  if (msg) return msg;
  throw new Error(`Unrecognized message type ${messageType}`);
}
function _chunkToMsg(chunk) {
  const chunkType = chunk.getType();
  let msg;
  const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => !["type", "tool_call_chunks"].includes(k) && !k.startsWith("lc_")));
  if (chunkType in _MSG_CHUNK_MAP) msg = _switchTypeToMessage(chunkType, fields);
  if (!msg) throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);
  return msg;
}
function defaultTextSplitter(text2) {
  const splits = text2.split("\n");
  return Promise.resolve([...splits.slice(0, -1).map((s) => `${s}
`), splits[splits.length - 1]]);
}
var _isMessageType, _MSG_CHUNK_MAP;
var init_transformers = __esm({
  "node_modules/@langchain/core/dist/messages/transformers.js"() {
    init_base();
    init_tool();
    init_chat();
    init_function();
    init_human();
    init_modifier();
    init_system();
    init_utils3();
    init_ai();
    init_base4();
    _isMessageType = (msg, types) => {
      const typesAsStrings = [...new Set(types?.map((t) => {
        if (typeof t === "string") return t;
        const instantiatedMsgClass = new t({});
        if (!("getType" in instantiatedMsgClass) || typeof instantiatedMsgClass.getType !== "function") throw new Error("Invalid type provided.");
        return instantiatedMsgClass.getType();
      }))];
      const msgType = msg.getType();
      return typesAsStrings.some((t) => t === msgType);
    };
    _MSG_CHUNK_MAP = {
      human: {
        message: HumanMessage,
        messageChunk: HumanMessageChunk
      },
      ai: {
        message: AIMessage,
        messageChunk: AIMessageChunk
      },
      system: {
        message: SystemMessage,
        messageChunk: SystemMessageChunk
      },
      developer: {
        message: SystemMessage,
        messageChunk: SystemMessageChunk
      },
      tool: {
        message: ToolMessage,
        messageChunk: ToolMessageChunk
      },
      function: {
        message: FunctionMessage,
        messageChunk: FunctionMessageChunk
      },
      generic: {
        message: ChatMessage,
        messageChunk: ChatMessageChunk
      },
      remove: {
        message: RemoveMessage,
        messageChunk: RemoveMessage
      }
    };
  }
});

// node_modules/@langchain/core/dist/messages/content/tools.js
var KNOWN_BLOCK_TYPES;
var init_tools = __esm({
  "node_modules/@langchain/core/dist/messages/content/tools.js"() {
    KNOWN_BLOCK_TYPES = [
      "tool_call",
      "tool_call_chunk",
      "invalid_tool_call",
      "server_tool_call",
      "server_tool_call_chunk",
      "server_tool_call_result"
    ];
  }
});

// node_modules/@langchain/core/dist/messages/content/multimodal.js
var KNOWN_BLOCK_TYPES2;
var init_multimodal = __esm({
  "node_modules/@langchain/core/dist/messages/content/multimodal.js"() {
    KNOWN_BLOCK_TYPES2 = [
      "image",
      "video",
      "audio",
      "text-plain",
      "file"
    ];
  }
});

// node_modules/@langchain/core/dist/messages/content/index.js
var KNOWN_BLOCK_TYPES$2;
var init_content = __esm({
  "node_modules/@langchain/core/dist/messages/content/index.js"() {
    init_tools();
    init_multimodal();
    KNOWN_BLOCK_TYPES$2 = [
      "text",
      "reasoning",
      ...KNOWN_BLOCK_TYPES,
      ...KNOWN_BLOCK_TYPES2
    ];
  }
});

// node_modules/@langchain/core/dist/messages/index.js
var messages_exports;
var init_messages2 = __esm({
  "node_modules/@langchain/core/dist/messages/index.js"() {
    init_rolldown_runtime();
    init_data();
    init_message();
    init_base();
    init_metadata();
    init_tool();
    init_chat();
    init_function();
    init_human();
    init_modifier();
    init_system();
    init_utils3();
    init_ai();
    init_transformers();
    init_content();
    messages_exports = {};
    __export2(messages_exports, {
      AIMessage: () => AIMessage,
      AIMessageChunk: () => AIMessageChunk,
      BaseMessage: () => BaseMessage,
      BaseMessageChunk: () => BaseMessageChunk,
      ChatMessage: () => ChatMessage,
      ChatMessageChunk: () => ChatMessageChunk,
      DEFAULT_MERGE_IGNORE_KEYS: () => DEFAULT_MERGE_IGNORE_KEYS,
      FunctionMessage: () => FunctionMessage,
      FunctionMessageChunk: () => FunctionMessageChunk,
      HumanMessage: () => HumanMessage,
      HumanMessageChunk: () => HumanMessageChunk,
      KNOWN_BLOCK_TYPES: () => KNOWN_BLOCK_TYPES$2,
      RemoveMessage: () => RemoveMessage,
      SystemMessage: () => SystemMessage,
      SystemMessageChunk: () => SystemMessageChunk,
      ToolMessage: () => ToolMessage,
      ToolMessageChunk: () => ToolMessageChunk,
      _isMessageFieldWithRole: () => _isMessageFieldWithRole,
      _mergeDicts: () => _mergeDicts,
      _mergeLists: () => _mergeLists,
      _mergeObj: () => _mergeObj,
      _mergeStatus: () => _mergeStatus,
      coerceMessageLikeToMessage: () => coerceMessageLikeToMessage,
      collapseToolCallChunks: () => collapseToolCallChunks,
      convertToChunk: () => convertToChunk,
      convertToOpenAIImageBlock: () => convertToOpenAIImageBlock,
      convertToProviderContentBlock: () => convertToProviderContentBlock,
      defaultTextSplitter: () => defaultTextSplitter,
      defaultToolCallParser: () => defaultToolCallParser,
      filterMessages: () => filterMessages,
      getBufferString: () => getBufferString,
      iife: () => iife2,
      isAIMessage: () => isAIMessage,
      isAIMessageChunk: () => isAIMessageChunk,
      isBase64ContentBlock: () => isBase64ContentBlock,
      isBaseMessage: () => isBaseMessage,
      isBaseMessageChunk: () => isBaseMessageChunk,
      isChatMessage: () => isChatMessage,
      isChatMessageChunk: () => isChatMessageChunk,
      isDataContentBlock: () => isDataContentBlock,
      isDirectToolOutput: () => isDirectToolOutput,
      isFunctionMessage: () => isFunctionMessage,
      isFunctionMessageChunk: () => isFunctionMessageChunk,
      isHumanMessage: () => isHumanMessage,
      isHumanMessageChunk: () => isHumanMessageChunk,
      isIDContentBlock: () => isIDContentBlock,
      isMessage: () => isMessage,
      isOpenAIToolCallArray: () => isOpenAIToolCallArray,
      isPlainTextContentBlock: () => isPlainTextContentBlock,
      isSystemMessage: () => isSystemMessage,
      isSystemMessageChunk: () => isSystemMessageChunk,
      isToolMessage: () => isToolMessage,
      isToolMessageChunk: () => isToolMessageChunk,
      isURLContentBlock: () => isURLContentBlock,
      mapChatMessagesToStoredMessages: () => mapChatMessagesToStoredMessages,
      mapStoredMessageToChatMessage: () => mapStoredMessageToChatMessage,
      mapStoredMessagesToChatMessages: () => mapStoredMessagesToChatMessages,
      mergeContent: () => mergeContent,
      mergeMessageRuns: () => mergeMessageRuns,
      mergeResponseMetadata: () => mergeResponseMetadata,
      mergeUsageMetadata: () => mergeUsageMetadata,
      parseBase64DataUrl: () => parseBase64DataUrl,
      parseMimeType: () => parseMimeType,
      trimMessages: () => trimMessages
    });
  }
});

// node_modules/@langchain/core/dist/chat_history.js
var chat_history_exports, BaseChatMessageHistory, BaseListChatMessageHistory, InMemoryChatMessageHistory;
var init_chat_history = __esm({
  "node_modules/@langchain/core/dist/chat_history.js"() {
    init_rolldown_runtime();
    init_serializable();
    init_human();
    init_ai();
    init_messages2();
    chat_history_exports = {};
    __export2(chat_history_exports, {
      BaseChatMessageHistory: () => BaseChatMessageHistory,
      BaseListChatMessageHistory: () => BaseListChatMessageHistory,
      InMemoryChatMessageHistory: () => InMemoryChatMessageHistory
    });
    BaseChatMessageHistory = class extends Serializable {
      /**
      * Add a list of messages.
      *
      * Implementations should override this method to handle bulk addition of messages
      * in an efficient manner to avoid unnecessary round-trips to the underlying store.
      *
      * @param messages - A list of BaseMessage objects to store.
      */
      async addMessages(messages) {
        for (const message of messages) await this.addMessage(message);
      }
    };
    BaseListChatMessageHistory = class extends Serializable {
      /**
      * This is a convenience method for adding a human message string to the store.
      * Please note that this is a convenience method. Code should favor the
      * bulk addMessages interface instead to save on round-trips to the underlying
      * persistence layer.
      * This method may be deprecated in a future release.
      */
      addUserMessage(message) {
        return this.addMessage(new HumanMessage(message));
      }
      /**
      * This is a convenience method for adding an AI message string to the store.
      * Please note that this is a convenience method. Code should favor the bulk
      * addMessages interface instead to save on round-trips to the underlying
      * persistence layer.
      * This method may be deprecated in a future release.
      */
      addAIMessage(message) {
        return this.addMessage(new AIMessage(message));
      }
      /**
      * Add a list of messages.
      *
      * Implementations should override this method to handle bulk addition of messages
      * in an efficient manner to avoid unnecessary round-trips to the underlying store.
      *
      * @param messages - A list of BaseMessage objects to store.
      */
      async addMessages(messages) {
        for (const message of messages) await this.addMessage(message);
      }
      /**
      * Remove all messages from the store.
      */
      clear() {
        throw new Error("Not implemented.");
      }
    };
    InMemoryChatMessageHistory = class extends BaseListChatMessageHistory {
      lc_namespace = [
        "langchain",
        "stores",
        "message",
        "in_memory"
      ];
      messages = [];
      constructor(messages) {
        super(...arguments);
        this.messages = messages ?? [];
      }
      /**
      * Method to get all the messages stored in the ChatMessageHistory
      * instance.
      * @returns Array of stored BaseMessage instances.
      */
      async getMessages() {
        return this.messages;
      }
      /**
      * Method to add a new message to the ChatMessageHistory instance.
      * @param message The BaseMessage instance to add.
      * @returns A promise that resolves when the message has been added.
      */
      async addMessage(message) {
        this.messages.push(message);
      }
      /**
      * Method to clear all the messages from the ChatMessageHistory instance.
      * @returns A promise that resolves when all messages have been cleared.
      */
      async clear() {
        this.messages = [];
      }
    };
  }
});

// node_modules/@langchain/core/dist/embeddings.js
var embeddings_exports, Embeddings;
var init_embeddings = __esm({
  "node_modules/@langchain/core/dist/embeddings.js"() {
    init_rolldown_runtime();
    init_async_caller2();
    embeddings_exports = {};
    __export2(embeddings_exports, { Embeddings: () => Embeddings });
    Embeddings = class {
      /**
      * The async caller should be used by subclasses to make any async calls,
      * which will thus benefit from the concurrency and retry logic.
      */
      caller;
      constructor(params) {
        this.caller = new AsyncCaller2(params ?? {});
      }
    };
  }
});

// node_modules/@langchain/core/dist/index.js
var src_exports;
var init_dist2 = __esm({
  "node_modules/@langchain/core/dist/index.js"() {
    src_exports = {};
  }
});

// node_modules/@langchain/core/dist/memory.js
function getPromptInputKey(inputs, memoryVariables) {
  const promptInputKeys = Object.keys(inputs).filter((key) => !memoryVariables.includes(key) && key !== "stop");
  if (promptInputKeys.length !== 1) throw new Error(`One input key expected, but got ${promptInputKeys.length}`);
  return promptInputKeys[0];
}
var memory_exports, BaseMemory, getValue, getInputValue, getOutputValue;
var init_memory = __esm({
  "node_modules/@langchain/core/dist/memory.js"() {
    init_rolldown_runtime();
    memory_exports = {};
    __export2(memory_exports, {
      BaseMemory: () => BaseMemory,
      getInputValue: () => getInputValue,
      getOutputValue: () => getOutputValue,
      getPromptInputKey: () => getPromptInputKey
    });
    BaseMemory = class {
    };
    getValue = (values, key) => {
      if (key !== void 0) return values[key];
      const keys = Object.keys(values);
      if (keys.length === 1) return values[keys[0]];
    };
    getInputValue = (inputValues, inputKey) => {
      const value = getValue(inputValues, inputKey);
      if (!value) {
        const keys = Object.keys(inputValues);
        throw new Error(`input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`);
      }
      return value;
    };
    getOutputValue = (outputValues, outputKey) => {
      const value = getValue(outputValues, outputKey);
      if (!value && value !== "") {
        const keys = Object.keys(outputValues);
        throw new Error(`output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`);
      }
      return value;
    };
  }
});

// node_modules/@langchain/core/dist/prompt_values.js
var prompt_values_exports, BasePromptValue, StringPromptValue, ChatPromptValue, ImagePromptValue;
var init_prompt_values = __esm({
  "node_modules/@langchain/core/dist/prompt_values.js"() {
    init_rolldown_runtime();
    init_serializable();
    init_human();
    init_utils3();
    prompt_values_exports = {};
    __export2(prompt_values_exports, {
      BasePromptValue: () => BasePromptValue,
      ChatPromptValue: () => ChatPromptValue,
      ImagePromptValue: () => ImagePromptValue,
      StringPromptValue: () => StringPromptValue
    });
    BasePromptValue = class extends Serializable {
    };
    StringPromptValue = class extends BasePromptValue {
      static lc_name() {
        return "StringPromptValue";
      }
      lc_namespace = ["langchain_core", "prompt_values"];
      lc_serializable = true;
      value;
      constructor(value) {
        super({ value });
        this.value = value;
      }
      toString() {
        return this.value;
      }
      toChatMessages() {
        return [new HumanMessage(this.value)];
      }
    };
    ChatPromptValue = class extends BasePromptValue {
      lc_namespace = ["langchain_core", "prompt_values"];
      lc_serializable = true;
      static lc_name() {
        return "ChatPromptValue";
      }
      messages;
      constructor(fields) {
        if (Array.isArray(fields)) fields = { messages: fields };
        super(fields);
        this.messages = fields.messages;
      }
      toString() {
        return getBufferString(this.messages);
      }
      toChatMessages() {
        return this.messages;
      }
    };
    ImagePromptValue = class extends BasePromptValue {
      lc_namespace = ["langchain_core", "prompt_values"];
      lc_serializable = true;
      static lc_name() {
        return "ImagePromptValue";
      }
      imageUrl;
      /** @ignore */
      value;
      constructor(fields) {
        if (!("imageUrl" in fields)) fields = { imageUrl: fields };
        super(fields);
        this.imageUrl = fields.imageUrl;
      }
      toString() {
        return this.imageUrl.url;
      }
      toChatMessages() {
        return [new HumanMessage({ content: [{
          type: "image_url",
          image_url: {
            detail: this.imageUrl.detail,
            url: this.imageUrl.url
          }
        }] })];
      }
    };
  }
});

// node_modules/@langchain/core/dist/stores.js
var stores_exports, BaseStore, InMemoryStore;
var init_stores = __esm({
  "node_modules/@langchain/core/dist/stores.js"() {
    init_rolldown_runtime();
    init_serializable();
    stores_exports = {};
    __export2(stores_exports, {
      BaseStore: () => BaseStore,
      InMemoryStore: () => InMemoryStore
    });
    BaseStore = class extends Serializable {
    };
    InMemoryStore = class extends BaseStore {
      lc_namespace = ["langchain", "storage"];
      store = {};
      /**
      * Retrieves the values associated with the given keys from the store.
      * @param keys Keys to retrieve values for.
      * @returns Array of values associated with the given keys.
      */
      async mget(keys) {
        return keys.map((key) => this.store[key]);
      }
      /**
      * Sets the values for the given keys in the store.
      * @param keyValuePairs Array of key-value pairs to set in the store.
      * @returns Promise that resolves when all key-value pairs have been set.
      */
      async mset(keyValuePairs) {
        for (const [key, value] of keyValuePairs) this.store[key] = value;
      }
      /**
      * Deletes the given keys and their associated values from the store.
      * @param keys Keys to delete from the store.
      * @returns Promise that resolves when all keys have been deleted.
      */
      async mdelete(keys) {
        for (const key of keys) delete this.store[key];
      }
      /**
      * Asynchronous generator that yields keys from the store. If a prefix is
      * provided, it only yields keys that start with the prefix.
      * @param prefix Optional prefix to filter keys.
      * @returns AsyncGenerator that yields keys from the store.
      */
      async *yieldKeys(prefix) {
        const keys = Object.keys(this.store);
        for (const key of keys) if (prefix === void 0 || key.startsWith(prefix)) yield key;
      }
    };
  }
});

// node_modules/@langchain/core/dist/retrievers/index.js
var retrievers_exports, BaseRetriever;
var init_retrievers = __esm({
  "node_modules/@langchain/core/dist/retrievers/index.js"() {
    init_rolldown_runtime();
    init_manager();
    init_config();
    init_base4();
    retrievers_exports = {};
    __export2(retrievers_exports, { BaseRetriever: () => BaseRetriever });
    BaseRetriever = class extends Runnable {
      /**
      * Optional callbacks to handle various events in the retrieval process.
      */
      callbacks;
      /**
      * Tags to label or categorize the retrieval operation.
      */
      tags;
      /**
      * Metadata to provide additional context or information about the retrieval
      * operation.
      */
      metadata;
      /**
      * If set to `true`, enables verbose logging for the retrieval process.
      */
      verbose;
      /**
      * Constructs a new `BaseRetriever` instance with optional configuration fields.
      *
      * @param fields - Optional input configuration that can include `callbacks`,
      *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.
      */
      constructor(fields) {
        super(fields);
        this.callbacks = fields?.callbacks;
        this.tags = fields?.tags ?? [];
        this.metadata = fields?.metadata ?? {};
        this.verbose = fields?.verbose ?? false;
      }
      /**
      * TODO: This should be an abstract method, but we'd like to avoid breaking
      * changes to people currently using subclassed custom retrievers.
      * Change it on next major release.
      */
      /**
      * Placeholder method for retrieving relevant documents based on a query.
      *
      * This method is intended to be implemented by subclasses and will be
      * converted to an abstract method in the next major release. Currently, it
      * throws an error if not implemented, ensuring that custom retrievers define
      * the specific retrieval logic.
      *
      * @param _query - The query string used to search for relevant documents.
      * @param _callbacks - (optional) Callback manager for managing callbacks
      *                     during retrieval.
      * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.
      * @throws {Error} Throws an error indicating the method is not implemented.
      */
      _getRelevantDocuments(_query, _callbacks) {
        throw new Error("Not implemented!");
      }
      /**
      * Executes a retrieval operation.
      *
      * @param input - The query string used to search for relevant documents.
      * @param options - (optional) Configuration options for the retrieval run,
      *                  which may include callbacks, tags, and metadata.
      * @returns A promise that resolves to an array of `DocumentInterface` instances
      *          representing the most relevant documents to the query.
      */
      async invoke(input, options) {
        const parsedConfig = ensureConfig(parseCallbackConfigArg(options));
        const callbackManager_ = await CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });
        const runManager = await callbackManager_?.handleRetrieverStart(this.toJSON(), input, parsedConfig.runId, void 0, void 0, void 0, parsedConfig.runName);
        try {
          const results = await this._getRelevantDocuments(input, runManager);
          await runManager?.handleRetrieverEnd(results);
          return results;
        } catch (error40) {
          await runManager?.handleRetrieverError(error40);
          throw error40;
        }
      }
    };
  }
});

// node_modules/@langchain/core/dist/vectorstores.js
var vectorstores_exports, VectorStoreRetriever, VectorStore, SaveableVectorStore;
var init_vectorstores = __esm({
  "node_modules/@langchain/core/dist/vectorstores.js"() {
    init_rolldown_runtime();
    init_serializable();
    init_retrievers();
    vectorstores_exports = {};
    __export2(vectorstores_exports, {
      SaveableVectorStore: () => SaveableVectorStore,
      VectorStore: () => VectorStore,
      VectorStoreRetriever: () => VectorStoreRetriever
    });
    VectorStoreRetriever = class extends BaseRetriever {
      static lc_name() {
        return "VectorStoreRetriever";
      }
      get lc_namespace() {
        return ["langchain_core", "vectorstores"];
      }
      /**
      * The instance of `VectorStore` used for storing and retrieving document embeddings.
      * This vector store must implement the `VectorStoreInterface` to be compatible
      * with the retrievers operations.
      */
      vectorStore;
      /**
      * Specifies the number of documents to retrieve for each search query.
      * Defaults to 4 if not specified, providing a basic result count for similarity or MMR searches.
      */
      k = 4;
      /**
      * Determines the type of search operation to perform on the vector store.
      *
      * - `"similarity"` (default): Conducts a similarity search based purely on vector similarity
      *   to the query.
      * - `"mmr"`: Executes a maximal marginal relevance (MMR) search, balancing relevance and
      *   diversity in the retrieved results.
      */
      searchType = "similarity";
      /**
      * Additional options specific to maximal marginal relevance (MMR) search, applicable
      * only if `searchType` is set to `"mmr"`.
      *
      * Includes:
      * - `fetchK`: The initial number of documents fetched before applying the MMR algorithm,
      *   allowing for a larger selection from which to choose the most diverse results.
      * - `lambda`: A parameter between 0 and 1 to adjust the relevance-diversity balance,
      *   where 0 prioritizes diversity and 1 prioritizes relevance.
      */
      searchKwargs;
      /**
      * Optional filter applied to search results, defined by the `FilterType` of the vector store.
      * Allows for refined, targeted results by restricting the returned documents based
      * on specified filter criteria.
      */
      filter;
      /**
      * Returns the type of vector store, as defined by the `vectorStore` instance.
      *
      * @returns {string} The vector store type.
      */
      _vectorstoreType() {
        return this.vectorStore._vectorstoreType();
      }
      /**
      * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.
      *
      * This constructor configures the retriever to interact with a given `VectorStore`
      * and supports different retrieval strategies, including similarity search and maximal
      * marginal relevance (MMR) search. Various options allow customization of the number
      * of documents retrieved per query, filtering based on conditions, and fine-tuning
      * MMR-specific parameters.
      *
      * @param fields - Configuration options for setting up the retriever:
      *
      *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`
      *     that will be used to store and retrieve document embeddings. This is the core component
      *     of the retriever, enabling vector-based similarity and MMR searches.
      *
      *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not
      *     provided, defaults to 4. This count determines the number of most relevant documents returned
      *     for each search operation, balancing performance with comprehensiveness.
      *
      *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for
      *     flexibility between two methods:
      *       - `"similarity"` (default): A similarity-based search, retrieving documents with high vector
      *         similarity to the query. This type prioritizes relevance and is often used when diversity
      *         among results is less critical.
      *       - `"mmr"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR
      *         is useful for scenarios where varied content is essential, as it selects results that
      *         both match the query and introduce content diversity.
      *
      *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows
      *     for refined and targeted search results. This filter applies specified conditions to limit
      *     which documents are eligible for retrieval, offering control over the scope of results.
      *
      *   - `searchKwargs` (optional, applicable only if `searchType` is `"mmr"`): Additional settings
      *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR
      *     search process:
      *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR
      *         algorithm is applied. Fetching a larger set enables the algorithm to select a more
      *         diverse subset of documents.
      *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes
      *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,
      *         allowing customization based on the importance of content variety relative to query relevance.
      */
      constructor(fields) {
        super(fields);
        this.vectorStore = fields.vectorStore;
        this.k = fields.k ?? this.k;
        this.searchType = fields.searchType ?? this.searchType;
        this.filter = fields.filter;
        if (fields.searchType === "mmr") this.searchKwargs = fields.searchKwargs;
      }
      /**
      * Retrieves relevant documents based on the specified query, using either
      * similarity or maximal marginal relevance (MMR) search.
      *
      * If `searchType` is set to `"mmr"`, performs an MMR search to balance
      * similarity and diversity among results. If `searchType` is `"similarity"`,
      * retrieves results purely based on similarity to the query.
      *
      * @param query - The query string used to find relevant documents.
      * @param runManager - Optional callback manager for tracking retrieval progress.
      * @returns A promise that resolves to an array of `DocumentInterface` instances
      *          representing the most relevant documents to the query.
      * @throws {Error} Throws an error if MMR search is requested but not supported
      *                 by the vector store.
      * @protected
      */
      async _getRelevantDocuments(query, runManager) {
        if (this.searchType === "mmr") {
          if (typeof this.vectorStore.maxMarginalRelevanceSearch !== "function") throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);
          return this.vectorStore.maxMarginalRelevanceSearch(query, {
            k: this.k,
            filter: this.filter,
            ...this.searchKwargs
          }, runManager?.getChild("vectorstore"));
        }
        return this.vectorStore.similaritySearch(query, this.k, this.filter, runManager?.getChild("vectorstore"));
      }
      /**
      * Adds an array of documents to the vector store, embedding them as part of
      * the storage process.
      *
      * This method delegates document embedding and storage to the `addDocuments`
      * method of the underlying vector store.
      *
      * @param documents - An array of documents to embed and add to the vector store.
      * @param options - Optional settings to customize document addition.
      * @returns A promise that resolves to an array of document IDs or `void`,
      *          depending on the vector store's implementation.
      */
      async addDocuments(documents, options) {
        return this.vectorStore.addDocuments(documents, options);
      }
    };
    VectorStore = class extends Serializable {
      /**
      * Namespace within LangChain to uniquely identify this vector store's
      * location, based on the vector store type.
      *
      * @internal
      */
      lc_namespace = [
        "langchain",
        "vectorstores",
        this._vectorstoreType()
      ];
      /**
      * Embeddings interface for generating vector embeddings from text queries,
      * enabling vector-based similarity searches.
      */
      embeddings;
      /**
      * Initializes a new vector store with embeddings and database configuration.
      *
      * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.
      * @param dbConfig - Configuration settings for the database or storage system.
      */
      constructor(embeddings, dbConfig) {
        super(dbConfig);
        this.embeddings = embeddings;
      }
      /**
      * Deletes documents from the vector store based on the specified parameters.
      *
      * @param _params - Flexible key-value pairs defining conditions for document deletion.
      * @returns A promise that resolves once the deletion is complete.
      */
      async delete(_params) {
        throw new Error("Not implemented.");
      }
      /**
      * Searches for documents similar to a text query by embedding the query and
      * performing a similarity search on the resulting vector.
      *
      * @param query - Text query for finding similar documents.
      * @param k - Number of similar results to return. Defaults to 4.
      * @param filter - Optional filter based on `FilterType`.
      * @param _callbacks - Optional callbacks for monitoring search progress
      * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.
      */
      async similaritySearch(query, k = 4, filter = void 0, _callbacks = void 0) {
        const results = await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);
        return results.map((result) => result[0]);
      }
      /**
      * Searches for documents similar to a text query by embedding the query,
      * and returns results with similarity scores.
      *
      * @param query - Text query for finding similar documents.
      * @param k - Number of similar results to return. Defaults to 4.
      * @param filter - Optional filter based on `FilterType`.
      * @param _callbacks - Optional callbacks for monitoring search progress
      * @returns A promise resolving to an array of tuples, each containing a
      *          document and its similarity score.
      */
      async similaritySearchWithScore(query, k = 4, filter = void 0, _callbacks = void 0) {
        return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);
      }
      /**
      * Creates a `VectorStore` instance from an array of text strings and optional
      * metadata, using the specified embeddings and database configuration.
      *
      * Subclasses must implement this method to define how text and metadata
      * are embedded and stored in the vector store. Throws an error if not overridden.
      *
      * @param _texts - Array of strings representing the text documents to be stored.
      * @param _metadatas - Metadata for the texts, either as an array (one for each text)
      *                     or a single object (applied to all texts).
      * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.
      * @param _dbConfig - Database configuration settings.
      * @returns A promise that resolves to a new `VectorStore` instance.
      * @throws {Error} Throws an error if this method is not overridden by a subclass.
      */
      static fromTexts(_texts, _metadatas, _embeddings, _dbConfig) {
        throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
      }
      /**
      * Creates a `VectorStore` instance from an array of documents, using the specified
      * embeddings and database configuration.
      *
      * Subclasses must implement this method to define how documents are embedded
      * and stored. Throws an error if not overridden.
      *
      * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.
      * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.
      * @param _dbConfig - Database configuration settings.
      * @returns A promise that resolves to a new `VectorStore` instance.
      * @throws {Error} Throws an error if this method is not overridden by a subclass.
      */
      static fromDocuments(_docs, _embeddings, _dbConfig) {
        throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
      }
      /**
      * Creates a `VectorStoreRetriever` instance with flexible configuration options.
      *
      * @param kOrFields
      *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).
      *    - If an object is provided, it should contain various configuration options.
      * @param filter
      *    - Optional filter criteria to limit the items retrieved based on the specified filter type.
      * @param callbacks
      *    - Optional callbacks that may be triggered at specific stages of the retrieval process.
      * @param tags
      *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.
      * @param metadata
      *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.
      * @param verbose
      *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.
      *
      * @returns
      *    - A configured `VectorStoreRetriever` instance based on the provided parameters.
      *
      * @example
      * Basic usage with a `k` value:
      * ```typescript
      * const retriever = myVectorStore.asRetriever(5);
      * ```
      *
      * Usage with a configuration object:
      * ```typescript
      * const retriever = myVectorStore.asRetriever({
      *   k: 10,
      *   filter: myFilter,
      *   tags: ['example', 'test'],
      *   verbose: true,
      *   searchType: 'mmr',
      *   searchKwargs: { alpha: 0.5 },
      * });
      * ```
      */
      asRetriever(kOrFields, filter, callbacks, tags, metadata, verbose) {
        if (typeof kOrFields === "number") return new VectorStoreRetriever({
          vectorStore: this,
          k: kOrFields,
          filter,
          tags: [...tags ?? [], this._vectorstoreType()],
          metadata,
          verbose,
          callbacks
        });
        else {
          const params = {
            vectorStore: this,
            k: kOrFields?.k,
            filter: kOrFields?.filter,
            tags: [...kOrFields?.tags ?? [], this._vectorstoreType()],
            metadata: kOrFields?.metadata,
            verbose: kOrFields?.verbose,
            callbacks: kOrFields?.callbacks,
            searchType: kOrFields?.searchType
          };
          if (kOrFields?.searchType === "mmr") return new VectorStoreRetriever({
            ...params,
            searchKwargs: kOrFields.searchKwargs
          });
          return new VectorStoreRetriever({ ...params });
        }
      }
    };
    SaveableVectorStore = class extends VectorStore {
      /**
      * Loads a vector store instance from the specified directory, using the
      * provided embeddings to ensure compatibility.
      *
      * This static method reconstructs a `SaveableVectorStore` from previously
      * saved data. Implementations should interpret the saved data format to
      * recreate the vector store instance.
      *
      * @param _directory - The directory path from which the vector store
      * data will be loaded.
      * @param _embeddings - An instance of `EmbeddingsInterface` to align
      * the embeddings with the loaded vector data.
      * @returns A promise that resolves to a `SaveableVectorStore` instance
      * constructed from the saved data.
      */
      static load(_directory, _embeddings) {
        throw new Error("Not implemented");
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/js-sha256/hash.js
function Sha256(is224, sharedMemory) {
  if (sharedMemory) {
    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    this.blocks = blocks;
  } else this.blocks = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  if (is224) {
    this.h0 = 3238371032;
    this.h1 = 914150663;
    this.h2 = 812702999;
    this.h3 = 4144912697;
    this.h4 = 4290775857;
    this.h5 = 1750603025;
    this.h6 = 1694076839;
    this.h7 = 3204075428;
  } else {
    this.h0 = 1779033703;
    this.h1 = 3144134277;
    this.h2 = 1013904242;
    this.h3 = 2773480762;
    this.h4 = 1359893119;
    this.h5 = 2600822924;
    this.h6 = 528734635;
    this.h7 = 1541459225;
  }
  this.block = this.start = this.bytes = this.hBytes = 0;
  this.finalized = this.hashed = false;
  this.first = true;
  this.is224 = is224;
}
var HEX_CHARS, EXTRA, SHIFT, K, blocks, sha256;
var init_hash = __esm({
  "node_modules/@langchain/core/dist/utils/js-sha256/hash.js"() {
    HEX_CHARS = "0123456789abcdef".split("");
    EXTRA = [
      -2147483648,
      8388608,
      32768,
      128
    ];
    SHIFT = [
      24,
      16,
      8,
      0
    ];
    K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    blocks = [];
    Sha256.prototype.update = function(message) {
      if (this.finalized) return;
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) throw new Error(ERROR);
          else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
          else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) throw new Error(ERROR);
          }
        } else throw new Error(ERROR);
        notString = true;
      }
      var code, index2 = 0, i, length = message.length, blocks$1 = this.blocks;
      while (index2 < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks$1[0] = this.block;
          this.block = blocks$1[16] = blocks$1[1] = blocks$1[2] = blocks$1[3] = blocks$1[4] = blocks$1[5] = blocks$1[6] = blocks$1[7] = blocks$1[8] = blocks$1[9] = blocks$1[10] = blocks$1[11] = blocks$1[12] = blocks$1[13] = blocks$1[14] = blocks$1[15] = 0;
        }
        if (notString) for (i = this.start; index2 < length && i < 64; ++index2) blocks$1[i >>> 2] |= message[index2] << SHIFT[i++ & 3];
        else for (i = this.start; index2 < length && i < 64; ++index2) {
          code = message.charCodeAt(index2);
          if (code < 128) blocks$1[i >>> 2] |= code << SHIFT[i++ & 3];
          else if (code < 2048) {
            blocks$1[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
          } else if (code < 55296 || code >= 57344) {
            blocks$1[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
          } else {
            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
            blocks$1[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 64) {
          this.block = blocks$1[16];
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else this.start = i;
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) return;
      this.finalized = true;
      var blocks$1 = this.blocks, i = this.lastByteIndex;
      blocks$1[16] = this.block;
      blocks$1[i >>> 2] |= EXTRA[i & 3];
      this.block = blocks$1[16];
      if (i >= 56) {
        if (!this.hashed) this.hash();
        blocks$1[0] = this.block;
        blocks$1[16] = blocks$1[1] = blocks$1[2] = blocks$1[3] = blocks$1[4] = blocks$1[5] = blocks$1[6] = blocks$1[7] = blocks$1[8] = blocks$1[9] = blocks$1[10] = blocks$1[11] = blocks$1[12] = blocks$1[13] = blocks$1[14] = blocks$1[15] = 0;
      }
      blocks$1[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks$1[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks$1 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
      for (j = 16; j < 64; ++j) {
        t1 = blocks$1[j - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks$1[j - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks$1[j] = blocks$1[j - 16] + s0 + blocks$1[j - 7] + s1 << 0;
      }
      bc = b & c;
      for (j = 0; j < 64; j += 4) {
        if (this.first) {
          if (this.is224) {
            ab = 300032;
            t1 = blocks$1[0] - 1413257819;
            h = t1 - 150054599 << 0;
            d = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks$1[0] - 210244248;
            h = t1 - 1521486534 << 0;
            d = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ab = a & b;
          maj = ab ^ a & c ^ bc;
          ch = e & f ^ ~e & g;
          t1 = h + s1 + ch + K[j] + blocks$1[j];
          t2 = s0 + maj;
          h = d + t1 << 0;
          d = t1 + t2 << 0;
        }
        s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
        s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
        da = d & a;
        maj = da ^ d & b ^ ab;
        ch = g & h ^ ~g & e;
        t1 = f + s1 + ch + K[j + 1] + blocks$1[j + 1];
        t2 = s0 + maj;
        g = c + t1 << 0;
        c = t1 + t2 << 0;
        s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
        s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
        cd = c & d;
        maj = cd ^ c & a ^ da;
        ch = f & g ^ ~f & h;
        t1 = e + s1 + ch + K[j + 2] + blocks$1[j + 2];
        t2 = s0 + maj;
        f = b + t1 << 0;
        b = t1 + t2 << 0;
        s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
        s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
        bc = b & c;
        maj = bc ^ b & d ^ cd;
        ch = f & g ^ ~f & h;
        t1 = e + s1 + ch + K[j + 3] + blocks$1[j + 3];
        t2 = s0 + maj;
        e = a + t1 << 0;
        a = t1 + t2 << 0;
        this.chromeBugWorkAround = true;
      }
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
      this.h4 = this.h4 + e << 0;
      this.h5 = this.h5 + f << 0;
      this.h6 = this.h6 + g << 0;
      this.h7 = this.h7 + h << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr3 = [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) arr3.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
      return arr3;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) dataView.setUint32(28, this.h7);
      return buffer;
    };
    sha256 = (...strings) => {
      return new Sha256(false, true).update(strings.join("")).hex();
    };
  }
});

// node_modules/@langchain/core/dist/utils/hash.js
var hash_exports;
var init_hash2 = __esm({
  "node_modules/@langchain/core/dist/utils/hash.js"() {
    init_rolldown_runtime();
    init_hash();
    hash_exports = {};
    __export2(hash_exports, { sha256: () => sha256 });
  }
});

// node_modules/@langchain/core/dist/caches/index.js
function deserializeStoredGeneration(storedGeneration) {
  if (storedGeneration.message !== void 0) return {
    text: storedGeneration.text,
    message: mapStoredMessageToChatMessage(storedGeneration.message)
  };
  else return { text: storedGeneration.text };
}
function serializeGeneration(generation) {
  const serializedValue = { text: generation.text };
  if (generation.message !== void 0) serializedValue.message = generation.message.toDict();
  return serializedValue;
}
var caches_exports, defaultHashKeyEncoder, BaseCache, GLOBAL_MAP, InMemoryCache;
var init_caches = __esm({
  "node_modules/@langchain/core/dist/caches/index.js"() {
    init_rolldown_runtime();
    init_utils3();
    init_hash();
    init_hash2();
    caches_exports = {};
    __export2(caches_exports, {
      BaseCache: () => BaseCache,
      InMemoryCache: () => InMemoryCache,
      defaultHashKeyEncoder: () => defaultHashKeyEncoder,
      deserializeStoredGeneration: () => deserializeStoredGeneration,
      serializeGeneration: () => serializeGeneration
    });
    defaultHashKeyEncoder = (...strings) => sha256(strings.join("_"));
    BaseCache = class {
      keyEncoder = defaultHashKeyEncoder;
      /**
      * Sets a custom key encoder function for the cache.
      * This function should take a prompt and an LLM key and return a string
      * that will be used as the cache key.
      * @param keyEncoderFn The custom key encoder function.
      */
      makeDefaultKeyEncoder(keyEncoderFn) {
        this.keyEncoder = keyEncoderFn;
      }
    };
    GLOBAL_MAP = /* @__PURE__ */ new Map();
    InMemoryCache = class InMemoryCache2 extends BaseCache {
      cache;
      constructor(map2) {
        super();
        this.cache = map2 ?? /* @__PURE__ */ new Map();
      }
      /**
      * Retrieves data from the cache using a prompt and an LLM key. If the
      * data is not found, it returns null.
      * @param prompt The prompt used to find the data.
      * @param llmKey The LLM key used to find the data.
      * @returns The data corresponding to the prompt and LLM key, or null if not found.
      */
      lookup(prompt, llmKey) {
        return Promise.resolve(this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null);
      }
      /**
      * Updates the cache with new data using a prompt and an LLM key.
      * @param prompt The prompt used to store the data.
      * @param llmKey The LLM key used to store the data.
      * @param value The data to be stored.
      */
      async update(prompt, llmKey, value) {
        this.cache.set(this.keyEncoder(prompt, llmKey), value);
      }
      /**
      * Returns a global instance of InMemoryCache using a predefined global
      * map as the initial cache.
      * @returns A global instance of InMemoryCache.
      */
      static global() {
        return new InMemoryCache2(GLOBAL_MAP);
      }
    };
  }
});

// node_modules/@langchain/core/dist/document_loaders/base.js
var base_exports3, BaseDocumentLoader;
var init_base5 = __esm({
  "node_modules/@langchain/core/dist/document_loaders/base.js"() {
    init_rolldown_runtime();
    base_exports3 = {};
    __export2(base_exports3, { BaseDocumentLoader: () => BaseDocumentLoader });
    BaseDocumentLoader = class {
    };
  }
});

// node_modules/@langchain/core/dist/document_loaders/langsmith.js
function _stringify(x) {
  if (typeof x === "string") return x;
  else try {
    return JSON.stringify(x, null, 2);
  } catch {
    return String(x);
  }
}
var langsmith_exports, LangSmithLoader;
var init_langsmith2 = __esm({
  "node_modules/@langchain/core/dist/document_loaders/langsmith.js"() {
    init_rolldown_runtime();
    init_base5();
    init_langsmith();
    langsmith_exports = {};
    __export2(langsmith_exports, { LangSmithLoader: () => LangSmithLoader });
    LangSmithLoader = class extends BaseDocumentLoader {
      datasetId;
      datasetName;
      exampleIds;
      asOf;
      splits;
      inlineS3Urls;
      offset;
      limit;
      metadata;
      filter;
      contentKey;
      formatContent;
      client;
      constructor(fields) {
        super();
        if (fields.client && fields.clientConfig) throw new Error("client and clientConfig cannot both be provided.");
        this.client = fields.client ?? new Client(fields?.clientConfig);
        this.contentKey = fields.contentKey ? fields.contentKey.split(".") : [];
        this.formatContent = fields.formatContent ?? _stringify;
        this.datasetId = fields.datasetId;
        this.datasetName = fields.datasetName;
        this.exampleIds = fields.exampleIds;
        this.asOf = fields.asOf;
        this.splits = fields.splits;
        this.inlineS3Urls = fields.inlineS3Urls;
        this.offset = fields.offset;
        this.limit = fields.limit;
        this.metadata = fields.metadata;
        this.filter = fields.filter;
      }
      async load() {
        const documents = [];
        for await (const example of this.client.listExamples({
          datasetId: this.datasetId,
          datasetName: this.datasetName,
          exampleIds: this.exampleIds,
          asOf: this.asOf,
          splits: this.splits,
          inlineS3Urls: this.inlineS3Urls,
          offset: this.offset,
          limit: this.limit,
          metadata: this.metadata,
          filter: this.filter
        })) {
          let content = example.inputs;
          for (const key of this.contentKey) content = content[key];
          const contentStr = this.formatContent(content);
          const metadata = example;
          ["created_at", "modified_at"].forEach((k) => {
            if (k in metadata) {
              if (typeof metadata[k] === "object") metadata[k] = metadata[k].toString();
            }
          });
          documents.push({
            pageContent: contentStr,
            metadata
          });
        }
        return documents;
      }
    };
  }
});

// node_modules/@langchain/core/dist/documents/document.js
var Document;
var init_document = __esm({
  "node_modules/@langchain/core/dist/documents/document.js"() {
    Document = class {
      pageContent;
      metadata;
      /**
      * An optional identifier for the document.
      *
      * Ideally this should be unique across the document collection and formatted
      * as a UUID, but this will not be enforced.
      */
      id;
      constructor(fields) {
        this.pageContent = fields.pageContent !== void 0 ? fields.pageContent.toString() : "";
        this.metadata = fields.metadata ?? {};
        this.id = fields.id;
      }
    };
  }
});

// node_modules/@langchain/core/dist/documents/transformers.js
var BaseDocumentTransformer, MappingDocumentTransformer;
var init_transformers2 = __esm({
  "node_modules/@langchain/core/dist/documents/transformers.js"() {
    init_base4();
    BaseDocumentTransformer = class extends Runnable {
      lc_namespace = [
        "langchain_core",
        "documents",
        "transformers"
      ];
      /**
      * Method to invoke the document transformation. This method calls the
      * transformDocuments method with the provided input.
      * @param input The input documents to be transformed.
      * @param _options Optional configuration object to customize the behavior of callbacks.
      * @returns A Promise that resolves to the transformed documents.
      */
      invoke(input, _options) {
        return this.transformDocuments(input);
      }
    };
    MappingDocumentTransformer = class extends BaseDocumentTransformer {
      async transformDocuments(documents) {
        const newDocuments = [];
        for (const document of documents) {
          const transformedDocument = await this._transformDocument(document);
          newDocuments.push(transformedDocument);
        }
        return newDocuments;
      }
    };
  }
});

// node_modules/@langchain/core/dist/documents/index.js
var documents_exports;
var init_documents = __esm({
  "node_modules/@langchain/core/dist/documents/index.js"() {
    init_rolldown_runtime();
    init_document();
    init_transformers2();
    documents_exports = {};
    __export2(documents_exports, {
      BaseDocumentTransformer: () => BaseDocumentTransformer,
      Document: () => Document,
      MappingDocumentTransformer: () => MappingDocumentTransformer
    });
  }
});

// node_modules/@langchain/core/dist/example_selectors/base.js
var BaseExampleSelector;
var init_base6 = __esm({
  "node_modules/@langchain/core/dist/example_selectors/base.js"() {
    init_serializable();
    BaseExampleSelector = class extends Serializable {
      lc_namespace = [
        "langchain_core",
        "example_selectors",
        "base"
      ];
    };
  }
});

// node_modules/@langchain/core/dist/example_selectors/conditional.js
function isLLM(llm) {
  return llm._modelType() === "base_llm";
}
function isChatModel(llm) {
  return llm._modelType() === "base_chat_model";
}
var BasePromptSelector, ConditionalPromptSelector;
var init_conditional = __esm({
  "node_modules/@langchain/core/dist/example_selectors/conditional.js"() {
    BasePromptSelector = class {
      /**
      * Asynchronous version of `getPrompt` that also accepts an options object
      * for partial variables.
      * @param llm The language model for which to get a prompt.
      * @param options Optional object for partial variables.
      * @returns A Promise that resolves to a prompt template.
      */
      async getPromptAsync(llm, options) {
        const prompt = this.getPrompt(llm);
        return prompt.partial(options?.partialVariables ?? {});
      }
    };
    ConditionalPromptSelector = class extends BasePromptSelector {
      defaultPrompt;
      conditionals;
      constructor(default_prompt, conditionals = []) {
        super();
        this.defaultPrompt = default_prompt;
        this.conditionals = conditionals;
      }
      /**
      * Method that selects a prompt based on a set of conditions. If none of
      * the conditions are met, it returns the default prompt.
      * @param llm The language model for which to get a prompt.
      * @returns A prompt template.
      */
      getPrompt(llm) {
        for (const [condition, prompt] of this.conditionals) if (condition(llm)) return prompt;
        return this.defaultPrompt;
      }
    };
  }
});

// node_modules/@langchain/core/dist/example_selectors/length_based.js
function getLengthBased(text2) {
  return text2.split(/\n| /).length;
}
var LengthBasedExampleSelector;
var init_length_based = __esm({
  "node_modules/@langchain/core/dist/example_selectors/length_based.js"() {
    init_base6();
    LengthBasedExampleSelector = class LengthBasedExampleSelector2 extends BaseExampleSelector {
      examples = [];
      examplePrompt;
      getTextLength = getLengthBased;
      maxLength = 2048;
      exampleTextLengths = [];
      constructor(data) {
        super(data);
        this.examplePrompt = data.examplePrompt;
        this.maxLength = data.maxLength ?? 2048;
        this.getTextLength = data.getTextLength ?? getLengthBased;
      }
      /**
      * Adds an example to the list of examples and calculates its length.
      * @param example The example to be added.
      * @returns Promise that resolves when the example has been added and its length calculated.
      */
      async addExample(example) {
        this.examples.push(example);
        const stringExample = await this.examplePrompt.format(example);
        this.exampleTextLengths.push(this.getTextLength(stringExample));
      }
      /**
      * Calculates the lengths of the examples.
      * @param v Array of lengths of the examples.
      * @param values Instance of LengthBasedExampleSelector.
      * @returns Promise that resolves with an array of lengths of the examples.
      */
      async calculateExampleTextLengths(v, values) {
        if (v.length > 0) return v;
        const { examples, examplePrompt } = values;
        const stringExamples = await Promise.all(examples.map((eg) => examplePrompt.format(eg)));
        return stringExamples.map((eg) => this.getTextLength(eg));
      }
      /**
      * Selects examples until the total length of the selected examples
      * reaches the maxLength.
      * @param inputVariables The input variables for the examples.
      * @returns Promise that resolves with an array of selected examples.
      */
      async selectExamples(inputVariables) {
        const inputs = Object.values(inputVariables).join(" ");
        let remainingLength = this.maxLength - this.getTextLength(inputs);
        let i = 0;
        const examples = [];
        while (remainingLength > 0 && i < this.examples.length) {
          const newLength = remainingLength - this.exampleTextLengths[i];
          if (newLength < 0) break;
          else {
            examples.push(this.examples[i]);
            remainingLength = newLength;
          }
          i += 1;
        }
        return examples;
      }
      /**
      * Creates a new instance of LengthBasedExampleSelector and adds a list of
      * examples to it.
      * @param examples Array of examples to be added.
      * @param args Input parameters for the LengthBasedExampleSelector.
      * @returns Promise that resolves with a new instance of LengthBasedExampleSelector with the examples added.
      */
      static async fromExamples(examples, args) {
        const selector = new LengthBasedExampleSelector2(args);
        await Promise.all(examples.map((eg) => selector.addExample(eg)));
        return selector;
      }
    };
  }
});

// node_modules/@langchain/core/dist/example_selectors/semantic_similarity.js
function sortedValues(values) {
  return Object.keys(values).sort().map((key) => values[key]);
}
var SemanticSimilarityExampleSelector;
var init_semantic_similarity = __esm({
  "node_modules/@langchain/core/dist/example_selectors/semantic_similarity.js"() {
    init_document();
    init_base6();
    SemanticSimilarityExampleSelector = class SemanticSimilarityExampleSelector2 extends BaseExampleSelector {
      vectorStoreRetriever;
      exampleKeys;
      inputKeys;
      constructor(data) {
        super(data);
        this.exampleKeys = data.exampleKeys;
        this.inputKeys = data.inputKeys;
        if (data.vectorStore !== void 0) this.vectorStoreRetriever = data.vectorStore.asRetriever({
          k: data.k ?? 4,
          filter: data.filter
        });
        else if (data.vectorStoreRetriever) this.vectorStoreRetriever = data.vectorStoreRetriever;
        else throw new Error(`You must specify one of "vectorStore" and "vectorStoreRetriever".`);
      }
      /**
      * Method that adds a new example to the vectorStore. The example is
      * converted to a string and added to the vectorStore as a document.
      * @param example The example to be added to the vectorStore.
      * @returns Promise that resolves when the example has been added to the vectorStore.
      */
      async addExample(example) {
        const inputKeys = this.inputKeys ?? Object.keys(example);
        const stringExample = sortedValues(inputKeys.reduce((acc, key) => ({
          ...acc,
          [key]: example[key]
        }), {})).join(" ");
        await this.vectorStoreRetriever.addDocuments([new Document({
          pageContent: stringExample,
          metadata: example
        })]);
      }
      /**
      * Method that selects which examples to use based on semantic similarity.
      * It performs a similarity search in the vectorStore using the input
      * variables and returns the examples with the highest similarity.
      * @param inputVariables The input variables used for the similarity search.
      * @returns Promise that resolves with an array of the selected examples.
      */
      async selectExamples(inputVariables) {
        const inputKeys = this.inputKeys ?? Object.keys(inputVariables);
        const query = sortedValues(inputKeys.reduce((acc, key) => ({
          ...acc,
          [key]: inputVariables[key]
        }), {})).join(" ");
        const exampleDocs = await this.vectorStoreRetriever.invoke(query);
        const examples = exampleDocs.map((doc) => doc.metadata);
        if (this.exampleKeys) return examples.map((example) => this.exampleKeys.reduce((acc, key) => ({
          ...acc,
          [key]: example[key]
        }), {}));
        return examples;
      }
      /**
      * Static method that creates a new instance of
      * SemanticSimilarityExampleSelector. It takes a list of examples, an
      * instance of Embeddings, a VectorStore class, and an options object as
      * parameters. It converts the examples to strings, creates a VectorStore
      * from the strings and the embeddings, and returns a new
      * SemanticSimilarityExampleSelector with the created VectorStore and the
      * options provided.
      * @param examples The list of examples to be used.
      * @param embeddings The instance of Embeddings to be used.
      * @param vectorStoreCls The VectorStore class to be used.
      * @param options The options object for the SemanticSimilarityExampleSelector.
      * @returns Promise that resolves with a new instance of SemanticSimilarityExampleSelector.
      */
      static async fromExamples(examples, embeddings, vectorStoreCls, options = {}) {
        const inputKeys = options.inputKeys ?? null;
        const stringExamples = examples.map((example) => sortedValues(inputKeys ? inputKeys.reduce((acc, key) => ({
          ...acc,
          [key]: example[key]
        }), {}) : example).join(" "));
        const vectorStore = await vectorStoreCls.fromTexts(stringExamples, examples, embeddings, options);
        return new SemanticSimilarityExampleSelector2({
          vectorStore,
          k: options.k ?? 4,
          exampleKeys: options.exampleKeys,
          inputKeys: options.inputKeys
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/example_selectors/index.js
var example_selectors_exports;
var init_example_selectors = __esm({
  "node_modules/@langchain/core/dist/example_selectors/index.js"() {
    init_rolldown_runtime();
    init_base6();
    init_conditional();
    init_length_based();
    init_semantic_similarity();
    example_selectors_exports = {};
    __export2(example_selectors_exports, {
      BaseExampleSelector: () => BaseExampleSelector,
      BasePromptSelector: () => BasePromptSelector,
      ConditionalPromptSelector: () => ConditionalPromptSelector,
      LengthBasedExampleSelector: () => LengthBasedExampleSelector,
      SemanticSimilarityExampleSelector: () => SemanticSimilarityExampleSelector,
      isChatModel: () => isChatModel,
      isLLM: () => isLLM
    });
  }
});

// node_modules/@langchain/core/dist/indexing/record_manager.js
var UUIDV5_NAMESPACE, RecordManager;
var init_record_manager = __esm({
  "node_modules/@langchain/core/dist/indexing/record_manager.js"() {
    init_serializable();
    UUIDV5_NAMESPACE = "10f90ea3-90a4-4962-bf75-83a0f3c1c62a";
    RecordManager = class extends Serializable {
      lc_namespace = ["langchain", "recordmanagers"];
    };
  }
});

// node_modules/@langchain/core/dist/indexing/base.js
function _batch(size, iterable) {
  const batches = [];
  let currentBatch = [];
  iterable.forEach((item) => {
    currentBatch.push(item);
    if (currentBatch.length >= size) {
      batches.push(currentBatch);
      currentBatch = [];
    }
  });
  if (currentBatch.length > 0) batches.push(currentBatch);
  return batches;
}
function _deduplicateInOrder(hashedDocuments) {
  const seen = /* @__PURE__ */ new Set();
  const deduplicated = [];
  for (const hashedDoc of hashedDocuments) {
    if (!hashedDoc.hash_) throw new Error("Hashed document does not have a hash");
    if (!seen.has(hashedDoc.hash_)) {
      seen.add(hashedDoc.hash_);
      deduplicated.push(hashedDoc);
    }
  }
  return deduplicated;
}
function _getSourceIdAssigner(sourceIdKey) {
  if (sourceIdKey === null) return (_doc) => null;
  else if (typeof sourceIdKey === "string") return (doc) => doc.metadata[sourceIdKey];
  else if (typeof sourceIdKey === "function") return sourceIdKey;
  else throw new Error(`sourceIdKey should be null, a string or a function, got ${typeof sourceIdKey}`);
}
async function index(args) {
  const { docsSource, recordManager, vectorStore, options } = args;
  const { batchSize = 100, cleanup, sourceIdKey, cleanupBatchSize = 1e3, forceUpdate = false } = options ?? {};
  if (cleanup === "incremental" && !sourceIdKey) throw new Error("sourceIdKey is required when cleanup mode is incremental. Please provide through 'options.sourceIdKey'.");
  const docs = _isBaseDocumentLoader(docsSource) ? await docsSource.load() : docsSource;
  const sourceIdAssigner = _getSourceIdAssigner(sourceIdKey ?? null);
  const indexStartDt = await recordManager.getTime();
  let numAdded = 0;
  let numDeleted = 0;
  let numUpdated = 0;
  let numSkipped = 0;
  const batches = _batch(batchSize ?? 100, docs);
  for (const batch of batches) {
    const hashedDocs = _deduplicateInOrder(batch.map((doc) => _HashedDocument.fromDocument(doc)));
    const sourceIds = hashedDocs.map((doc) => sourceIdAssigner(doc));
    if (cleanup === "incremental") hashedDocs.forEach((_hashedDoc, index$1) => {
      const source = sourceIds[index$1];
      if (source === null) throw new Error("sourceIdKey must be provided when cleanup is incremental");
    });
    const batchExists = await recordManager.exists(hashedDocs.map((doc) => doc.uid));
    const uids = [];
    const docsToIndex = [];
    const docsToUpdate = [];
    const seenDocs = /* @__PURE__ */ new Set();
    hashedDocs.forEach((hashedDoc, i) => {
      const docExists = batchExists[i];
      if (docExists) if (forceUpdate) seenDocs.add(hashedDoc.uid);
      else {
        docsToUpdate.push(hashedDoc.uid);
        return;
      }
      uids.push(hashedDoc.uid);
      docsToIndex.push(hashedDoc.toDocument());
    });
    if (docsToUpdate.length > 0) {
      await recordManager.update(docsToUpdate, { timeAtLeast: indexStartDt });
      numSkipped += docsToUpdate.length;
    }
    if (docsToIndex.length > 0) {
      await vectorStore.addDocuments(docsToIndex, { ids: uids });
      numAdded += docsToIndex.length - seenDocs.size;
      numUpdated += seenDocs.size;
    }
    await recordManager.update(hashedDocs.map((doc) => doc.uid), {
      timeAtLeast: indexStartDt,
      groupIds: sourceIds
    });
    if (cleanup === "incremental") {
      sourceIds.forEach((sourceId) => {
        if (!sourceId) throw new Error("Source id cannot be null");
      });
      const uidsToDelete = await recordManager.listKeys({
        before: indexStartDt,
        groupIds: sourceIds
      });
      if (uidsToDelete.length > 0) {
        await vectorStore.delete({ ids: uidsToDelete });
        await recordManager.deleteKeys(uidsToDelete);
        numDeleted += uidsToDelete.length;
      }
    }
  }
  if (cleanup === "full") {
    let uidsToDelete = await recordManager.listKeys({
      before: indexStartDt,
      limit: cleanupBatchSize
    });
    while (uidsToDelete.length > 0) {
      await vectorStore.delete({ ids: uidsToDelete });
      await recordManager.deleteKeys(uidsToDelete);
      numDeleted += uidsToDelete.length;
      uidsToDelete = await recordManager.listKeys({
        before: indexStartDt,
        limit: cleanupBatchSize
      });
    }
  }
  return {
    numAdded,
    numDeleted,
    numUpdated,
    numSkipped
  };
}
var _HashedDocument, _isBaseDocumentLoader;
var init_base7 = __esm({
  "node_modules/@langchain/core/dist/indexing/base.js"() {
    init_hash();
    init_hash2();
    init_document();
    init_record_manager();
    init_esm_node();
    _HashedDocument = class {
      uid;
      hash_;
      contentHash;
      metadataHash;
      pageContent;
      metadata;
      keyEncoder = sha256;
      constructor(fields) {
        this.uid = fields.uid;
        this.pageContent = fields.pageContent;
        this.metadata = fields.metadata;
      }
      makeDefaultKeyEncoder(keyEncoderFn) {
        this.keyEncoder = keyEncoderFn;
      }
      calculateHashes() {
        const forbiddenKeys = [
          "hash_",
          "content_hash",
          "metadata_hash"
        ];
        for (const key of forbiddenKeys) if (key in this.metadata) throw new Error(`Metadata cannot contain key ${key} as it is reserved for internal use. Restricted keys: [${forbiddenKeys.join(", ")}]`);
        const contentHash = this._hashStringToUUID(this.pageContent);
        try {
          const metadataHash = this._hashNestedDictToUUID(this.metadata);
          this.contentHash = contentHash;
          this.metadataHash = metadataHash;
        } catch (e) {
          throw new Error(`Failed to hash metadata: ${e}. Please use a dict that can be serialized using json.`);
        }
        this.hash_ = this._hashStringToUUID(this.contentHash + this.metadataHash);
        if (!this.uid) this.uid = this.hash_;
      }
      toDocument() {
        return new Document({
          pageContent: this.pageContent,
          metadata: this.metadata
        });
      }
      static fromDocument(document, uid) {
        const doc = new this({
          pageContent: document.pageContent,
          metadata: document.metadata,
          uid: uid || document.uid
        });
        doc.calculateHashes();
        return doc;
      }
      _hashStringToUUID(inputString) {
        const hash_value = this.keyEncoder(inputString);
        return v5_default(hash_value, UUIDV5_NAMESPACE);
      }
      _hashNestedDictToUUID(data) {
        const serialized_data = JSON.stringify(data, Object.keys(data).sort());
        const hash_value = this.keyEncoder(serialized_data);
        return v5_default(hash_value, UUIDV5_NAMESPACE);
      }
    };
    _isBaseDocumentLoader = (arg) => {
      if ("load" in arg && typeof arg.load === "function" && "loadAndSplit" in arg && typeof arg.loadAndSplit === "function") return true;
      return false;
    };
  }
});

// node_modules/@langchain/core/dist/indexing/index.js
var indexing_exports;
var init_indexing = __esm({
  "node_modules/@langchain/core/dist/indexing/index.js"() {
    init_rolldown_runtime();
    init_record_manager();
    init_base7();
    indexing_exports = {};
    __export2(indexing_exports, {
      RecordManager: () => RecordManager,
      UUIDV5_NAMESPACE: () => UUIDV5_NAMESPACE,
      _HashedDocument: () => _HashedDocument,
      _batch: () => _batch,
      _deduplicateInOrder: () => _deduplicateInOrder,
      _getSourceIdAssigner: () => _getSourceIdAssigner,
      _isBaseDocumentLoader: () => _isBaseDocumentLoader,
      index: () => index
    });
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup2 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup2[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr3 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr3[curByte++] = tmp >> 16 & 255;
        arr3[curByte++] = tmp >> 8 & 255;
        arr3[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr3[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr3[curByte++] = tmp >> 8 & 255;
        arr3[curByte++] = tmp & 255;
      }
      return arr3;
    }
    function tripletToBase64(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/js-tiktoken/dist/chunk-VL2OQCWN.js
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i) => ({ start: i, end: i + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0; i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex2(str2) {
  return str2.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
function getEncodingNameForModel(model) {
  switch (model) {
    case "gpt2": {
      return "gpt2";
    }
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003": {
      return "p50k_base";
    }
    case "code-davinci-edit-001":
    case "text-davinci-edit-001": {
      return "p50k_edit";
    }
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001": {
      return "r50k_base";
    }
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large": {
      return "cl100k_base";
    }
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest": {
      return "o200k_base";
    }
    default:
      throw new Error("Unknown model");
  }
}
var import_base64_js, __defProp3, __defNormalProp, __publicField, _Tiktoken, Tiktoken;
var init_chunk_VL2OQCWN = __esm({
  "node_modules/js-tiktoken/dist/chunk-VL2OQCWN.js"() {
    import_base64_js = __toESM(require_base64_js(), 1);
    __defProp3 = Object.defineProperty;
    __defNormalProp = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    _Tiktoken = class {
      /** @internal */
      specialTokens;
      /** @internal */
      inverseSpecialTokens;
      /** @internal */
      patStr;
      /** @internal */
      textEncoder = new TextEncoder();
      /** @internal */
      textDecoder = new TextDecoder("utf-8");
      /** @internal */
      rankMap = /* @__PURE__ */ new Map();
      /** @internal */
      textMap = /* @__PURE__ */ new Map();
      constructor(ranks, extendedSpecialTokens) {
        this.patStr = ranks.pat_str;
        const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
          const [_, offsetStr, ...tokens] = x.split(" ");
          const offset = Number.parseInt(offsetStr, 10);
          tokens.forEach((token, i) => memo[token] = offset + i);
          return memo;
        }, {});
        for (const [token, rank] of Object.entries(uncompressed)) {
          const bytes = import_base64_js.default.toByteArray(token);
          this.rankMap.set(bytes.join(","), rank);
          this.textMap.set(rank, bytes);
        }
        this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
        this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text2, rank]) => {
          memo[rank] = this.textEncoder.encode(text2);
          return memo;
        }, {});
      }
      encode(text2, allowedSpecial = [], disallowedSpecial = "all") {
        const regexes = new RegExp(this.patStr, "ug");
        const specialRegex = _Tiktoken.specialTokenRegex(
          Object.keys(this.specialTokens)
        );
        const ret = [];
        const allowedSpecialSet = new Set(
          allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
        );
        const disallowedSpecialSet = new Set(
          disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
            (x) => !allowedSpecialSet.has(x)
          ) : disallowedSpecial
        );
        if (disallowedSpecialSet.size > 0) {
          const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
            ...disallowedSpecialSet
          ]);
          const specialMatch = text2.match(disallowedSpecialRegex);
          if (specialMatch != null) {
            throw new Error(
              `The text contains a special token that is not allowed: ${specialMatch[0]}`
            );
          }
        }
        let start = 0;
        while (true) {
          let nextSpecial = null;
          let startFind = start;
          while (true) {
            specialRegex.lastIndex = startFind;
            nextSpecial = specialRegex.exec(text2);
            if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
              break;
            startFind = nextSpecial.index + 1;
          }
          const end = nextSpecial?.index ?? text2.length;
          for (const match of text2.substring(start, end).matchAll(regexes)) {
            const piece = this.textEncoder.encode(match[0]);
            const token2 = this.rankMap.get(piece.join(","));
            if (token2 != null) {
              ret.push(token2);
              continue;
            }
            ret.push(...bytePairEncode(piece, this.rankMap));
          }
          if (nextSpecial == null)
            break;
          let token = this.specialTokens[nextSpecial[0]];
          ret.push(token);
          start = nextSpecial.index + nextSpecial[0].length;
        }
        return ret;
      }
      decode(tokens) {
        const res = [];
        let length = 0;
        for (let i2 = 0; i2 < tokens.length; ++i2) {
          const token = tokens[i2];
          const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
          if (bytes != null) {
            res.push(bytes);
            length += bytes.length;
          }
        }
        const mergedArray = new Uint8Array(length);
        let i = 0;
        for (const bytes of res) {
          mergedArray.set(bytes, i);
          i += bytes.length;
        }
        return this.textDecoder.decode(mergedArray);
      }
    };
    Tiktoken = _Tiktoken;
    __publicField(Tiktoken, "specialTokenRegex", (tokens) => {
      return new RegExp(tokens.map((i) => escapeRegex2(i)).join("|"), "g");
    });
  }
});

// node_modules/js-tiktoken/dist/lite.js
var init_lite = __esm({
  "node_modules/js-tiktoken/dist/lite.js"() {
    init_chunk_VL2OQCWN();
  }
});

// node_modules/@langchain/core/dist/utils/tiktoken.js
async function getEncoding(encoding) {
  if (!(encoding in cache)) cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
    delete cache[encoding];
    throw e;
  });
  return await cache[encoding];
}
async function encodingForModel(model) {
  return getEncoding(getEncodingNameForModel(model));
}
var tiktoken_exports, cache, caller;
var init_tiktoken = __esm({
  "node_modules/@langchain/core/dist/utils/tiktoken.js"() {
    init_rolldown_runtime();
    init_async_caller2();
    init_lite();
    tiktoken_exports = {};
    __export2(tiktoken_exports, {
      encodingForModel: () => encodingForModel,
      getEncoding: () => getEncoding
    });
    cache = {};
    caller = /* @__PURE__ */ new AsyncCaller2({});
  }
});

// node_modules/@langchain/core/dist/language_models/base.js
function isOpenAITool(tool2) {
  if (typeof tool2 !== "object" || !tool2) return false;
  if ("type" in tool2 && tool2.type === "function" && "function" in tool2 && typeof tool2.function === "object" && tool2.function && "name" in tool2.function && "parameters" in tool2.function) return true;
  return false;
}
var base_exports4, getModelNameForTiktoken, getEmbeddingContextSize, getModelContextSize, calculateMaxTokens, getVerbosity, BaseLangChain, BaseLanguageModel;
var init_base8 = __esm({
  "node_modules/@langchain/core/dist/language_models/base.js"() {
    init_rolldown_runtime();
    init_utils3();
    init_async_caller2();
    init_base4();
    init_prompt_values();
    init_caches();
    init_tiktoken();
    base_exports4 = {};
    __export2(base_exports4, {
      BaseLangChain: () => BaseLangChain,
      BaseLanguageModel: () => BaseLanguageModel,
      calculateMaxTokens: () => calculateMaxTokens,
      getEmbeddingContextSize: () => getEmbeddingContextSize,
      getModelContextSize: () => getModelContextSize,
      getModelNameForTiktoken: () => getModelNameForTiktoken,
      isOpenAITool: () => isOpenAITool
    });
    getModelNameForTiktoken = (modelName) => {
      if (modelName.startsWith("gpt-5")) return "gpt-5";
      if (modelName.startsWith("gpt-3.5-turbo-16k")) return "gpt-3.5-turbo-16k";
      if (modelName.startsWith("gpt-3.5-turbo-")) return "gpt-3.5-turbo";
      if (modelName.startsWith("gpt-4-32k")) return "gpt-4-32k";
      if (modelName.startsWith("gpt-4-")) return "gpt-4";
      if (modelName.startsWith("gpt-4o")) return "gpt-4o";
      return modelName;
    };
    getEmbeddingContextSize = (modelName) => {
      switch (modelName) {
        case "text-embedding-ada-002":
          return 8191;
        default:
          return 2046;
      }
    };
    getModelContextSize = (modelName) => {
      const normalizedName = getModelNameForTiktoken(modelName);
      switch (normalizedName) {
        case "gpt-5":
        case "gpt-5-turbo":
        case "gpt-5-turbo-preview":
          return 4e5;
        case "gpt-4o":
        case "gpt-4o-mini":
        case "gpt-4o-2024-05-13":
        case "gpt-4o-2024-08-06":
          return 128e3;
        case "gpt-4-turbo":
        case "gpt-4-turbo-preview":
        case "gpt-4-turbo-2024-04-09":
        case "gpt-4-0125-preview":
        case "gpt-4-1106-preview":
          return 128e3;
        case "gpt-4-32k":
        case "gpt-4-32k-0314":
        case "gpt-4-32k-0613":
          return 32768;
        case "gpt-4":
        case "gpt-4-0314":
        case "gpt-4-0613":
          return 8192;
        case "gpt-3.5-turbo-16k":
        case "gpt-3.5-turbo-16k-0613":
          return 16384;
        case "gpt-3.5-turbo":
        case "gpt-3.5-turbo-0301":
        case "gpt-3.5-turbo-0613":
        case "gpt-3.5-turbo-1106":
        case "gpt-3.5-turbo-0125":
          return 4096;
        case "text-davinci-003":
        case "text-davinci-002":
          return 4097;
        case "text-davinci-001":
          return 2049;
        case "text-curie-001":
        case "text-babbage-001":
        case "text-ada-001":
          return 2048;
        case "code-davinci-002":
        case "code-davinci-001":
          return 8e3;
        case "code-cushman-001":
          return 2048;
        case "claude-3-5-sonnet-20241022":
        case "claude-3-5-sonnet-20240620":
        case "claude-3-opus-20240229":
        case "claude-3-sonnet-20240229":
        case "claude-3-haiku-20240307":
        case "claude-2.1":
          return 2e5;
        case "claude-2.0":
        case "claude-instant-1.2":
          return 1e5;
        case "gemini-1.5-pro":
        case "gemini-1.5-pro-latest":
        case "gemini-1.5-flash":
        case "gemini-1.5-flash-latest":
          return 1e6;
        case "gemini-pro":
        case "gemini-pro-vision":
          return 32768;
        default:
          return 4097;
      }
    };
    calculateMaxTokens = async ({ prompt, modelName }) => {
      let numTokens;
      try {
        numTokens = (await encodingForModel(getModelNameForTiktoken(modelName))).encode(prompt).length;
      } catch {
        console.warn("Failed to calculate number of tokens, falling back to approximate count");
        numTokens = Math.ceil(prompt.length / 4);
      }
      const maxTokens = getModelContextSize(modelName);
      return maxTokens - numTokens;
    };
    getVerbosity = () => false;
    BaseLangChain = class extends Runnable {
      /**
      * Whether to print out response text.
      */
      verbose;
      callbacks;
      tags;
      metadata;
      get lc_attributes() {
        return {
          callbacks: void 0,
          verbose: void 0
        };
      }
      constructor(params) {
        super(params);
        this.verbose = params.verbose ?? getVerbosity();
        this.callbacks = params.callbacks;
        this.tags = params.tags ?? [];
        this.metadata = params.metadata ?? {};
      }
    };
    BaseLanguageModel = class extends BaseLangChain {
      /**
      * Keys that the language model accepts as call options.
      */
      get callKeys() {
        return [
          "stop",
          "timeout",
          "signal",
          "tags",
          "metadata",
          "callbacks"
        ];
      }
      /**
      * The async caller should be used by subclasses to make any async calls,
      * which will thus benefit from the concurrency and retry logic.
      */
      caller;
      cache;
      constructor({ callbacks, callbackManager, ...params }) {
        const { cache: cache2, ...rest } = params;
        super({
          callbacks: callbacks ?? callbackManager,
          ...rest
        });
        if (typeof cache2 === "object") this.cache = cache2;
        else if (cache2) this.cache = InMemoryCache.global();
        else this.cache = void 0;
        this.caller = new AsyncCaller2(params ?? {});
      }
      _encoding;
      /**
      * Get the number of tokens in the content.
      * @param content The content to get the number of tokens for.
      * @returns The number of tokens in the content.
      */
      async getNumTokens(content) {
        let textContent;
        if (typeof content === "string") textContent = content;
        else
          textContent = content.map((item) => {
            if (typeof item === "string") return item;
            if (item.type === "text" && "text" in item) return item.text;
            return "";
          }).join("");
        let numTokens = Math.ceil(textContent.length / 4);
        if (!this._encoding) try {
          this._encoding = await encodingForModel("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2");
        } catch (error40) {
          console.warn("Failed to calculate number of tokens, falling back to approximate count", error40);
        }
        if (this._encoding) try {
          numTokens = this._encoding.encode(textContent).length;
        } catch (error40) {
          console.warn("Failed to calculate number of tokens, falling back to approximate count", error40);
        }
        return numTokens;
      }
      static _convertInputToPromptValue(input) {
        if (typeof input === "string") return new StringPromptValue(input);
        else if (Array.isArray(input)) return new ChatPromptValue(input.map(coerceMessageLikeToMessage));
        else return input;
      }
      /**
      * Get the identifying parameters of the LLM.
      */
      _identifyingParams() {
        return {};
      }
      /**
      * Create a unique cache key for a specific call to a specific language model.
      * @param callOptions Call options for the model
      * @returns A unique cache key.
      */
      _getSerializedCacheKeyParametersForCall({ config: config2, ...callOptions }) {
        const params = {
          ...this._identifyingParams(),
          ...callOptions,
          _type: this._llmType(),
          _model: this._modelType()
        };
        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== void 0);
        const serializedEntries = filteredEntries.map(([key, value]) => `${key}:${JSON.stringify(value)}`).sort().join(",");
        return serializedEntries;
      }
      /**
      * @deprecated
      * Return a json-like object representing this LLM.
      */
      serialize() {
        return {
          ...this._identifyingParams(),
          _type: this._llmType(),
          _model: this._modelType()
        };
      }
      /**
      * @deprecated
      * Load an LLM from a json-like object describing it.
      */
      static async deserialize(_data) {
        throw new Error("Use .toJSON() instead");
      }
      /**
      * Return profiling information for the model.
      *
      * @returns {ModelProfile} An object describing the model's capabilities and constraints
      */
      get profile() {
        return {};
      }
    };
  }
});

// node_modules/@langchain/core/dist/runnables/passthrough.js
var RunnablePassthrough;
var init_passthrough = __esm({
  "node_modules/@langchain/core/dist/runnables/passthrough.js"() {
    init_config();
    init_stream();
    init_base4();
    RunnablePassthrough = class extends Runnable {
      static lc_name() {
        return "RunnablePassthrough";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      func;
      constructor(fields) {
        super(fields);
        if (fields) this.func = fields.func;
      }
      async invoke(input, options) {
        const config2 = ensureConfig(options);
        if (this.func) await this.func(input, config2);
        return this._callWithConfig((input$1) => Promise.resolve(input$1), input, config2);
      }
      async *transform(generator, options) {
        const config2 = ensureConfig(options);
        let finalOutput;
        let finalOutputSupported = true;
        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config2)) {
          yield chunk;
          if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
          else try {
            finalOutput = concat(finalOutput, chunk);
          } catch {
            finalOutput = void 0;
            finalOutputSupported = false;
          }
        }
        if (this.func && finalOutput !== void 0) await this.func(finalOutput, config2);
      }
      /**
      * A runnable that assigns key-value pairs to the input.
      *
      * The example below shows how you could use it with an inline function.
      *
      * @example
      * ```typescript
      * const prompt =
      *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
      * Question: {question}
      * SQL Query:`);
      *
      * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
      * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
      * // In this case, we're passing the schema.
      * const sqlQueryGeneratorChain = RunnableSequence.from([
      *   RunnablePassthrough.assign({
      *     schema: async () => db.getTableInfo(),
      *   }),
      *   prompt,
      *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
      *   new StringOutputParser(),
      * ]);
      * const result = await sqlQueryGeneratorChain.invoke({
      *   question: "How many employees are there?",
      * });
      * ```
      */
      static assign(mapping) {
        return new RunnableAssign(new RunnableMap({ steps: mapping }));
      }
    };
  }
});

// node_modules/@langchain/core/dist/language_models/utils.js
function castStandardMessageContent(message) {
  const Cls = message.constructor;
  return new Cls({
    ...message,
    content: message.contentBlocks,
    response_metadata: {
      ...message.response_metadata,
      output_version: "v1"
    }
  });
}
var iife3;
var init_utils5 = __esm({
  "node_modules/@langchain/core/dist/language_models/utils.js"() {
    iife3 = (fn) => fn();
  }
});

// node_modules/@langchain/core/dist/language_models/chat_models.js
function _formatForTracing(messages) {
  const messagesToTrace = [];
  for (const message of messages) {
    let messageToTrace = message;
    if (Array.isArray(message.content)) for (let idx = 0; idx < message.content.length; idx++) {
      const block = message.content[idx];
      if (isURLContentBlock(block) || isBase64ContentBlock(block)) {
        if (messageToTrace === message) messageToTrace = new message.constructor({
          ...messageToTrace,
          content: [
            ...message.content.slice(0, idx),
            convertToOpenAIImageBlock(block),
            ...message.content.slice(idx + 1)
          ]
        });
      }
    }
    messagesToTrace.push(messageToTrace);
  }
  return messagesToTrace;
}
var chat_models_exports, BaseChatModel, SimpleChatModel;
var init_chat_models = __esm({
  "node_modules/@langchain/core/dist/language_models/chat_models.js"() {
    init_rolldown_runtime();
    init_data();
    init_base();
    init_utils3();
    init_ai();
    init_env();
    init_base2();
    init_manager();
    init_stream();
    init_outputs();
    init_zod2();
    init_json_schema2();
    init_base4();
    init_messages2();
    init_base8();
    init_passthrough();
    init_utils5();
    chat_models_exports = {};
    __export2(chat_models_exports, {
      BaseChatModel: () => BaseChatModel,
      SimpleChatModel: () => SimpleChatModel
    });
    BaseChatModel = class BaseChatModel2 extends BaseLanguageModel {
      lc_namespace = [
        "langchain",
        "chat_models",
        this._llmType()
      ];
      disableStreaming = false;
      outputVersion;
      get callKeys() {
        return [...super.callKeys, "outputVersion"];
      }
      constructor(fields) {
        super(fields);
        this.outputVersion = iife3(() => {
          const outputVersion = fields.outputVersion ?? getEnvironmentVariable("LC_OUTPUT_VERSION");
          if (outputVersion && ["v0", "v1"].includes(outputVersion)) return outputVersion;
          return "v0";
        });
      }
      _separateRunnableConfigFromCallOptionsCompat(options) {
        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
        callOptions.signal = runnableConfig.signal;
        return [runnableConfig, callOptions];
      }
      /**
      * Invokes the chat model with a single input.
      * @param input The input for the language model.
      * @param options The call options.
      * @returns A Promise that resolves to a BaseMessageChunk.
      */
      async invoke(input, options) {
        const promptValue = BaseChatModel2._convertInputToPromptValue(input);
        const result = await this.generatePrompt([promptValue], options, options?.callbacks);
        const chatGeneration = result.generations[0][0];
        return chatGeneration.message;
      }
      async *_streamResponseChunks(_messages, _options, _runManager) {
        throw new Error("Not implemented.");
      }
      async *_streamIterator(input, options) {
        if (this._streamResponseChunks === BaseChatModel2.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(input, options);
        else {
          const prompt = BaseChatModel2._convertInputToPromptValue(input);
          const messages = prompt.toChatMessages();
          const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);
          const inheritableMetadata = {
            ...runnableConfig.metadata,
            ...this.getLsParams(callOptions)
          };
          const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: callOptions,
            invocation_params: this?.invocationParams(callOptions),
            batch_size: 1
          };
          const outputVersion = callOptions.outputVersion ?? this.outputVersion;
          const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName);
          let generationChunk;
          let llmOutput;
          try {
            for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {
              if (chunk.message.id == null) {
                const runId = runManagers?.at(0)?.runId;
                if (runId != null) chunk.message._updateId(`run-${runId}`);
              }
              chunk.message.response_metadata = {
                ...chunk.generationInfo,
                ...chunk.message.response_metadata
              };
              if (outputVersion === "v1") yield castStandardMessageContent(chunk.message);
              else yield chunk.message;
              if (!generationChunk) generationChunk = chunk;
              else generationChunk = generationChunk.concat(chunk);
              if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) llmOutput = { tokenUsage: {
                promptTokens: chunk.message.usage_metadata.input_tokens,
                completionTokens: chunk.message.usage_metadata.output_tokens,
                totalTokens: chunk.message.usage_metadata.total_tokens
              } };
            }
          } catch (err) {
            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));
            throw err;
          }
          await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({
            generations: [[generationChunk]],
            llmOutput
          })));
        }
      }
      getLsParams(options) {
        const providerName = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
        return {
          ls_model_type: "chat",
          ls_stop: options.stop,
          ls_provider: providerName
        };
      }
      /** @ignore */
      async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {
        const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
        let runManagers;
        if (startedRunManagers !== void 0 && startedRunManagers.length === baseMessages.length) runManagers = startedRunManagers;
        else {
          const inheritableMetadata = {
            ...handledOptions.metadata,
            ...this.getLsParams(parsedOptions)
          };
          const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: parsedOptions,
            invocation_params: this?.invocationParams(parsedOptions),
            batch_size: 1
          };
          runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName);
        }
        const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;
        const generations = [];
        const llmOutputs = [];
        const hasStreamingHandler = !!runManagers?.[0].handlers.find(callbackHandlerPrefersStreaming);
        if (hasStreamingHandler && !this.disableStreaming && baseMessages.length === 1 && this._streamResponseChunks !== BaseChatModel2.prototype._streamResponseChunks) try {
          const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);
          let aggregated;
          let llmOutput;
          for await (const chunk of stream) {
            if (chunk.message.id == null) {
              const runId = runManagers?.at(0)?.runId;
              if (runId != null) chunk.message._updateId(`run-${runId}`);
            }
            if (aggregated === void 0) aggregated = chunk;
            else aggregated = concat(aggregated, chunk);
            if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) llmOutput = { tokenUsage: {
              promptTokens: chunk.message.usage_metadata.input_tokens,
              completionTokens: chunk.message.usage_metadata.output_tokens,
              totalTokens: chunk.message.usage_metadata.total_tokens
            } };
          }
          if (aggregated === void 0) throw new Error("Received empty response from chat model call.");
          generations.push([aggregated]);
          await runManagers?.[0].handleLLMEnd({
            generations,
            llmOutput
          });
        } catch (e) {
          await runManagers?.[0].handleLLMError(e);
          throw e;
        }
        else {
          const results = await Promise.allSettled(baseMessages.map(async (messageList, i) => {
            const generateResults = await this._generate(messageList, {
              ...parsedOptions,
              promptIndex: i
            }, runManagers?.[i]);
            if (outputVersion === "v1") for (const generation of generateResults.generations) generation.message = castStandardMessageContent(generation.message);
            return generateResults;
          }));
          await Promise.all(results.map(async (pResult, i) => {
            if (pResult.status === "fulfilled") {
              const result = pResult.value;
              for (const generation of result.generations) {
                if (generation.message.id == null) {
                  const runId = runManagers?.at(0)?.runId;
                  if (runId != null) generation.message._updateId(`run-${runId}`);
                }
                generation.message.response_metadata = {
                  ...generation.generationInfo,
                  ...generation.message.response_metadata
                };
              }
              if (result.generations.length === 1) result.generations[0].message.response_metadata = {
                ...result.llmOutput,
                ...result.generations[0].message.response_metadata
              };
              generations[i] = result.generations;
              llmOutputs[i] = result.llmOutput;
              return runManagers?.[i]?.handleLLMEnd({
                generations: [result.generations],
                llmOutput: result.llmOutput
              });
            } else {
              await runManagers?.[i]?.handleLLMError(pResult.reason);
              return Promise.reject(pResult.reason);
            }
          }));
        }
        const output = {
          generations,
          llmOutput: llmOutputs.length ? this._combineLLMOutput?.(...llmOutputs) : void 0
        };
        Object.defineProperty(output, RUN_KEY, {
          value: runManagers ? { runIds: runManagers?.map((manager) => manager.runId) } : void 0,
          configurable: true
        });
        return output;
      }
      async _generateCached({ messages, cache: cache2, llmStringKey, parsedOptions, handledOptions }) {
        const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
        const inheritableMetadata = {
          ...handledOptions.metadata,
          ...this.getLsParams(parsedOptions)
        };
        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
        const extra = {
          options: parsedOptions,
          invocation_params: this?.invocationParams(parsedOptions),
          batch_size: 1
        };
        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName);
        const missingPromptIndices = [];
        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index2) => {
          const prompt = BaseChatModel2._convertInputToPromptValue(baseMessage).toString();
          const result = await cache2.lookup(prompt, llmStringKey);
          if (result == null) missingPromptIndices.push(index2);
          return result;
        }));
        const cachedResults = results.map((result, index2) => ({
          result,
          runManager: runManagers?.[index2]
        })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
        const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;
        const generations = [];
        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {
          if (promiseResult.status === "fulfilled") {
            const result = promiseResult.value;
            generations[i] = result.map((result$1) => {
              if ("message" in result$1 && isBaseMessage(result$1.message) && isAIMessage(result$1.message)) {
                result$1.message.usage_metadata = {
                  input_tokens: 0,
                  output_tokens: 0,
                  total_tokens: 0
                };
                if (outputVersion === "v1") result$1.message = castStandardMessageContent(result$1.message);
              }
              result$1.generationInfo = {
                ...result$1.generationInfo,
                tokenUsage: {}
              };
              return result$1;
            });
            if (result.length) await runManager?.handleLLMNewToken(result[0].text);
            return runManager?.handleLLMEnd({ generations: [result] }, void 0, void 0, void 0, { cached: true });
          } else {
            await runManager?.handleLLMError(promiseResult.reason, void 0, void 0, void 0, { cached: true });
            return Promise.reject(promiseResult.reason);
          }
        }));
        const output = {
          generations,
          missingPromptIndices,
          startedRunManagers: runManagers
        };
        Object.defineProperty(output, RUN_KEY, {
          value: runManagers ? { runIds: runManagers?.map((manager) => manager.runId) } : void 0,
          configurable: true
        });
        return output;
      }
      /**
      * Generates chat based on the input messages.
      * @param messages An array of arrays of BaseMessage instances.
      * @param options The call options or an array of stop sequences.
      * @param callbacks The callbacks for the language model.
      * @returns A Promise that resolves to an LLMResult.
      */
      async generate(messages, options, callbacks) {
        let parsedOptions;
        if (Array.isArray(options)) parsedOptions = { stop: options };
        else parsedOptions = options;
        const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
        if (!this.cache) return this._generateUncached(baseMessages, callOptions, runnableConfig);
        const { cache: cache2 } = this;
        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
          messages: baseMessages,
          cache: cache2,
          llmStringKey,
          parsedOptions: callOptions,
          handledOptions: runnableConfig
        });
        let llmOutput = {};
        if (missingPromptIndices.length > 0) {
          const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i) => startedRunManagers?.[i]) : void 0);
          await Promise.all(results.generations.map(async (generation, index2) => {
            const promptIndex = missingPromptIndices[index2];
            generations[promptIndex] = generation;
            const prompt = BaseChatModel2._convertInputToPromptValue(baseMessages[promptIndex]).toString();
            return cache2.update(prompt, llmStringKey, generation);
          }));
          llmOutput = results.llmOutput ?? {};
        }
        return {
          generations,
          llmOutput
        };
      }
      /**
      * Get the parameters used to invoke the model
      */
      invocationParams(_options) {
        return {};
      }
      _modelType() {
        return "base_chat_model";
      }
      /**
      * Generates a prompt based on the input prompt values.
      * @param promptValues An array of BasePromptValue instances.
      * @param options The call options or an array of stop sequences.
      * @param callbacks The callbacks for the language model.
      * @returns A Promise that resolves to an LLMResult.
      */
      async generatePrompt(promptValues, options, callbacks) {
        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());
        return this.generate(promptMessages, options, callbacks);
      }
      withStructuredOutput(outputSchema, config2) {
        if (typeof this.bindTools !== "function") throw new Error(`Chat model must implement ".bindTools()" to use withStructuredOutput.`);
        if (config2?.strict) throw new Error(`"strict" mode is not supported for this model by default.`);
        const schema = outputSchema;
        const name = config2?.name;
        const description = getSchemaDescription(schema) ?? "A function available to call.";
        const method = config2?.method;
        const includeRaw = config2?.includeRaw;
        if (method === "jsonMode") throw new Error(`Base withStructuredOutput implementation only supports "functionCalling" as a method.`);
        let functionName = name ?? "extract";
        let tools2;
        if (isInteropZodSchema(schema)) tools2 = [{
          type: "function",
          function: {
            name: functionName,
            description,
            parameters: toJsonSchema(schema)
          }
        }];
        else {
          if ("name" in schema) functionName = schema.name;
          tools2 = [{
            type: "function",
            function: {
              name: functionName,
              description,
              parameters: schema
            }
          }];
        }
        const llm = this.bindTools(tools2);
        const outputParser = RunnableLambda.from((input) => {
          if (!AIMessageChunk.isInstance(input)) throw new Error("Input is not an AIMessageChunk.");
          if (!input.tool_calls || input.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
          const toolCall = input.tool_calls.find((tc) => tc.name === functionName);
          if (!toolCall) throw new Error(`No tool call found with name ${functionName}.`);
          return toolCall.args;
        });
        if (!includeRaw) return llm.pipe(outputParser).withConfig({ runName: "StructuredOutput" });
        const parserAssign = RunnablePassthrough.assign({ parsed: (input, config$1) => outputParser.invoke(input.raw, config$1) });
        const parserNone = RunnablePassthrough.assign({ parsed: () => null });
        const parsedWithFallback = parserAssign.withFallbacks({ fallbacks: [parserNone] });
        return RunnableSequence.from([{ raw: llm }, parsedWithFallback]).withConfig({ runName: "StructuredOutputRunnable" });
      }
    };
    SimpleChatModel = class extends BaseChatModel {
      async _generate(messages, options, runManager) {
        const text2 = await this._call(messages, options, runManager);
        const message = new AIMessage(text2);
        if (typeof message.content !== "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
        return { generations: [{
          text: message.content,
          message
        }] };
      }
    };
  }
});

// node_modules/@langchain/core/dist/language_models/llms.js
var llms_exports, BaseLLM, LLM;
var init_llms = __esm({
  "node_modules/@langchain/core/dist/language_models/llms.js"() {
    init_rolldown_runtime();
    init_base2();
    init_manager();
    init_stream();
    init_outputs();
    init_base8();
    llms_exports = {};
    __export2(llms_exports, {
      BaseLLM: () => BaseLLM,
      LLM: () => LLM
    });
    BaseLLM = class BaseLLM2 extends BaseLanguageModel {
      lc_namespace = [
        "langchain",
        "llms",
        this._llmType()
      ];
      /**
      * This method takes an input and options, and returns a string. It
      * converts the input to a prompt value and generates a result based on
      * the prompt.
      * @param input Input for the LLM.
      * @param options Options for the LLM call.
      * @returns A string result based on the prompt.
      */
      async invoke(input, options) {
        const promptValue = BaseLLM2._convertInputToPromptValue(input);
        const result = await this.generatePrompt([promptValue], options, options?.callbacks);
        return result.generations[0][0].text;
      }
      async *_streamResponseChunks(_input, _options, _runManager) {
        throw new Error("Not implemented.");
      }
      _separateRunnableConfigFromCallOptionsCompat(options) {
        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
        callOptions.signal = runnableConfig.signal;
        return [runnableConfig, callOptions];
      }
      async *_streamIterator(input, options) {
        if (this._streamResponseChunks === BaseLLM2.prototype._streamResponseChunks) yield this.invoke(input, options);
        else {
          const prompt = BaseLLM2._convertInputToPromptValue(input);
          const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);
          const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: callOptions,
            invocation_params: this?.invocationParams(callOptions),
            batch_size: 1
          };
          const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName);
          let generation = new GenerationChunk({ text: "" });
          try {
            for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {
              if (!generation) generation = chunk;
              else generation = generation.concat(chunk);
              if (typeof chunk.text === "string") yield chunk.text;
            }
          } catch (err) {
            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));
            throw err;
          }
          await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({ generations: [[generation]] })));
        }
      }
      /**
      * This method takes prompt values, options, and callbacks, and generates
      * a result based on the prompts.
      * @param promptValues Prompt values for the LLM.
      * @param options Options for the LLM call.
      * @param callbacks Callbacks for the LLM call.
      * @returns An LLMResult based on the prompts.
      */
      async generatePrompt(promptValues, options, callbacks) {
        const prompts = promptValues.map((promptValue) => promptValue.toString());
        return this.generate(prompts, options, callbacks);
      }
      /**
      * Get the parameters used to invoke the model
      */
      invocationParams(_options) {
        return {};
      }
      _flattenLLMResult(llmResult) {
        const llmResults = [];
        for (let i = 0; i < llmResult.generations.length; i += 1) {
          const genList = llmResult.generations[i];
          if (i === 0) llmResults.push({
            generations: [genList],
            llmOutput: llmResult.llmOutput
          });
          else {
            const llmOutput = llmResult.llmOutput ? {
              ...llmResult.llmOutput,
              tokenUsage: {}
            } : void 0;
            llmResults.push({
              generations: [genList],
              llmOutput
            });
          }
        }
        return llmResults;
      }
      /** @ignore */
      async _generateUncached(prompts, parsedOptions, handledOptions, startedRunManagers) {
        let runManagers;
        if (startedRunManagers !== void 0 && startedRunManagers.length === prompts.length) runManagers = startedRunManagers;
        else {
          const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: parsedOptions,
            invocation_params: this?.invocationParams(parsedOptions),
            batch_size: prompts.length
          };
          runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, void 0, extra, void 0, void 0, handledOptions?.runName);
        }
        const hasStreamingHandler = !!runManagers?.[0].handlers.find(callbackHandlerPrefersStreaming);
        let output;
        if (hasStreamingHandler && prompts.length === 1 && this._streamResponseChunks !== BaseLLM2.prototype._streamResponseChunks) try {
          const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);
          let aggregated;
          for await (const chunk of stream) if (aggregated === void 0) aggregated = chunk;
          else aggregated = concat(aggregated, chunk);
          if (aggregated === void 0) throw new Error("Received empty response from chat model call.");
          output = {
            generations: [[aggregated]],
            llmOutput: {}
          };
          await runManagers?.[0].handleLLMEnd(output);
        } catch (e) {
          await runManagers?.[0].handleLLMError(e);
          throw e;
        }
        else {
          try {
            output = await this._generate(prompts, parsedOptions, runManagers?.[0]);
          } catch (err) {
            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));
            throw err;
          }
          const flattenedOutputs = this._flattenLLMResult(output);
          await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));
        }
        const runIds = runManagers?.map((manager) => manager.runId) || void 0;
        Object.defineProperty(output, RUN_KEY, {
          value: runIds ? { runIds } : void 0,
          configurable: true
        });
        return output;
      }
      async _generateCached({ prompts, cache: cache2, llmStringKey, parsedOptions, handledOptions, runId }) {
        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
        const extra = {
          options: parsedOptions,
          invocation_params: this?.invocationParams(parsedOptions),
          batch_size: prompts.length
        };
        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, void 0, extra, void 0, void 0, handledOptions?.runName);
        const missingPromptIndices = [];
        const results = await Promise.allSettled(prompts.map(async (prompt, index2) => {
          const result = await cache2.lookup(prompt, llmStringKey);
          if (result == null) missingPromptIndices.push(index2);
          return result;
        }));
        const cachedResults = results.map((result, index2) => ({
          result,
          runManager: runManagers?.[index2]
        })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
        const generations = [];
        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {
          if (promiseResult.status === "fulfilled") {
            const result = promiseResult.value;
            generations[i] = result.map((result$1) => {
              result$1.generationInfo = {
                ...result$1.generationInfo,
                tokenUsage: {}
              };
              return result$1;
            });
            if (result.length) await runManager?.handleLLMNewToken(result[0].text);
            return runManager?.handleLLMEnd({ generations: [result] }, void 0, void 0, void 0, { cached: true });
          } else {
            await runManager?.handleLLMError(promiseResult.reason, void 0, void 0, void 0, { cached: true });
            return Promise.reject(promiseResult.reason);
          }
        }));
        const output = {
          generations,
          missingPromptIndices,
          startedRunManagers: runManagers
        };
        Object.defineProperty(output, RUN_KEY, {
          value: runManagers ? { runIds: runManagers?.map((manager) => manager.runId) } : void 0,
          configurable: true
        });
        return output;
      }
      /**
      * Run the LLM on the given prompts and input, handling caching.
      */
      async generate(prompts, options, callbacks) {
        if (!Array.isArray(prompts)) throw new Error("Argument 'prompts' is expected to be a string[]");
        let parsedOptions;
        if (Array.isArray(options)) parsedOptions = { stop: options };
        else parsedOptions = options;
        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
        if (!this.cache) return this._generateUncached(prompts, callOptions, runnableConfig);
        const { cache: cache2 } = this;
        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
          prompts,
          cache: cache2,
          llmStringKey,
          parsedOptions: callOptions,
          handledOptions: runnableConfig,
          runId: runnableConfig.runId
        });
        let llmOutput = {};
        if (missingPromptIndices.length > 0) {
          const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i) => startedRunManagers?.[i]) : void 0);
          await Promise.all(results.generations.map(async (generation, index2) => {
            const promptIndex = missingPromptIndices[index2];
            generations[promptIndex] = generation;
            return cache2.update(prompts[promptIndex], llmStringKey, generation);
          }));
          llmOutput = results.llmOutput ?? {};
        }
        return {
          generations,
          llmOutput
        };
      }
      /**
      * Get the identifying parameters of the LLM.
      */
      _identifyingParams() {
        return {};
      }
      _modelType() {
        return "base_llm";
      }
    };
    LLM = class extends BaseLLM {
      async _generate(prompts, options, runManager) {
        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, {
          ...options,
          promptIndex
        }, runManager).then((text2) => [{ text: text2 }])));
        return { generations };
      }
    };
  }
});

// node_modules/@langchain/core/dist/language_models/profile.js
var profile_exports;
var init_profile = __esm({
  "node_modules/@langchain/core/dist/language_models/profile.js"() {
    profile_exports = {};
  }
});

// node_modules/@langchain/core/dist/runnables/router.js
var RouterRunnable;
var init_router = __esm({
  "node_modules/@langchain/core/dist/runnables/router.js"() {
    init_config();
    init_base4();
    RouterRunnable = class extends Runnable {
      static lc_name() {
        return "RouterRunnable";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      runnables;
      constructor(fields) {
        super(fields);
        this.runnables = fields.runnables;
      }
      async invoke(input, options) {
        const { key, input: actualInput } = input;
        const runnable = this.runnables[key];
        if (runnable === void 0) throw new Error(`No runnable associated with key "${key}".`);
        return runnable.invoke(actualInput, ensureConfig(options));
      }
      async batch(inputs, options, batchOptions) {
        const keys = inputs.map((input) => input.key);
        const actualInputs = inputs.map((input) => input.input);
        const missingKey = keys.find((key) => this.runnables[key] === void 0);
        if (missingKey !== void 0) throw new Error(`One or more keys do not have a corresponding runnable.`);
        const runnables = keys.map((key) => this.runnables[key]);
        const optionsList = this._getOptionsList(options ?? {}, inputs.length);
        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;
        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;
        const batchResults = [];
        for (let i = 0; i < actualInputs.length; i += batchSize) {
          const batchPromises = actualInputs.slice(i, i + batchSize).map((actualInput, i$1) => runnables[i$1].invoke(actualInput, optionsList[i$1]));
          const batchResult = await Promise.all(batchPromises);
          batchResults.push(batchResult);
        }
        return batchResults.flat();
      }
      async stream(input, options) {
        const { key, input: actualInput } = input;
        const runnable = this.runnables[key];
        if (runnable === void 0) throw new Error(`No runnable associated with key "${key}".`);
        return runnable.stream(actualInput, options);
      }
    };
  }
});

// node_modules/@langchain/core/dist/runnables/branch.js
var RunnableBranch;
var init_branch = __esm({
  "node_modules/@langchain/core/dist/runnables/branch.js"() {
    init_config();
    init_stream();
    init_base4();
    RunnableBranch = class extends Runnable {
      static lc_name() {
        return "RunnableBranch";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      default;
      branches;
      constructor(fields) {
        super(fields);
        this.branches = fields.branches;
        this.default = fields.default;
      }
      /**
      * Convenience method for instantiating a RunnableBranch from
      * RunnableLikes (objects, functions, or Runnables).
      *
      * Each item in the input except for the last one should be a
      * tuple with two items. The first is a "condition" RunnableLike that
      * returns "true" if the second RunnableLike in the tuple should run.
      *
      * The final item in the input should be a RunnableLike that acts as a
      * default branch if no other branches match.
      *
      * @example
      * ```ts
      * import { RunnableBranch } from "@langchain/core/runnables";
      *
      * const branch = RunnableBranch.from([
      *   [(x: number) => x > 0, (x: number) => x + 1],
      *   [(x: number) => x < 0, (x: number) => x - 1],
      *   (x: number) => x
      * ]);
      * ```
      * @param branches An array where the every item except the last is a tuple of [condition, runnable]
      *   pairs. The last item is a default runnable which is invoked if no other condition matches.
      * @returns A new RunnableBranch.
      */
      static from(branches) {
        if (branches.length < 1) throw new Error("RunnableBranch requires at least one branch");
        const branchLikes = branches.slice(0, -1);
        const coercedBranches = branchLikes.map(([condition, runnable]) => [_coerceToRunnable(condition), _coerceToRunnable(runnable)]);
        const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);
        return new this({
          branches: coercedBranches,
          default: defaultBranch
        });
      }
      async _invoke(input, config2, runManager) {
        let result;
        for (let i = 0; i < this.branches.length; i += 1) {
          const [condition, branchRunnable] = this.branches[i];
          const conditionValue = await condition.invoke(input, patchConfig(config2, { callbacks: runManager?.getChild(`condition:${i + 1}`) }));
          if (conditionValue) {
            result = await branchRunnable.invoke(input, patchConfig(config2, { callbacks: runManager?.getChild(`branch:${i + 1}`) }));
            break;
          }
        }
        if (!result) result = await this.default.invoke(input, patchConfig(config2, { callbacks: runManager?.getChild("branch:default") }));
        return result;
      }
      async invoke(input, config2 = {}) {
        return this._callWithConfig(this._invoke, input, config2);
      }
      async *_streamIterator(input, config2) {
        const callbackManager_ = await getCallbackManagerForConfig(config2);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config2?.runId, void 0, void 0, void 0, config2?.runName);
        let finalOutput;
        let finalOutputSupported = true;
        let stream;
        try {
          for (let i = 0; i < this.branches.length; i += 1) {
            const [condition, branchRunnable] = this.branches[i];
            const conditionValue = await condition.invoke(input, patchConfig(config2, { callbacks: runManager?.getChild(`condition:${i + 1}`) }));
            if (conditionValue) {
              stream = await branchRunnable.stream(input, patchConfig(config2, { callbacks: runManager?.getChild(`branch:${i + 1}`) }));
              for await (const chunk of stream) {
                yield chunk;
                if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
                else try {
                  finalOutput = concat(finalOutput, chunk);
                } catch {
                  finalOutput = void 0;
                  finalOutputSupported = false;
                }
              }
              break;
            }
          }
          if (stream === void 0) {
            stream = await this.default.stream(input, patchConfig(config2, { callbacks: runManager?.getChild("branch:default") }));
            for await (const chunk of stream) {
              yield chunk;
              if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
              else try {
                finalOutput = concat(finalOutput, chunk);
              } catch {
                finalOutput = void 0;
                finalOutputSupported = false;
              }
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(finalOutput ?? {});
      }
    };
  }
});

// node_modules/@langchain/core/dist/runnables/history.js
var RunnableWithMessageHistory;
var init_history = __esm({
  "node_modules/@langchain/core/dist/runnables/history.js"() {
    init_base();
    init_human();
    init_ai();
    init_base4();
    init_messages2();
    init_passthrough();
    RunnableWithMessageHistory = class extends RunnableBinding {
      runnable;
      inputMessagesKey;
      outputMessagesKey;
      historyMessagesKey;
      getMessageHistory;
      constructor(fields) {
        let historyChain = RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: "loadHistory" });
        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;
        if (messagesKey) historyChain = RunnablePassthrough.assign({ [messagesKey]: historyChain }).withConfig({ runName: "insertHistory" });
        const bound = historyChain.pipe(fields.runnable.withListeners({ onEnd: (run, config$1) => this._exitHistory(run, config$1 ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" });
        const config2 = fields.config ?? {};
        super({
          ...fields,
          config: config2,
          bound
        });
        this.runnable = fields.runnable;
        this.getMessageHistory = fields.getMessageHistory;
        this.inputMessagesKey = fields.inputMessagesKey;
        this.outputMessagesKey = fields.outputMessagesKey;
        this.historyMessagesKey = fields.historyMessagesKey;
      }
      _getInputMessages(inputValue) {
        let parsedInputValue;
        if (typeof inputValue === "object" && !Array.isArray(inputValue) && !isBaseMessage(inputValue)) {
          let key;
          if (this.inputMessagesKey) key = this.inputMessagesKey;
          else if (Object.keys(inputValue).length === 1) key = Object.keys(inputValue)[0];
          else key = "input";
          if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) parsedInputValue = inputValue[key][0];
          else parsedInputValue = inputValue[key];
        } else parsedInputValue = inputValue;
        if (typeof parsedInputValue === "string") return [new HumanMessage(parsedInputValue)];
        else if (Array.isArray(parsedInputValue)) return parsedInputValue;
        else if (isBaseMessage(parsedInputValue)) return [parsedInputValue];
        else throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(parsedInputValue, null, 2)}`);
      }
      _getOutputMessages(outputValue) {
        let parsedOutputValue;
        if (!Array.isArray(outputValue) && !isBaseMessage(outputValue) && typeof outputValue !== "string") {
          let key;
          if (this.outputMessagesKey !== void 0) key = this.outputMessagesKey;
          else if (Object.keys(outputValue).length === 1) key = Object.keys(outputValue)[0];
          else key = "output";
          if (outputValue.generations !== void 0) parsedOutputValue = outputValue.generations[0][0].message;
          else parsedOutputValue = outputValue[key];
        } else parsedOutputValue = outputValue;
        if (typeof parsedOutputValue === "string") return [new AIMessage(parsedOutputValue)];
        else if (Array.isArray(parsedOutputValue)) return parsedOutputValue;
        else if (isBaseMessage(parsedOutputValue)) return [parsedOutputValue];
        else throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);
      }
      async _enterHistory(input, kwargs) {
        const history = kwargs?.configurable?.messageHistory;
        const messages = await history.getMessages();
        if (this.historyMessagesKey === void 0) return messages.concat(this._getInputMessages(input));
        return messages;
      }
      async _exitHistory(run, config2) {
        const history = config2.configurable?.messageHistory;
        let inputs;
        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) inputs = run.inputs[0];
        else inputs = run.inputs;
        let inputMessages = this._getInputMessages(inputs);
        if (this.historyMessagesKey === void 0) {
          const existingMessages = await history.getMessages();
          inputMessages = inputMessages.slice(existingMessages.length);
        }
        const outputValue = run.outputs;
        if (!outputValue) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);
        const outputMessages = this._getOutputMessages(outputValue);
        await history.addMessages([...inputMessages, ...outputMessages]);
      }
      async _mergeConfig(...configs) {
        const config2 = await super._mergeConfig(...configs);
        if (!config2.configurable || !config2.configurable.sessionId) {
          const exampleInput = { [this.inputMessagesKey ?? "input"]: "foo" };
          const exampleConfig = { configurable: { sessionId: "123" } };
          throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);
        }
        const { sessionId } = config2.configurable;
        config2.configurable.messageHistory = await this.getMessageHistory(sessionId);
        return config2;
      }
    };
  }
});

// node_modules/@langchain/core/dist/runnables/index.js
var runnables_exports;
var init_runnables = __esm({
  "node_modules/@langchain/core/dist/runnables/index.js"() {
    init_rolldown_runtime();
    init_config();
    init_signal();
    init_base4();
    init_passthrough();
    init_router();
    init_branch();
    init_history();
    runnables_exports = {};
    __export2(runnables_exports, {
      RouterRunnable: () => RouterRunnable,
      Runnable: () => Runnable,
      RunnableAssign: () => RunnableAssign,
      RunnableBinding: () => RunnableBinding,
      RunnableBranch: () => RunnableBranch,
      RunnableEach: () => RunnableEach,
      RunnableLambda: () => RunnableLambda,
      RunnableMap: () => RunnableMap,
      RunnableParallel: () => RunnableParallel,
      RunnablePassthrough: () => RunnablePassthrough,
      RunnablePick: () => RunnablePick,
      RunnableRetry: () => RunnableRetry,
      RunnableSequence: () => RunnableSequence,
      RunnableToolLike: () => RunnableToolLike,
      RunnableWithFallbacks: () => RunnableWithFallbacks,
      RunnableWithMessageHistory: () => RunnableWithMessageHistory,
      _coerceToRunnable: () => _coerceToRunnable,
      ensureConfig: () => ensureConfig,
      getCallbackManagerForConfig: () => getCallbackManagerForConfig,
      mergeConfigs: () => mergeConfigs,
      patchConfig: () => patchConfig,
      pickRunnableConfigKeys: () => pickRunnableConfigKeys,
      raceWithSignal: () => raceWithSignal
    });
  }
});

// node_modules/@langchain/core/dist/utils/json_patch.js
var json_patch_exports;
var init_json_patch = __esm({
  "node_modules/@langchain/core/dist/utils/json_patch.js"() {
    init_rolldown_runtime();
    init_core();
    init_duplex();
    init_fast_json_patch();
    json_patch_exports = {};
    __export2(json_patch_exports, {
      applyPatch: () => applyPatch,
      compare: () => compare
    });
  }
});

// node_modules/@langchain/core/dist/output_parsers/base.js
var BaseLLMOutputParser, BaseOutputParser, OutputParserException;
var init_base9 = __esm({
  "node_modules/@langchain/core/dist/output_parsers/base.js"() {
    init_errors2();
    init_base4();
    init_runnables();
    BaseLLMOutputParser = class extends Runnable {
      /**
      * Parses the result of an LLM call with a given prompt. By default, it
      * simply calls `parseResult`.
      * @param generations The generations from an LLM call.
      * @param _prompt The prompt used in the LLM call.
      * @param callbacks Optional callbacks.
      * @returns A promise of the parsed output.
      */
      parseResultWithPrompt(generations, _prompt, callbacks) {
        return this.parseResult(generations, callbacks);
      }
      _baseMessageToString(message) {
        return typeof message.content === "string" ? message.content : this._baseMessageContentToString(message.content);
      }
      _baseMessageContentToString(content) {
        return JSON.stringify(content);
      }
      /**
      * Calls the parser with a given input and optional configuration options.
      * If the input is a string, it creates a generation with the input as
      * text and calls `parseResult`. If the input is a `BaseMessage`, it
      * creates a generation with the input as a message and the content of the
      * input as text, and then calls `parseResult`.
      * @param input The input to the parser, which can be a string or a `BaseMessage`.
      * @param options Optional configuration options.
      * @returns A promise of the parsed output.
      */
      async invoke(input, options) {
        if (typeof input === "string") return this._callWithConfig(async (input$1, options$1) => this.parseResult([{ text: input$1 }], options$1?.callbacks), input, {
          ...options,
          runType: "parser"
        });
        else return this._callWithConfig(async (input$1, options$1) => this.parseResult([{
          message: input$1,
          text: this._baseMessageToString(input$1)
        }], options$1?.callbacks), input, {
          ...options,
          runType: "parser"
        });
      }
    };
    BaseOutputParser = class extends BaseLLMOutputParser {
      parseResult(generations, callbacks) {
        return this.parse(generations[0].text, callbacks);
      }
      async parseWithPrompt(text2, _prompt, callbacks) {
        return this.parse(text2, callbacks);
      }
      /**
      * Return the string type key uniquely identifying this class of parser
      */
      _type() {
        throw new Error("_type not implemented");
      }
    };
    OutputParserException = class extends Error {
      llmOutput;
      observation;
      sendToLLM;
      constructor(message, llmOutput, observation, sendToLLM = false) {
        super(message);
        this.llmOutput = llmOutput;
        this.observation = observation;
        this.sendToLLM = sendToLLM;
        if (sendToLLM) {
          if (observation === void 0 || llmOutput === void 0) throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
        }
        addLangChainErrorFields(this, "OUTPUT_PARSING_FAILURE");
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/transform.js
var BaseTransformOutputParser, BaseCumulativeTransformOutputParser;
var init_transform = __esm({
  "node_modules/@langchain/core/dist/output_parsers/transform.js"() {
    init_base();
    init_utils3();
    init_outputs();
    init_base9();
    init_esm();
    BaseTransformOutputParser = class extends BaseOutputParser {
      async *_transform(inputGenerator) {
        for await (const chunk of inputGenerator) if (typeof chunk === "string") yield this.parseResult([{ text: chunk }]);
        else yield this.parseResult([{
          message: chunk,
          text: this._baseMessageToString(chunk)
        }]);
      }
      /**
      * Transforms an asynchronous generator of input into an asynchronous
      * generator of parsed output.
      * @param inputGenerator An asynchronous generator of input.
      * @param options A configuration object.
      * @returns An asynchronous generator of parsed output.
      */
      async *transform(inputGenerator, options) {
        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {
          ...options,
          runType: "parser"
        });
      }
    };
    BaseCumulativeTransformOutputParser = class extends BaseTransformOutputParser {
      diff = false;
      constructor(fields) {
        super(fields);
        this.diff = fields?.diff ?? this.diff;
      }
      async *_transform(inputGenerator) {
        let prevParsed;
        let accGen;
        for await (const chunk of inputGenerator) {
          if (typeof chunk !== "string" && typeof chunk.content !== "string") throw new Error("Cannot handle non-string output.");
          let chunkGen;
          if (isBaseMessageChunk(chunk)) {
            if (typeof chunk.content !== "string") throw new Error("Cannot handle non-string message output.");
            chunkGen = new ChatGenerationChunk({
              message: chunk,
              text: chunk.content
            });
          } else if (isBaseMessage(chunk)) {
            if (typeof chunk.content !== "string") throw new Error("Cannot handle non-string message output.");
            chunkGen = new ChatGenerationChunk({
              message: convertToChunk(chunk),
              text: chunk.content
            });
          } else chunkGen = new GenerationChunk({ text: chunk });
          if (accGen === void 0) accGen = chunkGen;
          else accGen = accGen.concat(chunkGen);
          const parsed = await this.parsePartialResult([accGen]);
          if (parsed !== void 0 && parsed !== null && !deepCompareStrict(parsed, prevParsed)) {
            if (this.diff) yield this._diff(prevParsed, parsed);
            else yield parsed;
            prevParsed = parsed;
          }
        }
      }
      getFormatInstructions() {
        return "";
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/bytes.js
var BytesOutputParser;
var init_bytes = __esm({
  "node_modules/@langchain/core/dist/output_parsers/bytes.js"() {
    init_transform();
    BytesOutputParser = class extends BaseTransformOutputParser {
      static lc_name() {
        return "BytesOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "bytes"
      ];
      lc_serializable = true;
      textEncoder = new TextEncoder();
      parse(text2) {
        return Promise.resolve(this.textEncoder.encode(text2));
      }
      getFormatInstructions() {
        return "";
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/list.js
var ListOutputParser, CommaSeparatedListOutputParser, CustomListOutputParser, NumberedListOutputParser, MarkdownListOutputParser;
var init_list = __esm({
  "node_modules/@langchain/core/dist/output_parsers/list.js"() {
    init_base9();
    init_transform();
    ListOutputParser = class extends BaseTransformOutputParser {
      re;
      async *_transform(inputGenerator) {
        let buffer = "";
        for await (const input of inputGenerator) {
          if (typeof input === "string") buffer += input;
          else buffer += input.content;
          if (!this.re) {
            const parts = await this.parse(buffer);
            if (parts.length > 1) {
              for (const part of parts.slice(0, -1)) yield [part];
              buffer = parts[parts.length - 1];
            }
          } else {
            const matches = [...buffer.matchAll(this.re)];
            if (matches.length > 1) {
              let doneIdx = 0;
              for (const match of matches.slice(0, -1)) {
                yield [match[1]];
                doneIdx += (match.index ?? 0) + match[0].length;
              }
              buffer = buffer.slice(doneIdx);
            }
          }
        }
        for (const part of await this.parse(buffer)) yield [part];
      }
    };
    CommaSeparatedListOutputParser = class extends ListOutputParser {
      static lc_name() {
        return "CommaSeparatedListOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      lc_serializable = true;
      /**
      * Parses the given text into an array of strings, using a comma as the
      * separator. If the parsing fails, throws an OutputParserException.
      * @param text The text to parse.
      * @returns An array of strings obtained by splitting the input text at each comma.
      */
      async parse(text2) {
        try {
          return text2.trim().split(",").map((s) => s.trim());
        } catch {
          throw new OutputParserException(`Could not parse output: ${text2}`, text2);
        }
      }
      /**
      * Provides instructions on the expected format of the response for the
      * CommaSeparatedListOutputParser.
      * @returns A string containing instructions on the expected format of the response.
      */
      getFormatInstructions() {
        return `Your response should be a list of comma separated values, eg: \`foo, bar, baz\``;
      }
    };
    CustomListOutputParser = class extends ListOutputParser {
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      length;
      separator;
      constructor({ length, separator }) {
        super(...arguments);
        this.length = length;
        this.separator = separator || ",";
      }
      /**
      * Parses the given text into an array of strings, using the specified
      * separator. If the parsing fails or the number of items in the list
      * doesn't match the expected length, throws an OutputParserException.
      * @param text The text to parse.
      * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
      */
      async parse(text2) {
        try {
          const items = text2.trim().split(this.separator).map((s) => s.trim());
          if (this.length !== void 0 && items.length !== this.length) throw new OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);
          return items;
        } catch (e) {
          if (Object.getPrototypeOf(e) === OutputParserException.prototype) throw e;
          throw new OutputParserException(`Could not parse output: ${text2}`);
        }
      }
      /**
      * Provides instructions on the expected format of the response for the
      * CustomListOutputParser, including the number of items and the
      * separator.
      * @returns A string containing instructions on the expected format of the response.
      */
      getFormatInstructions() {
        return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
      }
    };
    NumberedListOutputParser = class extends ListOutputParser {
      static lc_name() {
        return "NumberedListOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      lc_serializable = true;
      getFormatInstructions() {
        return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
      }
      re = /\d+\.\s([^\n]+)/g;
      async parse(text2) {
        return [...text2.matchAll(this.re) ?? []].map((m) => m[1]);
      }
    };
    MarkdownListOutputParser = class extends ListOutputParser {
      static lc_name() {
        return "NumberedListOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      lc_serializable = true;
      getFormatInstructions() {
        return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
      }
      re = /^\s*[-*]\s([^\n]+)$/gm;
      async parse(text2) {
        return [...text2.matchAll(this.re) ?? []].map((m) => m[1]);
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/string.js
var StringOutputParser;
var init_string2 = __esm({
  "node_modules/@langchain/core/dist/output_parsers/string.js"() {
    init_transform();
    StringOutputParser = class extends BaseTransformOutputParser {
      static lc_name() {
        return "StrOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "string"
      ];
      lc_serializable = true;
      /**
      * Parses a string output from an LLM call. This method is meant to be
      * implemented by subclasses to define how a string output from an LLM
      * should be parsed.
      * @param text The string output from an LLM call.
      * @param callbacks Optional callbacks.
      * @returns A promise of the parsed output.
      */
      parse(text2) {
        return Promise.resolve(text2);
      }
      getFormatInstructions() {
        return "";
      }
      _textContentToString(content) {
        return content.text;
      }
      _imageUrlContentToString(_content) {
        throw new Error(`Cannot coerce a multimodal "image_url" message part into a string.`);
      }
      _messageContentToString(content) {
        switch (content.type) {
          case "text":
          case "text_delta":
            if ("text" in content) return this._textContentToString(content);
            break;
          case "image_url":
            if ("image_url" in content) return this._imageUrlContentToString(content);
            break;
          default:
            throw new Error(`Cannot coerce "${content.type}" message part into a string.`);
        }
        throw new Error(`Invalid content type: ${content.type}`);
      }
      _baseMessageContentToString(content) {
        return content.reduce((acc, item) => acc + this._messageContentToString(item), "");
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/structured.js
var StructuredOutputParser, JsonMarkdownStructuredOutputParser, AsymmetricStructuredOutputParser;
var init_structured = __esm({
  "node_modules/@langchain/core/dist/output_parsers/structured.js"() {
    init_zod2();
    init_json_schema2();
    init_base9();
    init_v3();
    StructuredOutputParser = class extends BaseOutputParser {
      static lc_name() {
        return "StructuredOutputParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "structured"
      ];
      toJSON() {
        return this.toJSONNotImplemented();
      }
      constructor(schema) {
        super(schema);
        this.schema = schema;
      }
      /**
      * Creates a new StructuredOutputParser from a Zod schema.
      * @param schema The Zod schema which the output should match
      * @returns A new instance of StructuredOutputParser.
      */
      static fromZodSchema(schema) {
        return new this(schema);
      }
      /**
      * Creates a new StructuredOutputParser from a set of names and
      * descriptions.
      * @param schemas An object where each key is a name and each value is a description
      * @returns A new instance of StructuredOutputParser.
      */
      static fromNamesAndDescriptions(schemas) {
        const zodSchema = external_exports.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, external_exports.string().describe(description)])));
        return new this(zodSchema);
      }
      /**
      * Returns a markdown code snippet with a JSON object formatted according
      * to the schema.
      * @param options Optional. The options for formatting the instructions
      * @returns A markdown code snippet with a JSON object formatted according to the schema.
      */
      getFormatInstructions() {
        return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(toJsonSchema(this.schema))}
\`\`\`
`;
      }
      /**
      * Parses the given text according to the schema.
      * @param text The text to parse
      * @returns The parsed output.
      */
      async parse(text2) {
        try {
          const trimmedText = text2.trim();
          const json2 = trimmedText.match(/^```(?:json)?\s*([\s\S]*?)```/)?.[1] || trimmedText.match(/```json\s*([\s\S]*?)```/)?.[1] || trimmedText;
          const escapedJson = json2.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (_match, capturedGroup) => {
            const escapedInsideQuotes = capturedGroup.replace(/\n/g, "\\n");
            return `"${escapedInsideQuotes}"`;
          }).replace(/\n/g, "");
          return await interopParseAsync(this.schema, JSON.parse(escapedJson));
        } catch (e) {
          throw new OutputParserException(`Failed to parse. Text: "${text2}". Error: ${e}`, text2);
        }
      }
    };
    JsonMarkdownStructuredOutputParser = class extends StructuredOutputParser {
      static lc_name() {
        return "JsonMarkdownStructuredOutputParser";
      }
      getFormatInstructions(options) {
        const interpolationDepth = options?.interpolationDepth ?? 1;
        if (interpolationDepth < 1) throw new Error("f string interpolation depth must be at least 1");
        return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(toJsonSchema(this.schema)).replaceAll("{", "{".repeat(interpolationDepth)).replaceAll("}", "}".repeat(interpolationDepth))}
\`\`\``;
      }
      _schemaToInstruction(schemaInput, indent = 2) {
        const schema = schemaInput;
        if ("type" in schema) {
          let nullable2 = false;
          let type;
          if (Array.isArray(schema.type)) {
            const nullIdx = schema.type.findIndex((type$1) => type$1 === "null");
            if (nullIdx !== -1) {
              nullable2 = true;
              schema.type.splice(nullIdx, 1);
            }
            type = schema.type.join(" | ");
          } else type = schema.type;
          if (schema.type === "object" && schema.properties) {
            const description$1 = schema.description ? ` // ${schema.description}` : "";
            const properties = Object.entries(schema.properties).map(([key, value]) => {
              const isOptional = schema.required?.includes(key) ? "" : " (optional)";
              return `${" ".repeat(indent)}"${key}": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;
            }).join("\n");
            return `{
${properties}
${" ".repeat(indent - 2)}}${description$1}`;
          }
          if (schema.type === "array" && schema.items) {
            const description$1 = schema.description ? ` // ${schema.description}` : "";
            return `array[
${" ".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}
${" ".repeat(indent - 2)}] ${description$1}`;
          }
          const isNullable2 = nullable2 ? " (nullable)" : "";
          const description = schema.description ? ` // ${schema.description}` : "";
          return `${type}${description}${isNullable2}`;
        }
        if ("anyOf" in schema) return schema.anyOf.map((s) => this._schemaToInstruction(s, indent)).join(`
${" ".repeat(indent - 2)}`);
        throw new Error("unsupported schema type");
      }
      static fromZodSchema(schema) {
        return new this(schema);
      }
      static fromNamesAndDescriptions(schemas) {
        const zodSchema = external_exports.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, external_exports.string().describe(description)])));
        return new this(zodSchema);
      }
    };
    AsymmetricStructuredOutputParser = class extends BaseOutputParser {
      structuredInputParser;
      constructor({ inputSchema: inputSchema7 }) {
        super(...arguments);
        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema7);
      }
      async parse(text2) {
        let parsedInput;
        try {
          parsedInput = await this.structuredInputParser.parse(text2);
        } catch (e) {
          throw new OutputParserException(`Failed to parse. Text: "${text2}". Error: ${e}`, text2);
        }
        return this.outputProcessor(parsedInput);
      }
      getFormatInstructions() {
        return this.structuredInputParser.getFormatInstructions();
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/json.js
var JsonOutputParser;
var init_json2 = __esm({
  "node_modules/@langchain/core/dist/output_parsers/json.js"() {
    init_json();
    init_duplex();
    init_transform();
    init_json_patch();
    JsonOutputParser = class extends BaseCumulativeTransformOutputParser {
      static lc_name() {
        return "JsonOutputParser";
      }
      lc_namespace = ["langchain_core", "output_parsers"];
      lc_serializable = true;
      /** @internal */
      _concatOutputChunks(first, second) {
        if (this.diff) return super._concatOutputChunks(first, second);
        return second;
      }
      _diff(prev, next) {
        if (!next) return void 0;
        if (!prev) return [{
          op: "replace",
          path: "",
          value: next
        }];
        return compare(prev, next);
      }
      async parsePartialResult(generations) {
        return parseJsonMarkdown(generations[0].text);
      }
      async parse(text2) {
        return parseJsonMarkdown(text2, JSON.parse);
      }
      getFormatInstructions() {
        return "";
      }
      /**
      * Extracts text content from a message for JSON parsing.
      * Uses the message's `.text` accessor which properly handles both
      * string content and ContentBlock[] arrays (extracting text from text blocks).
      * @param message The message to extract text from
      * @returns The text content of the message
      */
      _baseMessageToString(message) {
        return message.text;
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/sax-js/sax.js
var initializeSax, sax;
var init_sax = __esm({
  "node_modules/@langchain/core/dist/utils/sax-js/sax.js"() {
    initializeSax = function() {
      const sax$1 = {};
      sax$1.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax$1.SAXParser = SAXParser;
      sax$1.SAXStream = SAXStream;
      sax$1.createStream = createStream;
      sax$1.MAX_BUFFER_LENGTH = 64 * 1024;
      const buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax$1.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax$1.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax$1.XML_ENTITIES) : Object.create(sax$1.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
        emit(parser, "onready");
      }
      if (!Object.create) Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
      if (!Object.keys) Object.keys = function(o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax$1.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error40(parser, "Max buffer length exceeded: " + buffers[i]);
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax$1.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) parser[buffers[i]] = "";
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2 = ReadableStream;
      if (!Stream2) Stream2 = function() {
      };
      var streamWraps = sax$1.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, { constructor: { value: SAXStream } });
      SAXStream.prototype.write = function(data) {
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) this.write(chunk);
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler2) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
        return Stream2.prototype.on.call(me, ev, handler2);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
      };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace2(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace2(c);
      }
      function isMatch(regex2, c) {
        return regex2.test(c);
      }
      function notMatch(regex2, c) {
        return !isMatch(regex2, c);
      }
      var S = 0;
      sax$1.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      };
      sax$1.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      };
      sax$1.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      };
      Object.keys(sax$1.ENTITIES).forEach(function(key) {
        var e = sax$1.ENTITIES[key];
        var s$1 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax$1.ENTITIES[key] = s$1;
      });
      for (var s in sax$1.STATE) sax$1.STATE[sax$1.STATE[s]] = s;
      S = sax$1.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text2) {
        if (opt.trim) text2 = text2.trim();
        if (opt.normalize) text2 = text2.replace(/\s+/g, " ");
        return text2;
      }
      function error40(parser, er) {
        closeText(parser);
        if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error40(parser, "Unexpected end");
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
        if (parser.strict) error40(parser, message);
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
          name: parser.tagName,
          attributes: {}
        };
        if (parser.opt.xmlns) tag.ns = parent.ns;
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return {
          prefix,
          local
        };
      }
      function attrib(parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") if (local === "xml" && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
            tag.ns[local] = parser.attribValue;
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri: uri2
            };
            if (prefix && prefix !== "xmlns" && !uri2) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") parser.state = S.SCRIPT;
          else parser.state = S.TEXT;
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) strictFail(parser, "Unexpected close tag");
          else break;
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s$1 = parser.tags.length;
        while (s$1-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) x[i] = tag.ns[i];
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) Object.keys(tag.ns).forEach(function(p) {
            var n2 = tag.ns[p];
            emitNode(parser, "onclosenamespace", {
              prefix: p,
              uri: n2
            });
          });
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === "#") if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace2(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) result = chunk.charAt(i);
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) throw this.error;
        if (parser.closed) return error40(parser, "Cannot write after close. Assign an onready handler.");
        if (chunk === null) return end(parser);
        if (typeof chunk === "object") chunk = chunk.toString();
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) break;
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else parser.column++;
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") continue;
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else parser.column++;
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
                if (c === "&") parser.state = S.TEXT_ENTITY;
                else parser.textNode += c;
              }
              continue;
            case S.SCRIPT:
              if (c === "<") parser.state = S.SCRIPT_ENDING;
              else parser.script += c;
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") parser.state = S.CLOSE_TAG;
              else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace2(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else parser.sgmlDecl += c;
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") parser.state = S.DOCTYPE_DTD;
                else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") parser.state = S.DOCTYPE;
              else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") parser.state = S.COMMENT_ENDING;
              else parser.comment += c;
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) emitNode(parser, "oncomment", parser.comment);
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else parser.state = S.TEXT;
              continue;
            case S.CDATA:
              if (c === "]") parser.state = S.CDATA_ENDING;
              else parser.cdata += c;
              continue;
            case S.CDATA_ENDING:
              if (c === "]") parser.state = S.CDATA_ENDING_2;
              else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") parser.cdata += "]";
              else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") parser.state = S.PROC_INST_ENDING;
              else if (isWhitespace2(c)) parser.state = S.PROC_INST_BODY;
              else parser.procInstName += c;
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace2(c)) continue;
              else if (c === "?") parser.state = S.PROC_INST_ENDING;
              else parser.procInstBody += c;
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) parser.tagName += c;
              else {
                newTag(parser);
                if (c === ">") openTag(parser);
                else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                else {
                  if (!isWhitespace2(c)) strictFail(parser, "Invalid character in tag name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace2(c)) continue;
              else if (c === ">") openTag(parser);
              else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
              else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") parser.state = S.ATTRIB_VALUE;
              else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace2(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
              else if (isMatch(nameBody, c)) parser.attribName += c;
              else strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") parser.state = S.ATTRIB_VALUE;
              else if (isWhitespace2(c)) continue;
              else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") openTag(parser);
                else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace2(c)) continue;
              else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                else parser.attribValue += c;
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace2(c)) parser.state = S.ATTRIB;
              else if (c === ">") openTag(parser);
              else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
              else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U;
                else parser.attribValue += c;
                continue;
              }
              attrib(parser);
              if (c === ">") openTag(parser);
              else parser.state = S.ATTRIB;
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) if (isWhitespace2(c)) continue;
              else if (notMatch(nameStart, c)) if (parser.script) {
                parser.script += "</" + c;
                parser.state = S.SCRIPT;
              } else strictFail(parser, "Invalid tagname in closing tag.");
              else parser.tagName = c;
              else if (c === ">") closeTag(parser);
              else if (isMatch(nameBody, c)) parser.tagName += c;
              else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace2(c)) strictFail(parser, "Invalid tagname in closing tag");
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace2(c)) continue;
              if (c === ">") closeTag(parser);
              else strictFail(parser, "Invalid characters in closing tag");
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") if (parser.opt.unparsedEntities) {
                var parsedEntity = parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              }
              else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
              else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
        return parser;
      }
      if (!String.fromCodePoint) (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index2 = -1;
          var length = arguments.length;
          if (!length) return "";
          var result = "";
          while (++index2 < length) {
            var codePoint = Number(arguments[index2]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
            if (codePoint <= 65535) codeUnits.push(codePoint);
            else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
        else String.fromCodePoint = fromCodePoint;
      })();
      return sax$1;
    };
    sax = initializeSax();
  }
});

// node_modules/@langchain/core/dist/output_parsers/xml.js
function parseXMLMarkdown(s) {
  const cleanedString = strip(s);
  const parser = sax.parser(true);
  let parsedResult = {};
  const elementStack = [];
  parser.onopentag = (node) => {
    const element = {
      name: node.name,
      attributes: node.attributes,
      children: [],
      text: "",
      isSelfClosing: node.isSelfClosing
    };
    if (elementStack.length > 0) {
      const parentElement = elementStack[elementStack.length - 1];
      parentElement.children.push(element);
    } else parsedResult = element;
    if (!node.isSelfClosing) elementStack.push(element);
  };
  parser.onclosetag = () => {
    if (elementStack.length > 0) {
      const lastElement = elementStack.pop();
      if (elementStack.length === 0 && lastElement) parsedResult = lastElement;
    }
  };
  parser.ontext = (text2) => {
    if (elementStack.length > 0) {
      const currentElement = elementStack[elementStack.length - 1];
      currentElement.text += text2;
    }
  };
  parser.onattribute = (attr) => {
    if (elementStack.length > 0) {
      const currentElement = elementStack[elementStack.length - 1];
      currentElement.attributes[attr.name] = attr.value;
    }
  };
  const match = /```(xml)?(.*)```/s.exec(cleanedString);
  const xmlString = match ? match[2] : cleanedString;
  parser.write(xmlString).close();
  if (parsedResult && parsedResult.name === "?xml") parsedResult = parsedResult.children[0];
  return parseParsedResult(parsedResult);
}
var XML_FORMAT_INSTRUCTIONS, XMLOutputParser, strip, parseParsedResult;
var init_xml = __esm({
  "node_modules/@langchain/core/dist/output_parsers/xml.js"() {
    init_duplex();
    init_transform();
    init_json_patch();
    init_sax();
    XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
    XMLOutputParser = class extends BaseCumulativeTransformOutputParser {
      tags;
      constructor(fields) {
        super(fields);
        this.tags = fields?.tags;
      }
      static lc_name() {
        return "XMLOutputParser";
      }
      lc_namespace = ["langchain_core", "output_parsers"];
      lc_serializable = true;
      _diff(prev, next) {
        if (!next) return void 0;
        if (!prev) return [{
          op: "replace",
          path: "",
          value: next
        }];
        return compare(prev, next);
      }
      async parsePartialResult(generations) {
        return parseXMLMarkdown(generations[0].text);
      }
      async parse(text2) {
        return parseXMLMarkdown(text2);
      }
      getFormatInstructions() {
        const withTags = !!(this.tags && this.tags.length > 0);
        return withTags ? XML_FORMAT_INSTRUCTIONS.replace("{tags}", this.tags?.join(", ") ?? "") : XML_FORMAT_INSTRUCTIONS;
      }
    };
    strip = (text2) => text2.split("\n").map((line) => line.replace(/^\s+/, "")).join("\n").trim();
    parseParsedResult = (input) => {
      if (Object.keys(input).length === 0) return {};
      const result = {};
      if (input.children.length > 0) {
        result[input.name] = input.children.map(parseParsedResult);
        return result;
      } else {
        result[input.name] = input.text ?? void 0;
        return result;
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/index.js
var output_parsers_exports;
var init_output_parsers = __esm({
  "node_modules/@langchain/core/dist/output_parsers/index.js"() {
    init_rolldown_runtime();
    init_json();
    init_base9();
    init_transform();
    init_bytes();
    init_list();
    init_string2();
    init_structured();
    init_json2();
    init_xml();
    output_parsers_exports = {};
    __export2(output_parsers_exports, {
      AsymmetricStructuredOutputParser: () => AsymmetricStructuredOutputParser,
      BaseCumulativeTransformOutputParser: () => BaseCumulativeTransformOutputParser,
      BaseLLMOutputParser: () => BaseLLMOutputParser,
      BaseOutputParser: () => BaseOutputParser,
      BaseTransformOutputParser: () => BaseTransformOutputParser,
      BytesOutputParser: () => BytesOutputParser,
      CommaSeparatedListOutputParser: () => CommaSeparatedListOutputParser,
      CustomListOutputParser: () => CustomListOutputParser,
      JsonMarkdownStructuredOutputParser: () => JsonMarkdownStructuredOutputParser,
      JsonOutputParser: () => JsonOutputParser,
      ListOutputParser: () => ListOutputParser,
      MarkdownListOutputParser: () => MarkdownListOutputParser,
      NumberedListOutputParser: () => NumberedListOutputParser,
      OutputParserException: () => OutputParserException,
      StringOutputParser: () => StringOutputParser,
      StructuredOutputParser: () => StructuredOutputParser,
      XMLOutputParser: () => XMLOutputParser,
      XML_FORMAT_INSTRUCTIONS: () => XML_FORMAT_INSTRUCTIONS,
      parseJsonMarkdown: () => parseJsonMarkdown,
      parsePartialJson: () => parsePartialJson,
      parseXMLMarkdown: () => parseXMLMarkdown
    });
  }
});

// node_modules/@langchain/core/dist/output_parsers/openai_functions/json_output_functions_parsers.js
var OutputFunctionsParser, JsonOutputFunctionsParser, JsonKeyOutputFunctionsParser;
var init_json_output_functions_parsers = __esm({
  "node_modules/@langchain/core/dist/output_parsers/openai_functions/json_output_functions_parsers.js"() {
    init_json();
    init_duplex();
    init_base9();
    init_transform();
    init_json_patch();
    init_json2();
    OutputFunctionsParser = class extends BaseLLMOutputParser {
      static lc_name() {
        return "OutputFunctionsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_functions"
      ];
      lc_serializable = true;
      argsOnly = true;
      constructor(config2) {
        super();
        this.argsOnly = config2?.argsOnly ?? this.argsOnly;
      }
      /**
      * Parses the output and returns a string representation of the function
      * call or its arguments.
      * @param generations The output of the LLM to parse.
      * @returns A string representation of the function call or its arguments.
      */
      async parseResult(generations) {
        if ("message" in generations[0]) {
          const gen = generations[0];
          const functionCall = gen.message.additional_kwargs.function_call;
          if (!functionCall) throw new Error(`No function_call in message ${JSON.stringify(generations)}`);
          if (!functionCall.arguments) throw new Error(`No arguments in function_call ${JSON.stringify(generations)}`);
          if (this.argsOnly) return functionCall.arguments;
          return JSON.stringify(functionCall);
        } else throw new Error(`No message in generations ${JSON.stringify(generations)}`);
      }
    };
    JsonOutputFunctionsParser = class extends BaseCumulativeTransformOutputParser {
      static lc_name() {
        return "JsonOutputFunctionsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_functions"
      ];
      lc_serializable = true;
      outputParser;
      argsOnly = true;
      constructor(config2) {
        super(config2);
        this.argsOnly = config2?.argsOnly ?? this.argsOnly;
        this.outputParser = new OutputFunctionsParser(config2);
      }
      _diff(prev, next) {
        if (!next) return void 0;
        const ops = compare(prev ?? {}, next);
        return ops;
      }
      async parsePartialResult(generations) {
        const generation = generations[0];
        if (!generation.message) return void 0;
        const { message } = generation;
        const functionCall = message.additional_kwargs.function_call;
        if (!functionCall) return void 0;
        if (this.argsOnly) return parsePartialJson(functionCall.arguments);
        return {
          ...functionCall,
          arguments: parsePartialJson(functionCall.arguments)
        };
      }
      /**
      * Parses the output and returns a JSON object. If `argsOnly` is true,
      * only the arguments of the function call are returned.
      * @param generations The output of the LLM to parse.
      * @returns A JSON object representation of the function call or its arguments.
      */
      async parseResult(generations) {
        const result = await this.outputParser.parseResult(generations);
        if (!result) throw new Error(`No result from "OutputFunctionsParser" ${JSON.stringify(generations)}`);
        return this.parse(result);
      }
      async parse(text2) {
        const parsedResult = JSON.parse(text2);
        if (this.argsOnly) return parsedResult;
        parsedResult.arguments = JSON.parse(parsedResult.arguments);
        return parsedResult;
      }
      getFormatInstructions() {
        return "";
      }
    };
    JsonKeyOutputFunctionsParser = class extends BaseLLMOutputParser {
      static lc_name() {
        return "JsonKeyOutputFunctionsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_functions"
      ];
      lc_serializable = true;
      outputParser = new JsonOutputFunctionsParser();
      attrName;
      get lc_aliases() {
        return { attrName: "key_name" };
      }
      constructor(fields) {
        super(fields);
        this.attrName = fields.attrName;
      }
      /**
      * Parses the output and returns a specific attribute of the parsed JSON
      * object.
      * @param generations The output of the LLM to parse.
      * @returns The value of a specific attribute of the parsed JSON object.
      */
      async parseResult(generations) {
        const result = await this.outputParser.parseResult(generations);
        return result[this.attrName];
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/openai_functions/index.js
var openai_functions_exports;
var init_openai_functions = __esm({
  "node_modules/@langchain/core/dist/output_parsers/openai_functions/index.js"() {
    init_rolldown_runtime();
    init_json_output_functions_parsers();
    openai_functions_exports = {};
    __export2(openai_functions_exports, {
      JsonKeyOutputFunctionsParser: () => JsonKeyOutputFunctionsParser,
      JsonOutputFunctionsParser: () => JsonOutputFunctionsParser,
      OutputFunctionsParser: () => OutputFunctionsParser
    });
  }
});

// node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.js
function parseToolCall(rawToolCall, options) {
  if (rawToolCall.function === void 0) return void 0;
  let functionArgs;
  if (options?.partial) try {
    functionArgs = parsePartialJson(rawToolCall.function.arguments ?? "{}");
  } catch {
    return void 0;
  }
  else try {
    functionArgs = JSON.parse(rawToolCall.function.arguments);
  } catch (e) {
    throw new OutputParserException([
      `Function "${rawToolCall.function.name}" arguments:`,
      ``,
      rawToolCall.function.arguments,
      ``,
      `are not valid JSON.`,
      `Error: ${e.message}`
    ].join("\n"));
  }
  const parsedToolCall = {
    name: rawToolCall.function.name,
    args: functionArgs,
    type: "tool_call"
  };
  if (options?.returnId) parsedToolCall.id = rawToolCall.id;
  return parsedToolCall;
}
function convertLangChainToolCallToOpenAI(toolCall) {
  if (toolCall.id === void 0) throw new Error(`All OpenAI tool calls must have an "id" field.`);
  return {
    id: toolCall.id,
    type: "function",
    function: {
      name: toolCall.name,
      arguments: JSON.stringify(toolCall.args)
    }
  };
}
function makeInvalidToolCall(rawToolCall, errorMsg) {
  return {
    name: rawToolCall.function?.name,
    args: rawToolCall.function?.arguments,
    id: rawToolCall.id,
    error: errorMsg,
    type: "invalid_tool_call"
  };
}
var JsonOutputToolsParser, JsonOutputKeyToolsParser;
var init_json_output_tools_parsers = __esm({
  "node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.js"() {
    init_json();
    init_ai();
    init_zod2();
    init_base9();
    init_transform();
    init_json2();
    JsonOutputToolsParser = class extends BaseCumulativeTransformOutputParser {
      static lc_name() {
        return "JsonOutputToolsParser";
      }
      returnId = false;
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_tools"
      ];
      lc_serializable = true;
      constructor(fields) {
        super(fields);
        this.returnId = fields?.returnId ?? this.returnId;
      }
      _diff() {
        throw new Error("Not supported.");
      }
      async parse() {
        throw new Error("Not implemented.");
      }
      async parseResult(generations) {
        const result = await this.parsePartialResult(generations, false);
        return result;
      }
      /**
      * Parses the output and returns a JSON object. If `argsOnly` is true,
      * only the arguments of the function call are returned.
      * @param generations The output of the LLM to parse.
      * @returns A JSON object representation of the function call or its arguments.
      */
      async parsePartialResult(generations, partial2 = true) {
        const message = generations[0].message;
        let toolCalls;
        if (isAIMessage(message) && message.tool_calls?.length) toolCalls = message.tool_calls.map((toolCall) => {
          const { id, ...rest } = toolCall;
          if (!this.returnId) return rest;
          return {
            id,
            ...rest
          };
        });
        else if (message.additional_kwargs.tool_calls !== void 0) {
          const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));
          toolCalls = rawToolCalls.map((rawToolCall) => {
            return parseToolCall(rawToolCall, {
              returnId: this.returnId,
              partial: partial2
            });
          });
        }
        if (!toolCalls) return [];
        const parsedToolCalls = [];
        for (const toolCall of toolCalls) if (toolCall !== void 0) {
          const backwardsCompatibleToolCall = {
            type: toolCall.name,
            args: toolCall.args,
            id: toolCall.id
          };
          parsedToolCalls.push(backwardsCompatibleToolCall);
        }
        return parsedToolCalls;
      }
    };
    JsonOutputKeyToolsParser = class extends JsonOutputToolsParser {
      static lc_name() {
        return "JsonOutputKeyToolsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_tools"
      ];
      lc_serializable = true;
      returnId = false;
      /** The type of tool calls to return. */
      keyName;
      /** Whether to return only the first tool call. */
      returnSingle = false;
      zodSchema;
      constructor(params) {
        super(params);
        this.keyName = params.keyName;
        this.returnSingle = params.returnSingle ?? this.returnSingle;
        this.zodSchema = params.zodSchema;
      }
      async _validateResult(result) {
        if (this.zodSchema === void 0) return result;
        const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);
        if (zodParsedResult.success) return zodParsedResult.data;
        else throw new OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`, JSON.stringify(result, null, 2));
      }
      async parsePartialResult(generations) {
        const results = await super.parsePartialResult(generations);
        const matchingResults = results.filter((result) => result.type === this.keyName);
        let returnedValues = matchingResults;
        if (!matchingResults.length) return void 0;
        if (!this.returnId) returnedValues = matchingResults.map((result) => result.args);
        if (this.returnSingle) return returnedValues[0];
        return returnedValues;
      }
      async parseResult(generations) {
        const results = await super.parsePartialResult(generations, false);
        const matchingResults = results.filter((result) => result.type === this.keyName);
        let returnedValues = matchingResults;
        if (!matchingResults.length) return void 0;
        if (!this.returnId) returnedValues = matchingResults.map((result) => result.args);
        if (this.returnSingle) return this._validateResult(returnedValues[0]);
        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));
        return toolCallResults;
      }
    };
  }
});

// node_modules/@langchain/core/dist/output_parsers/openai_tools/index.js
var openai_tools_exports;
var init_openai_tools = __esm({
  "node_modules/@langchain/core/dist/output_parsers/openai_tools/index.js"() {
    init_rolldown_runtime();
    init_json_output_tools_parsers();
    openai_tools_exports = {};
    __export2(openai_tools_exports, {
      JsonOutputKeyToolsParser: () => JsonOutputKeyToolsParser,
      JsonOutputToolsParser: () => JsonOutputToolsParser,
      convertLangChainToolCallToOpenAI: () => convertLangChainToolCallToOpenAI,
      makeInvalidToolCall: () => makeInvalidToolCall,
      parseToolCall: () => parseToolCall
    });
  }
});

// node_modules/@langchain/core/dist/prompts/base.js
var BasePromptTemplate;
var init_base10 = __esm({
  "node_modules/@langchain/core/dist/prompts/base.js"() {
    init_base4();
    BasePromptTemplate = class extends Runnable {
      lc_serializable = true;
      lc_namespace = [
        "langchain_core",
        "prompts",
        this._getPromptType()
      ];
      get lc_attributes() {
        return { partialVariables: void 0 };
      }
      inputVariables;
      outputParser;
      partialVariables;
      /**
      * Metadata to be used for tracing.
      */
      metadata;
      /** Tags to be used for tracing. */
      tags;
      constructor(input) {
        super(input);
        const { inputVariables } = input;
        if (inputVariables.includes("stop")) throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
        Object.assign(this, input);
      }
      /**
      * Merges partial variables and user variables.
      * @param userVariables The user variables to merge with the partial variables.
      * @returns A Promise that resolves to an object containing the merged variables.
      */
      async mergePartialAndUserVariables(userVariables) {
        const partialVariables = this.partialVariables ?? {};
        const partialValues = {};
        for (const [key, value] of Object.entries(partialVariables)) if (typeof value === "string") partialValues[key] = value;
        else partialValues[key] = await value();
        const allKwargs = {
          ...partialValues,
          ...userVariables
        };
        return allKwargs;
      }
      /**
      * Invokes the prompt template with the given input and options.
      * @param input The input to invoke the prompt template with.
      * @param options Optional configuration for the callback.
      * @returns A Promise that resolves to the output of the prompt template.
      */
      async invoke(input, options) {
        const metadata = {
          ...this.metadata,
          ...options?.metadata
        };
        const tags = [...this.tags ?? [], ...options?.tags ?? []];
        return this._callWithConfig((input$1) => this.formatPromptValue(input$1), input, {
          ...options,
          tags,
          metadata,
          runType: "prompt"
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/string.js
var BaseStringPromptTemplate;
var init_string3 = __esm({
  "node_modules/@langchain/core/dist/prompts/string.js"() {
    init_prompt_values();
    init_base10();
    BaseStringPromptTemplate = class extends BasePromptTemplate {
      /**
      * Formats the prompt given the input values and returns a formatted
      * prompt value.
      * @param values The input values to format the prompt.
      * @returns A Promise that resolves to a formatted prompt value.
      */
      async formatPromptValue(values) {
        const formattedPrompt = await this.format(values);
        return new StringPromptValue(formattedPrompt);
      }
    };
  }
});

// node_modules/mustache/mustache.mjs
function isFunction(object2) {
  return typeof object2 === "function";
}
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
function escapeRegExp(string4) {
  return string4.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName2) {
  return obj != null && typeof obj === "object" && propName2 in obj;
}
function primitiveHasOwnProperty(primitive, propName2) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName2);
}
function testRegExp(re, string4) {
  return regExpTest.call(re, string4);
}
function isWhitespace(string4) {
  return !testRegExp(nonSpaceRe, string4);
}
function escapeHtml(string4) {
  return String(string4).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string4) {
  this.string = string4;
  this.tail = string4;
  this.pos = 0;
}
function Context(view2, parentContext) {
  this.view = view2;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set2(key, value) {
      this._cache[key] = value;
    },
    get: function get(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
var objectToString3, isArray, regExpTest, nonSpaceRe, entityMap, whiteRe, spaceRe, equalsRe, curlyRe, tagRe, mustache, defaultWriter, mustache_default;
var init_mustache = __esm({
  "node_modules/mustache/mustache.mjs"() {
    objectToString3 = Object.prototype.toString;
    isArray = Array.isArray || function isArrayPolyfill(object2) {
      return objectToString3.call(object2) === "[object Array]";
    };
    regExpTest = RegExp.prototype.test;
    nonSpaceRe = /\S/;
    entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    whiteRe = /\s*/;
    spaceRe = /\s+/;
    equalsRe = /\s*=/;
    curlyRe = /\s*\}/;
    tagRe = /#|\^|\/|>|\{|&|=|!/;
    Scanner.prototype.eos = function eos() {
      return this.tail === "";
    };
    Scanner.prototype.scan = function scan(re) {
      var match = this.tail.match(re);
      if (!match || match.index !== 0)
        return "";
      var string4 = match[0];
      this.tail = this.tail.substring(string4.length);
      this.pos += string4.length;
      return string4;
    };
    Scanner.prototype.scanUntil = function scanUntil(re) {
      var index2 = this.tail.search(re), match;
      switch (index2) {
        case -1:
          match = this.tail;
          this.tail = "";
          break;
        case 0:
          match = "";
          break;
        default:
          match = this.tail.substring(0, index2);
          this.tail = this.tail.substring(index2);
      }
      this.pos += match.length;
      return match;
    };
    Context.prototype.push = function push(view2) {
      return new Context(view2, this);
    };
    Context.prototype.lookup = function lookup(name) {
      var cache2 = this.cache;
      var value;
      if (cache2.hasOwnProperty(name)) {
        value = cache2[name];
      } else {
        var context2 = this, intermediateValue, names, index2, lookupHit = false;
        while (context2) {
          if (name.indexOf(".") > 0) {
            intermediateValue = context2.view;
            names = name.split(".");
            index2 = 0;
            while (intermediateValue != null && index2 < names.length) {
              if (index2 === names.length - 1)
                lookupHit = hasProperty(intermediateValue, names[index2]) || primitiveHasOwnProperty(intermediateValue, names[index2]);
              intermediateValue = intermediateValue[names[index2++]];
            }
          } else {
            intermediateValue = context2.view[name];
            lookupHit = hasProperty(context2.view, name);
          }
          if (lookupHit) {
            value = intermediateValue;
            break;
          }
          context2 = context2.parent;
        }
        cache2[name] = value;
      }
      if (isFunction(value))
        value = value.call(this.view);
      return value;
    };
    Writer.prototype.clearCache = function clearCache() {
      if (typeof this.templateCache !== "undefined") {
        this.templateCache.clear();
      }
    };
    Writer.prototype.parse = function parse5(template, tags) {
      var cache2 = this.templateCache;
      var cacheKey = template + ":" + (tags || mustache.tags).join(":");
      var isCacheEnabled = typeof cache2 !== "undefined";
      var tokens = isCacheEnabled ? cache2.get(cacheKey) : void 0;
      if (tokens == void 0) {
        tokens = parseTemplate(template, tags);
        isCacheEnabled && cache2.set(cacheKey, tokens);
      }
      return tokens;
    };
    Writer.prototype.render = function render(template, view2, partials, config2) {
      var tags = this.getConfigTags(config2);
      var tokens = this.parse(template, tags);
      var context2 = view2 instanceof Context ? view2 : new Context(view2, void 0);
      return this.renderTokens(tokens, context2, partials, template, config2);
    };
    Writer.prototype.renderTokens = function renderTokens(tokens, context2, partials, originalTemplate, config2) {
      var buffer = "";
      var token, symbol2, value;
      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
        value = void 0;
        token = tokens[i];
        symbol2 = token[0];
        if (symbol2 === "#") value = this.renderSection(token, context2, partials, originalTemplate, config2);
        else if (symbol2 === "^") value = this.renderInverted(token, context2, partials, originalTemplate, config2);
        else if (symbol2 === ">") value = this.renderPartial(token, context2, partials, config2);
        else if (symbol2 === "&") value = this.unescapedValue(token, context2);
        else if (symbol2 === "name") value = this.escapedValue(token, context2, config2);
        else if (symbol2 === "text") value = this.rawValue(token);
        if (value !== void 0)
          buffer += value;
      }
      return buffer;
    };
    Writer.prototype.renderSection = function renderSection(token, context2, partials, originalTemplate, config2) {
      var self2 = this;
      var buffer = "";
      var value = context2.lookup(token[1]);
      function subRender(template) {
        return self2.render(template, context2, partials, config2);
      }
      if (!value) return;
      if (isArray(value)) {
        for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
          buffer += this.renderTokens(token[4], context2.push(value[j]), partials, originalTemplate, config2);
        }
      } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
        buffer += this.renderTokens(token[4], context2.push(value), partials, originalTemplate, config2);
      } else if (isFunction(value)) {
        if (typeof originalTemplate !== "string")
          throw new Error("Cannot use higher-order sections without the original template");
        value = value.call(context2.view, originalTemplate.slice(token[3], token[5]), subRender);
        if (value != null)
          buffer += value;
      } else {
        buffer += this.renderTokens(token[4], context2, partials, originalTemplate, config2);
      }
      return buffer;
    };
    Writer.prototype.renderInverted = function renderInverted(token, context2, partials, originalTemplate, config2) {
      var value = context2.lookup(token[1]);
      if (!value || isArray(value) && value.length === 0)
        return this.renderTokens(token[4], context2, partials, originalTemplate, config2);
    };
    Writer.prototype.indentPartial = function indentPartial(partial2, indentation, lineHasNonSpace) {
      var filteredIndentation = indentation.replace(/[^ \t]/g, "");
      var partialByNl = partial2.split("\n");
      for (var i = 0; i < partialByNl.length; i++) {
        if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
          partialByNl[i] = filteredIndentation + partialByNl[i];
        }
      }
      return partialByNl.join("\n");
    };
    Writer.prototype.renderPartial = function renderPartial(token, context2, partials, config2) {
      if (!partials) return;
      var tags = this.getConfigTags(config2);
      var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
      if (value != null) {
        var lineHasNonSpace = token[6];
        var tagIndex = token[5];
        var indentation = token[4];
        var indentedValue = value;
        if (tagIndex == 0 && indentation) {
          indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
        }
        var tokens = this.parse(indentedValue, tags);
        return this.renderTokens(tokens, context2, partials, indentedValue, config2);
      }
    };
    Writer.prototype.unescapedValue = function unescapedValue(token, context2) {
      var value = context2.lookup(token[1]);
      if (value != null)
        return value;
    };
    Writer.prototype.escapedValue = function escapedValue(token, context2, config2) {
      var escape2 = this.getConfigEscape(config2) || mustache.escape;
      var value = context2.lookup(token[1]);
      if (value != null)
        return typeof value === "number" && escape2 === mustache.escape ? String(value) : escape2(value);
    };
    Writer.prototype.rawValue = function rawValue(token) {
      return token[1];
    };
    Writer.prototype.getConfigTags = function getConfigTags(config2) {
      if (isArray(config2)) {
        return config2;
      } else if (config2 && typeof config2 === "object") {
        return config2.tags;
      } else {
        return void 0;
      }
    };
    Writer.prototype.getConfigEscape = function getConfigEscape(config2) {
      if (config2 && typeof config2 === "object" && !isArray(config2)) {
        return config2.escape;
      } else {
        return void 0;
      }
    };
    mustache = {
      name: "mustache.js",
      version: "4.2.0",
      tags: ["{{", "}}"],
      clearCache: void 0,
      escape: void 0,
      parse: void 0,
      render: void 0,
      Scanner: void 0,
      Context: void 0,
      Writer: void 0,
      /**
       * Allows a user to override the default caching strategy, by providing an
       * object with set, get and clear methods. This can also be used to disable
       * the cache by setting it to the literal `undefined`.
       */
      set templateCache(cache2) {
        defaultWriter.templateCache = cache2;
      },
      /**
       * Gets the default or overridden caching object from the default writer.
       */
      get templateCache() {
        return defaultWriter.templateCache;
      }
    };
    defaultWriter = new Writer();
    mustache.clearCache = function clearCache2() {
      return defaultWriter.clearCache();
    };
    mustache.parse = function parse6(template, tags) {
      return defaultWriter.parse(template, tags);
    };
    mustache.render = function render2(template, view2, partials, config2) {
      if (typeof template !== "string") {
        throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
      }
      return defaultWriter.render(template, view2, partials, config2);
    };
    mustache.escape = escapeHtml;
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    mustache.Writer = Writer;
    mustache_default = mustache;
  }
});

// node_modules/@langchain/core/dist/prompts/template.js
function configureMustache() {
  mustache_default.escape = (text2) => text2;
}
var parseFString, mustacheTemplateToNodes, parseMustache, interpolateFString, interpolateMustache, DEFAULT_FORMATTER_MAPPING, DEFAULT_PARSER_MAPPING, renderTemplate, parseTemplate2, checkValidTemplate;
var init_template = __esm({
  "node_modules/@langchain/core/dist/prompts/template.js"() {
    init_errors2();
    init_mustache();
    parseFString = (template) => {
      const chars = template.split("");
      const nodes = [];
      const nextBracket = (bracket, start) => {
        for (let i$1 = start; i$1 < chars.length; i$1 += 1) if (bracket.includes(chars[i$1])) return i$1;
        return -1;
      };
      let i = 0;
      while (i < chars.length) if (chars[i] === "{" && i + 1 < chars.length && chars[i + 1] === "{") {
        nodes.push({
          type: "literal",
          text: "{"
        });
        i += 2;
      } else if (chars[i] === "}" && i + 1 < chars.length && chars[i + 1] === "}") {
        nodes.push({
          type: "literal",
          text: "}"
        });
        i += 2;
      } else if (chars[i] === "{") {
        const j = nextBracket("}", i);
        if (j < 0) throw new Error("Unclosed '{' in template.");
        nodes.push({
          type: "variable",
          name: chars.slice(i + 1, j).join("")
        });
        i = j + 1;
      } else if (chars[i] === "}") throw new Error("Single '}' in template.");
      else {
        const next = nextBracket("{}", i);
        const text2 = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join("");
        nodes.push({
          type: "literal",
          text: text2
        });
        i = next < 0 ? chars.length : next;
      }
      return nodes;
    };
    mustacheTemplateToNodes = (template, context2 = []) => {
      const nodes = [];
      for (const temp of template) if (temp[0] === "name") {
        const name = temp[1].includes(".") ? temp[1].split(".")[0] : temp[1];
        nodes.push({
          type: "variable",
          name
        });
      } else if ([
        "#",
        "&",
        "^",
        ">"
      ].includes(temp[0])) {
        nodes.push({
          type: "variable",
          name: temp[1]
        });
        if (temp[0] === "#" && temp.length > 4 && Array.isArray(temp[4])) {
          const newContext = [...context2, temp[1]];
          const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);
          nodes.push(...nestedNodes);
        }
      } else nodes.push({
        type: "literal",
        text: temp[1]
      });
      return nodes;
    };
    parseMustache = (template) => {
      configureMustache();
      const parsed = mustache_default.parse(template);
      return mustacheTemplateToNodes(parsed);
    };
    interpolateFString = (template, values) => {
      return parseFString(template).reduce((res, node) => {
        if (node.type === "variable") {
          if (node.name in values) {
            const stringValue = typeof values[node.name] === "string" ? values[node.name] : JSON.stringify(values[node.name]);
            return res + stringValue;
          }
          throw new Error(`(f-string) Missing value for input ${node.name}`);
        }
        return res + node.text;
      }, "");
    };
    interpolateMustache = (template, values) => {
      configureMustache();
      return mustache_default.render(template, values);
    };
    DEFAULT_FORMATTER_MAPPING = {
      "f-string": interpolateFString,
      mustache: interpolateMustache
    };
    DEFAULT_PARSER_MAPPING = {
      "f-string": parseFString,
      mustache: parseMustache
    };
    renderTemplate = (template, templateFormat, inputValues) => {
      try {
        return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);
      } catch (e) {
        const error40 = addLangChainErrorFields(e, "INVALID_PROMPT_INPUT");
        throw error40;
      }
    };
    parseTemplate2 = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);
    checkValidTemplate = (template, templateFormat, inputVariables) => {
      if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {
        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);
        throw new Error(`Invalid template format. Got \`${templateFormat}\`;
                         should be one of ${validFormats}`);
      }
      try {
        const dummyInputs = Object.fromEntries(inputVariables.map((v) => [v, "foo"]));
        if (Array.isArray(template)) template.forEach((message) => {
          if (message.type === "text" && "text" in message && typeof message.text === "string") renderTemplate(message.text, templateFormat, dummyInputs);
          else if (message.type === "image_url") {
            if (typeof message.image_url === "string") renderTemplate(message.image_url, templateFormat, dummyInputs);
            else if (typeof message.image_url === "object" && message.image_url !== null && "url" in message.image_url && typeof message.image_url.url === "string") {
              const imageUrl = message.image_url.url;
              renderTemplate(imageUrl, templateFormat, dummyInputs);
            }
          } else throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);
        });
        else renderTemplate(template, templateFormat, dummyInputs);
      } catch (e) {
        throw new Error(`Invalid prompt schema: ${e.message}`);
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/prompt.js
var PromptTemplate;
var init_prompt = __esm({
  "node_modules/@langchain/core/dist/prompts/prompt.js"() {
    init_string3();
    init_template();
    PromptTemplate = class PromptTemplate2 extends BaseStringPromptTemplate {
      static lc_name() {
        return "PromptTemplate";
      }
      template;
      templateFormat = "f-string";
      validateTemplate = true;
      /**
      * Additional fields which should be included inside
      * the message content array if using a complex message
      * content.
      */
      additionalContentFields;
      constructor(input) {
        super(input);
        if (input.templateFormat === "mustache" && input.validateTemplate === void 0) this.validateTemplate = false;
        Object.assign(this, input);
        if (this.validateTemplate) {
          if (this.templateFormat === "mustache") throw new Error("Mustache templates cannot be validated.");
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          checkValidTemplate(this.template, this.templateFormat, totalInputVariables);
        }
      }
      _getPromptType() {
        return "prompt";
      }
      /**
      * Formats the prompt template with the provided values.
      * @param values The values to be used to format the prompt template.
      * @returns A promise that resolves to a string which is the formatted prompt.
      */
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        return renderTemplate(this.template, this.templateFormat, allValues);
      }
      /**
      * Take examples in list format with prefix and suffix to create a prompt.
      *
      * Intended to be used a a way to dynamically create a prompt from examples.
      *
      * @param examples - List of examples to use in the prompt.
      * @param suffix - String to go after the list of examples. Should generally set up the user's input.
      * @param inputVariables - A list of variable names the final prompt template will expect
      * @param exampleSeparator - The separator to use in between examples
      * @param prefix - String that should go before any examples. Generally includes examples.
      *
      * @returns The final prompt template generated.
      */
      static fromExamples(examples, suffix, inputVariables, exampleSeparator = "\n\n", prefix = "") {
        const template = [
          prefix,
          ...examples,
          suffix
        ].join(exampleSeparator);
        return new PromptTemplate2({
          inputVariables,
          template
        });
      }
      static fromTemplate(template, options) {
        const { templateFormat = "f-string", ...rest } = options ?? {};
        const names = /* @__PURE__ */ new Set();
        parseTemplate2(template, templateFormat).forEach((node) => {
          if (node.type === "variable") names.add(node.name);
        });
        return new PromptTemplate2({
          inputVariables: [...names],
          templateFormat,
          template,
          ...rest
        });
      }
      /**
      * Partially applies values to the prompt template.
      * @param values The values to be partially applied to the prompt template.
      * @returns A new instance of PromptTemplate with the partially applied values.
      */
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new PromptTemplate2(promptDict);
      }
      serialize() {
        if (this.outputParser !== void 0) throw new Error("Cannot serialize a prompt template with an output parser");
        return {
          _type: this._getPromptType(),
          input_variables: this.inputVariables,
          template: this.template,
          template_format: this.templateFormat
        };
      }
      static async deserialize(data) {
        if (!data.template) throw new Error("Prompt template must have a template");
        const res = new PromptTemplate2({
          inputVariables: data.input_variables,
          template: data.template,
          templateFormat: data.template_format
        });
        return res;
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/image.js
var ImagePromptTemplate;
var init_image = __esm({
  "node_modules/@langchain/core/dist/prompts/image.js"() {
    init_prompt_values();
    init_base10();
    init_template();
    ImagePromptTemplate = class ImagePromptTemplate2 extends BasePromptTemplate {
      static lc_name() {
        return "ImagePromptTemplate";
      }
      lc_namespace = [
        "langchain_core",
        "prompts",
        "image"
      ];
      template;
      templateFormat = "f-string";
      validateTemplate = true;
      /**
      * Additional fields which should be included inside
      * the message content array if using a complex message
      * content.
      */
      additionalContentFields;
      constructor(input) {
        super(input);
        this.template = input.template;
        this.templateFormat = input.templateFormat ?? this.templateFormat;
        this.validateTemplate = input.validateTemplate ?? this.validateTemplate;
        this.additionalContentFields = input.additionalContentFields;
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          checkValidTemplate([{
            type: "image_url",
            image_url: this.template
          }], this.templateFormat, totalInputVariables);
        }
      }
      _getPromptType() {
        return "prompt";
      }
      /**
      * Partially applies values to the prompt template.
      * @param values The values to be partially applied to the prompt template.
      * @returns A new instance of ImagePromptTemplate with the partially applied values.
      */
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new ImagePromptTemplate2(promptDict);
      }
      /**
      * Formats the prompt template with the provided values.
      * @param values The values to be used to format the prompt template.
      * @returns A promise that resolves to a string which is the formatted prompt.
      */
      async format(values) {
        const formatted = {};
        for (const [key, value] of Object.entries(this.template)) if (typeof value === "string") formatted[key] = renderTemplate(value, this.templateFormat, values);
        else formatted[key] = value;
        const url2 = values.url || formatted.url;
        const detail = values.detail || formatted.detail;
        if (!url2) throw new Error("Must provide either an image URL.");
        if (typeof url2 !== "string") throw new Error("url must be a string.");
        const output = { url: url2 };
        if (detail) output.detail = detail;
        return output;
      }
      /**
      * Formats the prompt given the input values and returns a formatted
      * prompt value.
      * @param values The input values to format the prompt.
      * @returns A Promise that resolves to a formatted prompt value.
      */
      async formatPromptValue(values) {
        const formattedPrompt = await this.format(values);
        return new ImagePromptValue(formattedPrompt);
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/dict.js
function _getInputVariables(template, templateFormat) {
  const inputVariables = [];
  for (const v of Object.values(template)) if (typeof v === "string") parseTemplate2(v, templateFormat).forEach((t) => {
    if (t.type === "variable") inputVariables.push(t.name);
  });
  else if (Array.isArray(v)) {
    for (const x of v) if (typeof x === "string") parseTemplate2(x, templateFormat).forEach((t) => {
      if (t.type === "variable") inputVariables.push(t.name);
    });
    else if (typeof x === "object") inputVariables.push(..._getInputVariables(x, templateFormat));
  } else if (typeof v === "object" && v !== null) inputVariables.push(..._getInputVariables(v, templateFormat));
  return Array.from(new Set(inputVariables));
}
function _insertInputVariables(template, inputs, templateFormat) {
  const formatted = {};
  for (const [k, v] of Object.entries(template)) if (typeof v === "string") formatted[k] = renderTemplate(v, templateFormat, inputs);
  else if (Array.isArray(v)) {
    const formattedV = [];
    for (const x of v) if (typeof x === "string") formattedV.push(renderTemplate(x, templateFormat, inputs));
    else if (typeof x === "object") formattedV.push(_insertInputVariables(x, inputs, templateFormat));
    formatted[k] = formattedV;
  } else if (typeof v === "object" && v !== null) formatted[k] = _insertInputVariables(v, inputs, templateFormat);
  else formatted[k] = v;
  return formatted;
}
var DictPromptTemplate;
var init_dict = __esm({
  "node_modules/@langchain/core/dist/prompts/dict.js"() {
    init_base4();
    init_template();
    DictPromptTemplate = class extends Runnable {
      lc_namespace = [
        "langchain_core",
        "prompts",
        "dict"
      ];
      lc_serializable = true;
      template;
      templateFormat;
      inputVariables;
      static lc_name() {
        return "DictPromptTemplate";
      }
      constructor(fields) {
        const templateFormat = fields.templateFormat ?? "f-string";
        const inputVariables = _getInputVariables(fields.template, templateFormat);
        super({
          inputVariables,
          ...fields
        });
        this.template = fields.template;
        this.templateFormat = templateFormat;
        this.inputVariables = inputVariables;
      }
      async format(values) {
        return _insertInputVariables(this.template, values, this.templateFormat);
      }
      async invoke(values) {
        return await this._callWithConfig(this.format.bind(this), values, { runType: "prompt" });
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/chat.js
function isTextTemplateParam(param) {
  if (param === null || typeof param !== "object" || Array.isArray(param)) return false;
  return Object.keys(param).length === 1 && "text" in param && typeof param.text === "string";
}
function isImageTemplateParam(param) {
  if (param === null || typeof param !== "object" || Array.isArray(param)) return false;
  return "image_url" in param && (typeof param.image_url === "string" || typeof param.image_url === "object" && param.image_url !== null && "url" in param.image_url && typeof param.image_url.url === "string");
}
function _isBaseMessagePromptTemplate(baseMessagePromptTemplateLike) {
  return typeof baseMessagePromptTemplateLike.formatMessages === "function";
}
function _coerceMessagePromptTemplateLike(messagePromptTemplateLike, extra) {
  if (_isBaseMessagePromptTemplate(messagePromptTemplateLike) || isBaseMessage(messagePromptTemplateLike)) return messagePromptTemplateLike;
  if (Array.isArray(messagePromptTemplateLike) && messagePromptTemplateLike[0] === "placeholder") {
    const messageContent = messagePromptTemplateLike[1];
    if (extra?.templateFormat === "mustache" && typeof messageContent === "string" && messageContent.slice(0, 2) === "{{" && messageContent.slice(-2) === "}}") {
      const variableName = messageContent.slice(2, -2);
      return new MessagesPlaceholder({
        variableName,
        optional: true
      });
    } else if (typeof messageContent === "string" && messageContent[0] === "{" && messageContent[messageContent.length - 1] === "}") {
      const variableName = messageContent.slice(1, -1);
      return new MessagesPlaceholder({
        variableName,
        optional: true
      });
    }
    throw new Error(`Invalid placeholder template for format ${extra?.templateFormat ?? `"f-string"`}: "${messagePromptTemplateLike[1]}". Expected a variable name surrounded by ${extra?.templateFormat === "mustache" ? "double" : "single"} curly braces.`);
  }
  const message = coerceMessageLikeToMessage(messagePromptTemplateLike);
  let templateData;
  if (typeof message.content === "string") templateData = message.content;
  else templateData = message.content.map((item) => {
    if ("text" in item) return {
      ...item,
      text: item.text
    };
    else if ("image_url" in item) return {
      ...item,
      image_url: item.image_url
    };
    else return item;
  });
  if (message._getType() === "human") return HumanMessagePromptTemplate.fromTemplate(templateData, extra);
  else if (message._getType() === "ai") return AIMessagePromptTemplate.fromTemplate(templateData, extra);
  else if (message._getType() === "system") return SystemMessagePromptTemplate.fromTemplate(templateData, extra);
  else if (ChatMessage.isInstance(message)) return ChatMessagePromptTemplate.fromTemplate(message.content, message.role, extra);
  else throw new Error(`Could not coerce message prompt template from input. Received message type: "${message._getType()}".`);
}
function isMessagesPlaceholder(x) {
  return x.constructor.lc_name() === "MessagesPlaceholder";
}
var BaseMessagePromptTemplate, MessagesPlaceholder, BaseMessageStringPromptTemplate, BaseChatPromptTemplate, ChatMessagePromptTemplate, _StringImageMessagePromptTemplate, HumanMessagePromptTemplate, AIMessagePromptTemplate, SystemMessagePromptTemplate, ChatPromptTemplate;
var init_chat2 = __esm({
  "node_modules/@langchain/core/dist/prompts/chat.js"() {
    init_base();
    init_errors2();
    init_chat();
    init_human();
    init_system();
    init_utils3();
    init_ai();
    init_base4();
    init_messages2();
    init_prompt_values();
    init_base10();
    init_string3();
    init_template();
    init_prompt();
    init_image();
    init_dict();
    BaseMessagePromptTemplate = class extends Runnable {
      lc_namespace = [
        "langchain_core",
        "prompts",
        "chat"
      ];
      lc_serializable = true;
      /**
      * Calls the formatMessages method with the provided input and options.
      * @param input Input for the formatMessages method
      * @param options Optional BaseCallbackConfig
      * @returns Formatted output messages
      */
      async invoke(input, options) {
        return this._callWithConfig((input$1) => this.formatMessages(input$1), input, {
          ...options,
          runType: "prompt"
        });
      }
    };
    MessagesPlaceholder = class extends BaseMessagePromptTemplate {
      static lc_name() {
        return "MessagesPlaceholder";
      }
      variableName;
      optional;
      constructor(fields) {
        if (typeof fields === "string") fields = { variableName: fields };
        super(fields);
        this.variableName = fields.variableName;
        this.optional = fields.optional ?? false;
      }
      get inputVariables() {
        return [this.variableName];
      }
      async formatMessages(values) {
        const input = values[this.variableName];
        if (this.optional && !input) return [];
        else if (!input) {
          const error40 = /* @__PURE__ */ new Error(`Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);
          error40.name = "InputFormatError";
          throw error40;
        }
        let formattedMessages;
        try {
          if (Array.isArray(input)) formattedMessages = input.map(coerceMessageLikeToMessage);
          else formattedMessages = [coerceMessageLikeToMessage(input)];
        } catch (e) {
          const readableInput = typeof input === "string" ? input : JSON.stringify(input, null, 2);
          const error40 = new Error([
            `Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,
            `Received value: ${readableInput}`,
            `Additional message: ${e.message}`
          ].join("\n\n"));
          error40.name = "InputFormatError";
          error40.lc_error_code = e.lc_error_code;
          throw error40;
        }
        return formattedMessages;
      }
    };
    BaseMessageStringPromptTemplate = class extends BaseMessagePromptTemplate {
      prompt;
      constructor(fields) {
        if (!("prompt" in fields)) fields = { prompt: fields };
        super(fields);
        this.prompt = fields.prompt;
      }
      get inputVariables() {
        return this.prompt.inputVariables;
      }
      async formatMessages(values) {
        return [await this.format(values)];
      }
    };
    BaseChatPromptTemplate = class extends BasePromptTemplate {
      constructor(input) {
        super(input);
      }
      async format(values) {
        return (await this.formatPromptValue(values)).toString();
      }
      async formatPromptValue(values) {
        const resultMessages = await this.formatMessages(values);
        return new ChatPromptValue(resultMessages);
      }
    };
    ChatMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
      static lc_name() {
        return "ChatMessagePromptTemplate";
      }
      role;
      constructor(fields, role) {
        if (!("prompt" in fields)) fields = {
          prompt: fields,
          role
        };
        super(fields);
        this.role = fields.role;
      }
      async format(values) {
        return new ChatMessage(await this.prompt.format(values), this.role);
      }
      static fromTemplate(template, role, options) {
        return new this(PromptTemplate.fromTemplate(template, { templateFormat: options?.templateFormat }), role);
      }
    };
    _StringImageMessagePromptTemplate = class extends BaseMessagePromptTemplate {
      lc_namespace = [
        "langchain_core",
        "prompts",
        "chat"
      ];
      lc_serializable = true;
      inputVariables = [];
      additionalOptions = {};
      prompt;
      messageClass;
      static _messageClass() {
        throw new Error("Can not invoke _messageClass from inside _StringImageMessagePromptTemplate");
      }
      chatMessageClass;
      constructor(fields, additionalOptions) {
        if (!("prompt" in fields)) fields = { prompt: fields };
        super(fields);
        this.prompt = fields.prompt;
        if (Array.isArray(this.prompt)) {
          let inputVariables = [];
          this.prompt.forEach((prompt) => {
            if ("inputVariables" in prompt) inputVariables = inputVariables.concat(prompt.inputVariables);
          });
          this.inputVariables = inputVariables;
        } else this.inputVariables = this.prompt.inputVariables;
        this.additionalOptions = additionalOptions ?? this.additionalOptions;
      }
      createMessage(content) {
        const constructor = this.constructor;
        if (constructor._messageClass()) {
          const MsgClass = constructor._messageClass();
          return new MsgClass({ content });
        } else if (constructor.chatMessageClass) {
          const MsgClass = constructor.chatMessageClass();
          return new MsgClass({
            content,
            role: this.getRoleFromMessageClass(MsgClass.lc_name())
          });
        } else throw new Error("No message class defined");
      }
      getRoleFromMessageClass(name) {
        switch (name) {
          case "HumanMessage":
            return "human";
          case "AIMessage":
            return "ai";
          case "SystemMessage":
            return "system";
          case "ChatMessage":
            return "chat";
          default:
            throw new Error("Invalid message class name");
        }
      }
      static fromTemplate(template, additionalOptions) {
        if (typeof template === "string") return new this(PromptTemplate.fromTemplate(template, additionalOptions));
        const prompt = [];
        for (const item of template) if (typeof item === "string") prompt.push(PromptTemplate.fromTemplate(item, additionalOptions));
        else if (item === null) {
        } else if (isTextTemplateParam(item)) {
          let text2 = "";
          if (typeof item.text === "string") text2 = item.text ?? "";
          const options = {
            ...additionalOptions,
            additionalContentFields: item
          };
          prompt.push(PromptTemplate.fromTemplate(text2, options));
        } else if (isImageTemplateParam(item)) {
          let imgTemplate = item.image_url ?? "";
          let imgTemplateObject;
          let inputVariables = [];
          if (typeof imgTemplate === "string") {
            let parsedTemplate;
            if (additionalOptions?.templateFormat === "mustache") parsedTemplate = parseMustache(imgTemplate);
            else parsedTemplate = parseFString(imgTemplate);
            const variables = parsedTemplate.flatMap((item$1) => item$1.type === "variable" ? [item$1.name] : []);
            if ((variables?.length ?? 0) > 0) {
              if (variables.length > 1) throw new Error(`Only one format variable allowed per image template.
Got: ${variables}
From: ${imgTemplate}`);
              inputVariables = [variables[0]];
            } else inputVariables = [];
            imgTemplate = { url: imgTemplate };
            imgTemplateObject = new ImagePromptTemplate({
              template: imgTemplate,
              inputVariables,
              templateFormat: additionalOptions?.templateFormat,
              additionalContentFields: item
            });
          } else if (typeof imgTemplate === "object") {
            if ("url" in imgTemplate) {
              let parsedTemplate;
              if (additionalOptions?.templateFormat === "mustache") parsedTemplate = parseMustache(imgTemplate.url);
              else parsedTemplate = parseFString(imgTemplate.url);
              inputVariables = parsedTemplate.flatMap((item$1) => item$1.type === "variable" ? [item$1.name] : []);
            } else inputVariables = [];
            imgTemplateObject = new ImagePromptTemplate({
              template: imgTemplate,
              inputVariables,
              templateFormat: additionalOptions?.templateFormat,
              additionalContentFields: item
            });
          } else throw new Error("Invalid image template");
          prompt.push(imgTemplateObject);
        } else if (typeof item === "object") prompt.push(new DictPromptTemplate({
          template: item,
          templateFormat: additionalOptions?.templateFormat
        }));
        return new this({
          prompt,
          additionalOptions
        });
      }
      async format(input) {
        if (this.prompt instanceof BaseStringPromptTemplate) {
          const text2 = await this.prompt.format(input);
          return this.createMessage(text2);
        } else {
          const content = [];
          for (const prompt of this.prompt) {
            let inputs = {};
            if (!("inputVariables" in prompt)) throw new Error(`Prompt ${prompt} does not have inputVariables defined.`);
            for (const item of prompt.inputVariables) {
              if (!inputs) inputs = { [item]: input[item] };
              inputs = {
                ...inputs,
                [item]: input[item]
              };
            }
            if (prompt instanceof BaseStringPromptTemplate) {
              const formatted = await prompt.format(inputs);
              let additionalContentFields;
              if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
              if (formatted !== "") content.push({
                ...additionalContentFields,
                type: "text",
                text: formatted
              });
            } else if (prompt instanceof ImagePromptTemplate) {
              const formatted = await prompt.format(inputs);
              let additionalContentFields;
              if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
              content.push({
                ...additionalContentFields,
                type: "image_url",
                image_url: formatted
              });
            } else if (prompt instanceof DictPromptTemplate) {
              const formatted = await prompt.format(inputs);
              let additionalContentFields;
              if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
              content.push({
                ...additionalContentFields,
                ...formatted
              });
            }
          }
          return this.createMessage(content);
        }
      }
      async formatMessages(values) {
        return [await this.format(values)];
      }
    };
    HumanMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
      static _messageClass() {
        return HumanMessage;
      }
      static lc_name() {
        return "HumanMessagePromptTemplate";
      }
    };
    AIMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
      static _messageClass() {
        return AIMessage;
      }
      static lc_name() {
        return "AIMessagePromptTemplate";
      }
    };
    SystemMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
      static _messageClass() {
        return SystemMessage;
      }
      static lc_name() {
        return "SystemMessagePromptTemplate";
      }
    };
    ChatPromptTemplate = class ChatPromptTemplate2 extends BaseChatPromptTemplate {
      static lc_name() {
        return "ChatPromptTemplate";
      }
      get lc_aliases() {
        return { promptMessages: "messages" };
      }
      promptMessages;
      validateTemplate = true;
      templateFormat = "f-string";
      constructor(input) {
        super(input);
        if (input.templateFormat === "mustache" && input.validateTemplate === void 0) this.validateTemplate = false;
        Object.assign(this, input);
        if (this.validateTemplate) {
          const inputVariablesMessages = /* @__PURE__ */ new Set();
          for (const promptMessage of this.promptMessages) {
            if (promptMessage instanceof BaseMessage) continue;
            for (const inputVariable of promptMessage.inputVariables) inputVariablesMessages.add(inputVariable);
          }
          const totalInputVariables = this.inputVariables;
          const inputVariablesInstance = new Set(this.partialVariables ? totalInputVariables.concat(Object.keys(this.partialVariables)) : totalInputVariables);
          const difference = new Set([...inputVariablesInstance].filter((x) => !inputVariablesMessages.has(x)));
          if (difference.size > 0) throw new Error(`Input variables \`${[...difference]}\` are not used in any of the prompt messages.`);
          const otherDifference = new Set([...inputVariablesMessages].filter((x) => !inputVariablesInstance.has(x)));
          if (otherDifference.size > 0) throw new Error(`Input variables \`${[...otherDifference]}\` are used in prompt messages but not in the prompt template.`);
        }
      }
      _getPromptType() {
        return "chat";
      }
      async _parseImagePrompts(message, inputValues) {
        if (typeof message.content === "string") return message;
        const formattedMessageContent = await Promise.all(message.content.map(async (item) => {
          if (item.type !== "image_url") return item;
          let imageUrl = "";
          if (typeof item.image_url === "string") imageUrl = item.image_url;
          else if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url && typeof item.image_url.url === "string") imageUrl = item.image_url.url;
          const promptTemplatePlaceholder = PromptTemplate.fromTemplate(imageUrl, { templateFormat: this.templateFormat });
          const formattedUrl = await promptTemplatePlaceholder.format(inputValues);
          if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url) item.image_url.url = formattedUrl;
          else item.image_url = formattedUrl;
          return item;
        }));
        message.content = formattedMessageContent;
        return message;
      }
      async formatMessages(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        let resultMessages = [];
        for (const promptMessage of this.promptMessages) if (promptMessage instanceof BaseMessage) resultMessages.push(await this._parseImagePrompts(promptMessage, allValues));
        else {
          let inputValues;
          if (this.templateFormat === "mustache") inputValues = { ...allValues };
          else inputValues = promptMessage.inputVariables.reduce((acc, inputVariable) => {
            if (!(inputVariable in allValues) && !(isMessagesPlaceholder(promptMessage) && promptMessage.optional)) {
              const error40 = addLangChainErrorFields(/* @__PURE__ */ new Error(`Missing value for input variable \`${inputVariable.toString()}\``), "INVALID_PROMPT_INPUT");
              throw error40;
            }
            acc[inputVariable] = allValues[inputVariable];
            return acc;
          }, {});
          const message = await promptMessage.formatMessages(inputValues);
          resultMessages = resultMessages.concat(message);
        }
        return resultMessages;
      }
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new ChatPromptTemplate2(promptDict);
      }
      static fromTemplate(template, options) {
        const prompt = PromptTemplate.fromTemplate(template, options);
        const humanTemplate = new HumanMessagePromptTemplate({ prompt });
        return this.fromMessages([humanTemplate]);
      }
      /**
      * Create a chat model-specific prompt from individual chat messages
      * or message-like tuples.
      * @param promptMessages Messages to be passed to the chat model
      * @returns A new ChatPromptTemplate
      */
      static fromMessages(promptMessages, extra) {
        const flattenedMessages = promptMessages.reduce((acc, promptMessage) => acc.concat(promptMessage instanceof ChatPromptTemplate2 ? promptMessage.promptMessages : [_coerceMessagePromptTemplateLike(promptMessage, extra)]), []);
        const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage) => promptMessage instanceof ChatPromptTemplate2 ? Object.assign(acc, promptMessage.partialVariables) : acc, /* @__PURE__ */ Object.create(null));
        const inputVariables = /* @__PURE__ */ new Set();
        for (const promptMessage of flattenedMessages) {
          if (promptMessage instanceof BaseMessage) continue;
          for (const inputVariable of promptMessage.inputVariables) {
            if (inputVariable in flattenedPartialVariables) continue;
            inputVariables.add(inputVariable);
          }
        }
        return new this({
          ...extra,
          inputVariables: [...inputVariables],
          promptMessages: flattenedMessages,
          partialVariables: flattenedPartialVariables,
          templateFormat: extra?.templateFormat
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/few_shot.js
var FewShotPromptTemplate, FewShotChatMessagePromptTemplate;
var init_few_shot = __esm({
  "node_modules/@langchain/core/dist/prompts/few_shot.js"() {
    init_string3();
    init_template();
    init_prompt();
    init_chat2();
    FewShotPromptTemplate = class FewShotPromptTemplate2 extends BaseStringPromptTemplate {
      lc_serializable = false;
      examples;
      exampleSelector;
      examplePrompt;
      suffix = "";
      exampleSeparator = "\n\n";
      prefix = "";
      templateFormat = "f-string";
      validateTemplate = true;
      constructor(input) {
        super(input);
        Object.assign(this, input);
        if (this.examples !== void 0 && this.exampleSelector !== void 0) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
        if (this.examples === void 0 && this.exampleSelector === void 0) throw new Error("One of 'examples' and 'example_selector' should be provided");
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
        }
      }
      _getPromptType() {
        return "few_shot";
      }
      static lc_name() {
        return "FewShotPromptTemplate";
      }
      async getExamples(inputVariables) {
        if (this.examples !== void 0) return this.examples;
        if (this.exampleSelector !== void 0) return this.exampleSelector.selectExamples(inputVariables);
        throw new Error("One of 'examples' and 'example_selector' should be provided");
      }
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new FewShotPromptTemplate2(promptDict);
      }
      /**
      * Formats the prompt with the given values.
      * @param values The values to format the prompt with.
      * @returns A promise that resolves to a string representing the formatted prompt.
      */
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        const examples = await this.getExamples(allValues);
        const exampleStrings = await Promise.all(examples.map((example) => this.examplePrompt.format(example)));
        const template = [
          this.prefix,
          ...exampleStrings,
          this.suffix
        ].join(this.exampleSeparator);
        return renderTemplate(template, this.templateFormat, allValues);
      }
      serialize() {
        if (this.exampleSelector || !this.examples) throw new Error("Serializing an example selector is not currently supported");
        if (this.outputParser !== void 0) throw new Error("Serializing an output parser is not currently supported");
        return {
          _type: this._getPromptType(),
          input_variables: this.inputVariables,
          example_prompt: this.examplePrompt.serialize(),
          example_separator: this.exampleSeparator,
          suffix: this.suffix,
          prefix: this.prefix,
          template_format: this.templateFormat,
          examples: this.examples
        };
      }
      static async deserialize(data) {
        const { example_prompt } = data;
        if (!example_prompt) throw new Error("Missing example prompt");
        const examplePrompt = await PromptTemplate.deserialize(example_prompt);
        let examples;
        if (Array.isArray(data.examples)) examples = data.examples;
        else throw new Error("Invalid examples format. Only list or string are supported.");
        return new FewShotPromptTemplate2({
          inputVariables: data.input_variables,
          examplePrompt,
          examples,
          exampleSeparator: data.example_separator,
          prefix: data.prefix,
          suffix: data.suffix,
          templateFormat: data.template_format
        });
      }
    };
    FewShotChatMessagePromptTemplate = class FewShotChatMessagePromptTemplate2 extends BaseChatPromptTemplate {
      lc_serializable = true;
      examples;
      exampleSelector;
      examplePrompt;
      suffix = "";
      exampleSeparator = "\n\n";
      prefix = "";
      templateFormat = "f-string";
      validateTemplate = true;
      _getPromptType() {
        return "few_shot_chat";
      }
      static lc_name() {
        return "FewShotChatMessagePromptTemplate";
      }
      constructor(fields) {
        super(fields);
        this.examples = fields.examples;
        this.examplePrompt = fields.examplePrompt;
        this.exampleSeparator = fields.exampleSeparator ?? "\n\n";
        this.exampleSelector = fields.exampleSelector;
        this.prefix = fields.prefix ?? "";
        this.suffix = fields.suffix ?? "";
        this.templateFormat = fields.templateFormat ?? "f-string";
        this.validateTemplate = fields.validateTemplate ?? true;
        if (this.examples !== void 0 && this.exampleSelector !== void 0) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
        if (this.examples === void 0 && this.exampleSelector === void 0) throw new Error("One of 'examples' and 'example_selector' should be provided");
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
        }
      }
      async getExamples(inputVariables) {
        if (this.examples !== void 0) return this.examples;
        if (this.exampleSelector !== void 0) return this.exampleSelector.selectExamples(inputVariables);
        throw new Error("One of 'examples' and 'example_selector' should be provided");
      }
      /**
      * Formats the list of values and returns a list of formatted messages.
      * @param values The values to format the prompt with.
      * @returns A promise that resolves to a string representing the formatted prompt.
      */
      async formatMessages(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        let examples = await this.getExamples(allValues);
        examples = examples.map((example) => {
          const result = {};
          this.examplePrompt.inputVariables.forEach((inputVariable) => {
            result[inputVariable] = example[inputVariable];
          });
          return result;
        });
        const messages = [];
        for (const example of examples) {
          const exampleMessages = await this.examplePrompt.formatMessages(example);
          messages.push(...exampleMessages);
        }
        return messages;
      }
      /**
      * Formats the prompt with the given values.
      * @param values The values to format the prompt with.
      * @returns A promise that resolves to a string representing the formatted prompt.
      */
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        const examples = await this.getExamples(allValues);
        const exampleMessages = await Promise.all(examples.map((example) => this.examplePrompt.formatMessages(example)));
        const exampleStrings = exampleMessages.flat().map((message) => message.content);
        const template = [
          this.prefix,
          ...exampleStrings,
          this.suffix
        ].join(this.exampleSeparator);
        return renderTemplate(template, this.templateFormat, allValues);
      }
      /**
      * Partially formats the prompt with the given values.
      * @param values The values to partially format the prompt with.
      * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.
      */
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((variable) => !(variable in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new FewShotChatMessagePromptTemplate2(promptDict);
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/pipeline.js
var PipelinePromptTemplate;
var init_pipeline2 = __esm({
  "node_modules/@langchain/core/dist/prompts/pipeline.js"() {
    init_base10();
    init_chat2();
    PipelinePromptTemplate = class PipelinePromptTemplate2 extends BasePromptTemplate {
      static lc_name() {
        return "PipelinePromptTemplate";
      }
      pipelinePrompts;
      finalPrompt;
      constructor(input) {
        super({
          ...input,
          inputVariables: []
        });
        this.pipelinePrompts = input.pipelinePrompts;
        this.finalPrompt = input.finalPrompt;
        this.inputVariables = this.computeInputValues();
      }
      /**
      * Computes the input values required by the pipeline prompts.
      * @returns Array of input values required by the pipeline prompts.
      */
      computeInputValues() {
        const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);
        const inputValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue))).flat();
        return [...new Set(inputValues)];
      }
      static extractRequiredInputValues(allValues, requiredValueNames) {
        return requiredValueNames.reduce((requiredValues, valueName) => {
          requiredValues[valueName] = allValues[valueName];
          return requiredValues;
        }, {});
      }
      /**
      * Formats the pipeline prompts based on the provided input values.
      * @param values Input values to format the pipeline prompts.
      * @returns Promise that resolves with the formatted input values.
      */
      async formatPipelinePrompts(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this.pipelinePrompts) {
          const pipelinePromptInputValues = PipelinePromptTemplate2.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);
          if (pipelinePrompt instanceof ChatPromptTemplate) allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);
          else allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);
        }
        return PipelinePromptTemplate2.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);
      }
      /**
      * Formats the final prompt value based on the provided input values.
      * @param values Input values to format the final prompt value.
      * @returns Promise that resolves with the formatted final prompt value.
      */
      async formatPromptValue(values) {
        return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));
      }
      async format(values) {
        return this.finalPrompt.format(await this.formatPipelinePrompts(values));
      }
      /**
      * Handles partial prompts, which are prompts that have been partially
      * filled with input values.
      * @param values Partial input values.
      * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.
      */
      async partial(values) {
        const promptDict = { ...this };
        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));
        promptDict.partialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        return new PipelinePromptTemplate2(promptDict);
      }
      serialize() {
        throw new Error("Not implemented.");
      }
      _getPromptType() {
        return "pipeline";
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/structured.js
function isWithStructuredOutput(x) {
  return typeof x === "object" && x != null && "withStructuredOutput" in x && typeof x.withStructuredOutput === "function";
}
function isRunnableBinding(x) {
  return typeof x === "object" && x != null && "lc_id" in x && Array.isArray(x.lc_id) && x.lc_id.join("/") === "langchain_core/runnables/RunnableBinding";
}
var StructuredPrompt;
var init_structured2 = __esm({
  "node_modules/@langchain/core/dist/prompts/structured.js"() {
    init_base4();
    init_chat2();
    StructuredPrompt = class StructuredPrompt2 extends ChatPromptTemplate {
      schema;
      method;
      lc_namespace = [
        "langchain_core",
        "prompts",
        "structured"
      ];
      get lc_aliases() {
        return {
          ...super.lc_aliases,
          schema: "schema_"
        };
      }
      constructor(input) {
        super(input);
        this.schema = input.schema;
        this.method = input.method;
      }
      pipe(coerceable) {
        if (isWithStructuredOutput(coerceable)) return super.pipe(coerceable.withStructuredOutput(this.schema));
        if (isRunnableBinding(coerceable) && isWithStructuredOutput(coerceable.bound)) return super.pipe(new RunnableBinding({
          bound: coerceable.bound.withStructuredOutput(this.schema, ...this.method ? [{ method: this.method }] : []),
          kwargs: coerceable.kwargs ?? {},
          config: coerceable.config,
          configFactories: coerceable.configFactories
        }));
        throw new Error(`Structured prompts need to be piped to a language model that supports the "withStructuredOutput()" method.`);
      }
      static fromMessagesAndSchema(promptMessages, schema, method) {
        return StructuredPrompt2.fromMessages(promptMessages, {
          schema,
          method
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/prompts/index.js
var prompts_exports;
var init_prompts2 = __esm({
  "node_modules/@langchain/core/dist/prompts/index.js"() {
    init_rolldown_runtime();
    init_base10();
    init_string3();
    init_template();
    init_prompt();
    init_image();
    init_dict();
    init_chat2();
    init_few_shot();
    init_pipeline2();
    init_structured2();
    prompts_exports = {};
    __export2(prompts_exports, {
      AIMessagePromptTemplate: () => AIMessagePromptTemplate,
      BaseChatPromptTemplate: () => BaseChatPromptTemplate,
      BaseMessagePromptTemplate: () => BaseMessagePromptTemplate,
      BaseMessageStringPromptTemplate: () => BaseMessageStringPromptTemplate,
      BasePromptTemplate: () => BasePromptTemplate,
      BaseStringPromptTemplate: () => BaseStringPromptTemplate,
      ChatMessagePromptTemplate: () => ChatMessagePromptTemplate,
      ChatPromptTemplate: () => ChatPromptTemplate,
      DEFAULT_FORMATTER_MAPPING: () => DEFAULT_FORMATTER_MAPPING,
      DEFAULT_PARSER_MAPPING: () => DEFAULT_PARSER_MAPPING,
      DictPromptTemplate: () => DictPromptTemplate,
      FewShotChatMessagePromptTemplate: () => FewShotChatMessagePromptTemplate,
      FewShotPromptTemplate: () => FewShotPromptTemplate,
      HumanMessagePromptTemplate: () => HumanMessagePromptTemplate,
      ImagePromptTemplate: () => ImagePromptTemplate,
      MessagesPlaceholder: () => MessagesPlaceholder,
      PipelinePromptTemplate: () => PipelinePromptTemplate,
      PromptTemplate: () => PromptTemplate,
      StructuredPrompt: () => StructuredPrompt,
      SystemMessagePromptTemplate: () => SystemMessagePromptTemplate,
      checkValidTemplate: () => checkValidTemplate,
      interpolateFString: () => interpolateFString,
      interpolateMustache: () => interpolateMustache,
      parseFString: () => parseFString,
      parseMustache: () => parseMustache,
      parseTemplate: () => parseTemplate2,
      renderTemplate: () => renderTemplate
    });
  }
});

// node_modules/@langchain/core/dist/retrievers/document_compressors/index.js
var document_compressors_exports, BaseDocumentCompressor;
var init_document_compressors = __esm({
  "node_modules/@langchain/core/dist/retrievers/document_compressors/index.js"() {
    init_rolldown_runtime();
    document_compressors_exports = {};
    __export2(document_compressors_exports, { BaseDocumentCompressor: () => BaseDocumentCompressor });
    BaseDocumentCompressor = class {
      static isBaseDocumentCompressor(x) {
        return x?.compressDocuments !== void 0;
      }
    };
  }
});

// node_modules/@langchain/core/dist/structured_query/ir.js
var Operators, Comparators, Visitor, Expression, FilterDirective, Comparison, Operation, StructuredQuery;
var init_ir = __esm({
  "node_modules/@langchain/core/dist/structured_query/ir.js"() {
    Operators = {
      and: "and",
      or: "or",
      not: "not"
    };
    Comparators = {
      eq: "eq",
      ne: "ne",
      lt: "lt",
      gt: "gt",
      lte: "lte",
      gte: "gte"
    };
    Visitor = class {
    };
    Expression = class {
      accept(visitor) {
        if (this.exprName === "Operation") return visitor.visitOperation(this);
        else if (this.exprName === "Comparison") return visitor.visitComparison(this);
        else if (this.exprName === "StructuredQuery") return visitor.visitStructuredQuery(this);
        else throw new Error("Unknown Expression type");
      }
    };
    FilterDirective = class extends Expression {
    };
    Comparison = class extends FilterDirective {
      exprName = "Comparison";
      constructor(comparator, attribute, value) {
        super();
        this.comparator = comparator;
        this.attribute = attribute;
        this.value = value;
      }
    };
    Operation = class extends FilterDirective {
      exprName = "Operation";
      constructor(operator, args) {
        super();
        this.operator = operator;
        this.args = args;
      }
    };
    StructuredQuery = class extends Expression {
      exprName = "StructuredQuery";
      constructor(query, filter) {
        super();
        this.query = query;
        this.filter = filter;
      }
    };
  }
});

// node_modules/@langchain/core/dist/structured_query/utils.js
function isObject2(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
}
function isFilterEmpty(filter) {
  if (!filter) return true;
  if (typeof filter === "string" && filter.length > 0) return false;
  if (typeof filter === "function") return false;
  return isObject2(filter) && Object.keys(filter).length === 0;
}
function isInt(value) {
  if (typeof value === "number") return value % 1 === 0;
  else if (typeof value === "string") {
    const numberValue = parseInt(value, 10);
    return !Number.isNaN(numberValue) && numberValue % 1 === 0 && numberValue.toString() === value;
  }
  return false;
}
function isFloat(value) {
  if (typeof value === "number") return value % 1 !== 0;
  else if (typeof value === "string") {
    const numberValue = parseFloat(value);
    return !Number.isNaN(numberValue) && numberValue % 1 !== 0 && numberValue.toString() === value;
  }
  return false;
}
function isString(value) {
  return typeof value === "string" && (Number.isNaN(parseFloat(value)) || parseFloat(value).toString() !== value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function castValue(input) {
  let value;
  if (isString(input)) value = input;
  else if (isInt(input)) value = parseInt(input, 10);
  else if (isFloat(input)) value = parseFloat(input);
  else if (isBoolean(input)) value = Boolean(input);
  else throw new Error("Unsupported value type");
  return value;
}
var init_utils6 = __esm({
  "node_modules/@langchain/core/dist/structured_query/utils.js"() {
  }
});

// node_modules/@langchain/core/dist/structured_query/base.js
var BaseTranslator, BasicTranslator;
var init_base11 = __esm({
  "node_modules/@langchain/core/dist/structured_query/base.js"() {
    init_ir();
    init_utils6();
    BaseTranslator = class extends Visitor {
    };
    BasicTranslator = class extends BaseTranslator {
      allowedOperators;
      allowedComparators;
      constructor(opts) {
        super();
        this.allowedOperators = opts?.allowedOperators ?? [Operators.and, Operators.or];
        this.allowedComparators = opts?.allowedComparators ?? [
          Comparators.eq,
          Comparators.ne,
          Comparators.gt,
          Comparators.gte,
          Comparators.lt,
          Comparators.lte
        ];
      }
      formatFunction(func) {
        if (func in Comparators) {
          if (this.allowedComparators.length > 0 && this.allowedComparators.indexOf(func) === -1) throw new Error(`Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(", ")}`);
        } else if (func in Operators) {
          if (this.allowedOperators.length > 0 && this.allowedOperators.indexOf(func) === -1) throw new Error(`Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(", ")}`);
        } else throw new Error("Unknown comparator or operator");
        return `$${func}`;
      }
      /**
      * Visits an operation and returns a result.
      * @param operation The operation to visit.
      * @returns The result of visiting the operation.
      */
      visitOperation(operation) {
        const args = operation.args?.map((arg) => arg.accept(this));
        return { [this.formatFunction(operation.operator)]: args };
      }
      /**
      * Visits a comparison and returns a result.
      * @param comparison The comparison to visit.
      * @returns The result of visiting the comparison.
      */
      visitComparison(comparison) {
        return { [comparison.attribute]: { [this.formatFunction(comparison.comparator)]: castValue(comparison.value) } };
      }
      /**
      * Visits a structured query and returns a result.
      * @param query The structured query to visit.
      * @returns The result of visiting the structured query.
      */
      visitStructuredQuery(query) {
        let nextArg = {};
        if (query.filter) nextArg = { filter: query.filter.accept(this) };
        return nextArg;
      }
      mergeFilters(defaultFilter, generatedFilter, mergeType = "and", forceDefaultFilter = false) {
        if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) return void 0;
        if (isFilterEmpty(defaultFilter) || mergeType === "replace") {
          if (isFilterEmpty(generatedFilter)) return void 0;
          return generatedFilter;
        }
        if (isFilterEmpty(generatedFilter)) {
          if (forceDefaultFilter) return defaultFilter;
          if (mergeType === "and") return void 0;
          return defaultFilter;
        }
        if (mergeType === "and") return { $and: [defaultFilter, generatedFilter] };
        else if (mergeType === "or") return { $or: [defaultFilter, generatedFilter] };
        else throw new Error("Unknown merge type");
      }
    };
  }
});

// node_modules/@langchain/core/dist/structured_query/functional.js
var FunctionalTranslator;
var init_functional = __esm({
  "node_modules/@langchain/core/dist/structured_query/functional.js"() {
    init_ir();
    init_utils6();
    init_base11();
    FunctionalTranslator = class extends BaseTranslator {
      allowedOperators = [Operators.and, Operators.or];
      allowedComparators = [
        Comparators.eq,
        Comparators.ne,
        Comparators.gt,
        Comparators.gte,
        Comparators.lt,
        Comparators.lte
      ];
      formatFunction() {
        throw new Error("Not implemented");
      }
      /**
      * Returns the allowed comparators for a given data type.
      * @param input The input value to get the allowed comparators for.
      * @returns An array of allowed comparators for the input data type.
      */
      getAllowedComparatorsForType(inputType) {
        switch (inputType) {
          case "string":
            return [
              Comparators.eq,
              Comparators.ne,
              Comparators.gt,
              Comparators.gte,
              Comparators.lt,
              Comparators.lte
            ];
          case "number":
            return [
              Comparators.eq,
              Comparators.ne,
              Comparators.gt,
              Comparators.gte,
              Comparators.lt,
              Comparators.lte
            ];
          case "boolean":
            return [Comparators.eq, Comparators.ne];
          default:
            throw new Error(`Unsupported data type: ${inputType}`);
        }
      }
      /**
      * Returns a function that performs a comparison based on the provided
      * comparator.
      * @param comparator The comparator to base the comparison function on.
      * @returns A function that takes two arguments and returns a boolean based on the comparison.
      */
      getComparatorFunction(comparator) {
        switch (comparator) {
          case Comparators.eq:
            return (a, b) => a === b;
          case Comparators.ne:
            return (a, b) => a !== b;
          case Comparators.gt:
            return (a, b) => a > b;
          case Comparators.gte:
            return (a, b) => a >= b;
          case Comparators.lt:
            return (a, b) => a < b;
          case Comparators.lte:
            return (a, b) => a <= b;
          default:
            throw new Error("Unknown comparator");
        }
      }
      /**
      * Returns a function that performs an operation based on the provided
      * operator.
      * @param operator The operator to base the operation function on.
      * @returns A function that takes two boolean arguments and returns a boolean based on the operation.
      */
      getOperatorFunction(operator) {
        switch (operator) {
          case Operators.and:
            return (a, b) => a && b;
          case Operators.or:
            return (a, b) => a || b;
          default:
            throw new Error("Unknown operator");
        }
      }
      /**
      * Visits the operation part of a structured query and translates it into
      * a functional filter.
      * @param operation The operation part of a structured query.
      * @returns A function that takes a `Document` as an argument and returns a boolean based on the operation.
      */
      visitOperation(operation) {
        const { operator, args } = operation;
        if (this.allowedOperators.includes(operator)) {
          const operatorFunction = this.getOperatorFunction(operator);
          return (document) => {
            if (!args) return true;
            return args.reduce((acc, arg) => {
              const result = arg.accept(this);
              if (typeof result === "function") return operatorFunction(acc, result(document));
              else throw new Error("Filter is not a function");
            }, true);
          };
        } else throw new Error("Operator not allowed");
      }
      /**
      * Visits the comparison part of a structured query and translates it into
      * a functional filter.
      * @param comparison The comparison part of a structured query.
      * @returns A function that takes a `Document` as an argument and returns a boolean based on the comparison.
      */
      visitComparison(comparison) {
        const { comparator, attribute, value } = comparison;
        const undefinedTrue = [Comparators.ne];
        if (this.allowedComparators.includes(comparator)) {
          if (!this.getAllowedComparatorsForType(typeof value).includes(comparator)) throw new Error(`'${comparator}' comparator not allowed to be used with ${typeof value}`);
          const comparatorFunction = this.getComparatorFunction(comparator);
          return (document) => {
            const documentValue = document.metadata[attribute];
            if (documentValue === void 0) {
              if (undefinedTrue.includes(comparator)) return true;
              return false;
            }
            return comparatorFunction(documentValue, castValue(value));
          };
        } else throw new Error("Comparator not allowed");
      }
      /**
      * Visits a structured query and translates it into a functional filter.
      * @param query The structured query to translate.
      * @returns An object containing a `filter` property, which is a function that takes a `Document` as an argument and returns a boolean based on the structured query.
      */
      visitStructuredQuery(query) {
        if (!query.filter) return {};
        const filterFunction = query.filter?.accept(this);
        if (typeof filterFunction !== "function") throw new Error("Structured query filter is not a function");
        return { filter: filterFunction };
      }
      /**
      * Merges two filters into one, based on the specified merge type.
      * @param defaultFilter The default filter function.
      * @param generatedFilter The generated filter function.
      * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'. Default is 'and'.
      * @returns A function that takes a `Document` as an argument and returns a boolean based on the merged filters, or `undefined` if both filters are empty.
      */
      mergeFilters(defaultFilter, generatedFilter, mergeType = "and") {
        if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) return void 0;
        if (isFilterEmpty(defaultFilter) || mergeType === "replace") {
          if (isFilterEmpty(generatedFilter)) return void 0;
          return generatedFilter;
        }
        if (isFilterEmpty(generatedFilter)) {
          if (mergeType === "and") return void 0;
          return defaultFilter;
        }
        if (mergeType === "and") return (document) => defaultFilter(document) && generatedFilter(document);
        else if (mergeType === "or") return (document) => defaultFilter(document) || generatedFilter(document);
        else throw new Error("Unknown merge type");
      }
    };
  }
});

// node_modules/@langchain/core/dist/structured_query/index.js
var structured_query_exports;
var init_structured_query = __esm({
  "node_modules/@langchain/core/dist/structured_query/index.js"() {
    init_rolldown_runtime();
    init_ir();
    init_utils6();
    init_base11();
    init_functional();
    structured_query_exports = {};
    __export2(structured_query_exports, {
      BaseTranslator: () => BaseTranslator,
      BasicTranslator: () => BasicTranslator,
      Comparators: () => Comparators,
      Comparison: () => Comparison,
      Expression: () => Expression,
      FilterDirective: () => FilterDirective,
      FunctionalTranslator: () => FunctionalTranslator,
      Operation: () => Operation,
      Operators: () => Operators,
      StructuredQuery: () => StructuredQuery,
      Visitor: () => Visitor,
      castValue: () => castValue,
      isBoolean: () => isBoolean,
      isFilterEmpty: () => isFilterEmpty,
      isFloat: () => isFloat,
      isInt: () => isInt,
      isObject: () => isObject2,
      isString: () => isString
    });
  }
});

// node_modules/@langchain/core/dist/tools/types.js
function isStructuredTool(tool2) {
  return tool2 !== void 0 && Array.isArray(tool2.lc_namespace);
}
function isRunnableToolLike(tool2) {
  return tool2 !== void 0 && Runnable.isRunnable(tool2) && "lc_name" in tool2.constructor && typeof tool2.constructor.lc_name === "function" && tool2.constructor.lc_name() === "RunnableToolLike";
}
function isStructuredToolParams(tool2) {
  return !!tool2 && typeof tool2 === "object" && "name" in tool2 && "schema" in tool2 && (isInteropZodSchema(tool2.schema) || tool2.schema != null && typeof tool2.schema === "object" && "type" in tool2.schema && typeof tool2.schema.type === "string" && [
    "null",
    "boolean",
    "object",
    "array",
    "number",
    "string"
  ].includes(tool2.schema.type));
}
function isLangChainTool(tool2) {
  return isStructuredToolParams(tool2) || isRunnableToolLike(tool2) || isStructuredTool(tool2);
}
var init_types4 = __esm({
  "node_modules/@langchain/core/dist/tools/types.js"() {
    init_zod2();
    init_base4();
  }
});

// node_modules/zod/v4/classic/checks.js
var init_checks2 = __esm({
  "node_modules/zod/v4/classic/checks.js"() {
    init_core3();
  }
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date3,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time3
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date3(params) {
  return _isoDate(ZodISODate, params);
}
function time3(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/zod/v4/classic/iso.js"() {
    init_core3();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
  }
});

// node_modules/zod/v4/classic/errors.js
var initializer2, ZodError2, ZodRealError;
var init_errors5 = __esm({
  "node_modules/zod/v4/classic/errors.js"() {
    init_core3();
    init_core3();
    initializer2 = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue2) => inst.issues.push(issue2)
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => inst.issues.push(...issues2)
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError2 = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/zod/v4/classic/parse.js
var parse7, parseAsync2, safeParse2, safeParseAsync2;
var init_parse5 = __esm({
  "node_modules/zod/v4/classic/parse.js"() {
    init_core3();
    init_errors5();
    parse7 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  }
});

// node_modules/zod/v4/classic/schemas.js
function string2(params) {
  return _string(ZodString2, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base643(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format2, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format2, fnOrRegex, _params);
}
function number2(params) {
  return _number(ZodNumber2, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt2, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol2, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
function _null3(params) {
  return _null2(ZodNull2, params);
}
function any() {
  return _any(ZodAny2);
}
function unknown() {
  return _unknown(ZodUnknown2);
}
function never(params) {
  return _never(ZodNever2, params);
}
function _void2(params) {
  return _void(ZodVoid2, params);
}
function date4(params) {
  return _date(ZodDate2, params);
}
function array(element, params) {
  return _array(ZodArray2, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN2, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType2, _ZodString, ZodString2, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber2, ZodNumberFormat, ZodBoolean2, ZodBigInt2, ZodBigIntFormat, ZodSymbol2, ZodUndefined2, ZodNull2, ZodAny2, ZodUnknown2, ZodNever2, ZodVoid2, ZodDate2, ZodArray2, ZodObject2, ZodUnion2, ZodDiscriminatedUnion2, ZodIntersection2, ZodTuple2, ZodRecord2, ZodMap2, ZodSet2, ZodEnum2, ZodLiteral2, ZodFile, ZodTransform, ZodOptional2, ZodNullable2, ZodDefault2, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch2, ZodNaN2, ZodPipe, ZodReadonly2, ZodTemplateLiteral, ZodLazy2, ZodPromise2, ZodCustom, stringbool;
var init_schemas2 = __esm({
  "node_modules/zod/v4/classic/schemas.js"() {
    init_core3();
    init_core3();
    init_checks2();
    init_iso();
    init_parse5();
    ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      inst.def = def;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(
          {
            ...def,
            checks: [
              ...def.checks ?? [],
              ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
            ]
          }
          // { parent: true }
        );
      };
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = (reg, meta) => {
        reg.add(inst, meta);
        return inst;
      };
      inst.parse = (data, params) => parse7(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType2.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
    });
    ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date3(params));
      inst.time = (params) => inst.check(time3(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType2.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber2.init(inst, def);
    });
    ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType2.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt2.init(inst, def);
    });
    ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType2.init(inst, def);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType2.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObject.init(inst, def);
      ZodType2.init(inst, def);
      util_exports.defineLazy(inst, "shape", () => def.shape);
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType2.init(inst, def);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion2.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType2.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType2.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType2.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType2.init(inst, def);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType2.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum2({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum2({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType2.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType2.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
    });
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.addIssue = (issue2) => {
          if (typeof issue2 === "string") {
            payload.issues.push(util_exports.issue(issue2, payload.value, def));
          } else {
            const _issue = issue2;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            _issue.continue ?? (_issue.continue = true);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType2.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType2.init(inst, def);
    });
    stringbool = (...args) => _stringbool({
      Pipe: ZodPipe,
      Boolean: ZodBoolean2,
      String: ZodString2,
      Transform: ZodTransform
    }, ...args);
  }
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap2(map2) {
  config({
    customError: map2
  });
}
function getErrorMap2() {
  return config().customError;
}
var ZodIssueCode2;
var init_compat = __esm({
  "node_modules/zod/v4/classic/compat.js"() {
    init_core3();
    ZodIssueCode2 = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
  }
});

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date5,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString2, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber2, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean2, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt2, params);
}
function date5(params) {
  return _coercedDate(ZodDate2, params);
}
var init_coerce = __esm({
  "node_modules/zod/v4/classic/coerce.js"() {
    init_core3();
    init_schemas2();
  }
});

// node_modules/zod/v4/classic/external.js
var external_exports2 = {};
__export(external_exports2, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodFile: () => ZodFile,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  any: () => any,
  array: () => array,
  base64: () => base643,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports3,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom2,
  date: () => date4,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap2,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse7,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap2,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});
var init_external2 = __esm({
  "node_modules/zod/v4/classic/external.js"() {
    init_core3();
    init_schemas2();
    init_checks2();
    init_errors5();
    init_parse5();
    init_compat();
    init_core3();
    init_en2();
    init_core3();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config(en_default2());
  }
});

// node_modules/zod/v4/classic/index.js
var init_classic = __esm({
  "node_modules/zod/v4/classic/index.js"() {
    init_external2();
    init_external2();
  }
});

// node_modules/zod/v4/index.js
var init_v43 = __esm({
  "node_modules/zod/v4/index.js"() {
    init_classic();
  }
});

// node_modules/@langchain/core/dist/tools/index.js
function tool(func, fields) {
  const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);
  const isStringJSONSchema = validatesOnlyStrings(fields.schema);
  if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) return new DynamicTool({
    ...fields,
    description: fields.description ?? fields.schema?.description ?? `${fields.name} tool`,
    func: async (input, runManager, config2) => {
      return new Promise((resolve, reject) => {
        const childConfig = patchConfig(config2, { callbacks: runManager?.getChild() });
        AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
          try {
            resolve(func(input, childConfig));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  });
  const schema = fields.schema;
  const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;
  return new DynamicStructuredTool({
    ...fields,
    description,
    schema,
    func: async (input, runManager, config2) => {
      return new Promise((resolve, reject) => {
        let listener;
        const cleanup = () => {
          if (config2?.signal && listener) config2.signal.removeEventListener("abort", listener);
        };
        if (config2?.signal) {
          listener = () => {
            cleanup();
            reject(getAbortSignalError(config2.signal));
          };
          config2.signal.addEventListener("abort", listener);
        }
        const childConfig = patchConfig(config2, { callbacks: runManager?.getChild() });
        AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
          try {
            const result = await func(input, childConfig);
            if (config2?.signal?.aborted) {
              cleanup();
              return;
            }
            cleanup();
            resolve(result);
          } catch (e) {
            cleanup();
            reject(e);
          }
        });
      });
    }
  });
}
function _formatToolOutput(params) {
  const { content, artifact, toolCallId, metadata } = params;
  if (toolCallId && !isDirectToolOutput(content)) if (typeof content === "string" || Array.isArray(content) && content.every((item) => typeof item === "object")) return new ToolMessage({
    status: "success",
    content,
    artifact,
    tool_call_id: toolCallId,
    name: params.name,
    metadata
  });
  else return new ToolMessage({
    status: "success",
    content: _stringify2(content),
    artifact,
    tool_call_id: toolCallId,
    name: params.name,
    metadata
  });
  else return content;
}
function _stringify2(content) {
  try {
    return JSON.stringify(content) ?? "";
  } catch (_noOp) {
    return `${content}`;
  }
}
var tools_exports, StructuredTool, Tool, DynamicTool, DynamicStructuredTool, BaseToolkit;
var init_tools2 = __esm({
  "node_modules/@langchain/core/dist/tools/index.js"() {
    init_rolldown_runtime();
    init_tool();
    init_utils2();
    init_manager();
    init_async_local_storage();
    init_singletons();
    init_config();
    init_signal();
    init_zod2();
    init_json_schema2();
    init_base8();
    init_types4();
    init_v3();
    init_esm();
    init_v43();
    tools_exports = {};
    __export2(tools_exports, {
      BaseToolkit: () => BaseToolkit,
      DynamicStructuredTool: () => DynamicStructuredTool,
      DynamicTool: () => DynamicTool,
      StructuredTool: () => StructuredTool,
      Tool: () => Tool,
      ToolInputParsingException: () => ToolInputParsingException,
      isLangChainTool: () => isLangChainTool,
      isRunnableToolLike: () => isRunnableToolLike,
      isStructuredTool: () => isStructuredTool,
      isStructuredToolParams: () => isStructuredToolParams,
      tool: () => tool
    });
    StructuredTool = class extends BaseLangChain {
      /**
      * Optional provider-specific extra fields for the tool.
      *
      * This is used to pass provider-specific configuration that doesn't fit into
      * standard tool fields.
      */
      extras;
      /**
      * Whether to return the tool's output directly.
      *
      * Setting this to true means that after the tool is called,
      * an agent should stop looping.
      */
      returnDirect = false;
      verboseParsingErrors = false;
      get lc_namespace() {
        return ["langchain", "tools"];
      }
      /**
      * The tool response format.
      *
      * If "content" then the output of the tool is interpreted as the contents of a
      * ToolMessage. If "content_and_artifact" then the output is expected to be a
      * two-tuple corresponding to the (content, artifact) of a ToolMessage.
      *
      * @default "content"
      */
      responseFormat = "content";
      /**
      * Default config object for the tool runnable.
      */
      defaultConfig;
      constructor(fields) {
        super(fields ?? {});
        this.verboseParsingErrors = fields?.verboseParsingErrors ?? this.verboseParsingErrors;
        this.responseFormat = fields?.responseFormat ?? this.responseFormat;
        this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;
        this.metadata = fields?.metadata ?? this.metadata;
        this.extras = fields?.extras ?? this.extras;
      }
      /**
      * Invokes the tool with the provided input and configuration.
      * @param input The input for the tool.
      * @param config Optional configuration for the tool.
      * @returns A Promise that resolves with the tool's output.
      */
      async invoke(input, config2) {
        let toolInput;
        let enrichedConfig = ensureConfig(mergeConfigs(this.defaultConfig, config2));
        if (_isToolCall(input)) {
          toolInput = input.args;
          enrichedConfig = {
            ...enrichedConfig,
            toolCall: input
          };
        } else toolInput = input;
        return this.call(toolInput, enrichedConfig);
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      *
      * Calls the tool with the provided argument, configuration, and tags. It
      * parses the input according to the schema, handles any errors, and
      * manages callbacks.
      * @param arg The input argument for the tool.
      * @param configArg Optional configuration or callbacks for the tool.
      * @param tags Optional tags for the tool.
      * @returns A Promise that resolves with a string.
      */
      async call(arg, configArg, tags) {
        const inputForValidation = _isToolCall(arg) ? arg.args : arg;
        let parsed;
        if (isInteropZodSchema(this.schema)) try {
          parsed = await interopParseAsync(this.schema, inputForValidation);
        } catch (e) {
          let message = `Received tool input did not match expected schema`;
          if (this.verboseParsingErrors) message = `${message}
Details: ${e.message}`;
          if (isInteropZodError(e)) message = `${message}

${external_exports2.prettifyError(e)}`;
          throw new ToolInputParsingException(message, JSON.stringify(arg));
        }
        else {
          const result$1 = validate5(inputForValidation, this.schema);
          if (!result$1.valid) {
            let message = `Received tool input did not match expected schema`;
            if (this.verboseParsingErrors) message = `${message}
Details: ${result$1.errors.map((e) => `${e.keywordLocation}: ${e.error}`).join("\n")}`;
            throw new ToolInputParsingException(message, JSON.stringify(arg));
          }
          parsed = inputForValidation;
        }
        const config2 = parseCallbackConfigArg(configArg);
        const callbackManager_ = CallbackManager.configure(config2.callbacks, this.callbacks, config2.tags || tags, this.tags, config2.metadata, this.metadata, { verbose: this.verbose });
        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof arg === "string" ? arg : JSON.stringify(arg), config2.runId, void 0, void 0, void 0, config2.runName);
        delete config2.runId;
        let result;
        try {
          result = await this._call(parsed, runManager, config2);
        } catch (e) {
          await runManager?.handleToolError(e);
          throw e;
        }
        let content;
        let artifact;
        if (this.responseFormat === "content_and_artifact") if (Array.isArray(result) && result.length === 2) [content, artifact] = result;
        else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(result)}`);
        else content = result;
        let toolCallId;
        if (_isToolCall(arg)) toolCallId = arg.id;
        if (!toolCallId && _configHasToolCallId(config2)) toolCallId = config2.toolCall.id;
        const formattedOutput = _formatToolOutput({
          content,
          artifact,
          toolCallId,
          name: this.name,
          metadata: this.metadata
        });
        await runManager?.handleToolEnd(formattedOutput);
        return formattedOutput;
      }
    };
    Tool = class extends StructuredTool {
      schema = external_exports.object({ input: external_exports.string().optional() }).transform((obj) => obj.input);
      constructor(fields) {
        super(fields);
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      *
      * Calls the tool with the provided argument and callbacks. It handles
      * string inputs specifically.
      * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
      * @param callbacks Optional callbacks for the tool.
      * @returns A Promise that resolves with a string.
      */
      call(arg, callbacks) {
        const structuredArg = typeof arg === "string" || arg == null ? { input: arg } : arg;
        return super.call(structuredArg, callbacks);
      }
    };
    DynamicTool = class extends Tool {
      static lc_name() {
        return "DynamicTool";
      }
      name;
      description;
      func;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
        this.description = fields.description;
        this.func = fields.func;
        this.returnDirect = fields.returnDirect ?? this.returnDirect;
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      */
      async call(arg, configArg) {
        const config2 = parseCallbackConfigArg(configArg);
        if (config2.runName === void 0) config2.runName = this.name;
        return super.call(arg, config2);
      }
      /** @ignore */
      async _call(input, runManager, parentConfig) {
        return this.func(input, runManager, parentConfig);
      }
    };
    DynamicStructuredTool = class extends StructuredTool {
      static lc_name() {
        return "DynamicStructuredTool";
      }
      description;
      func;
      schema;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
        this.description = fields.description;
        this.func = fields.func;
        this.returnDirect = fields.returnDirect ?? this.returnDirect;
        this.schema = fields.schema;
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      */
      async call(arg, configArg, tags) {
        const config2 = parseCallbackConfigArg(configArg);
        if (config2.runName === void 0) config2.runName = this.name;
        return super.call(arg, config2, tags);
      }
      _call(arg, runManager, parentConfig) {
        return this.func(arg, runManager, parentConfig);
      }
    };
    BaseToolkit = class {
      getTools() {
        return this.tools;
      }
    };
  }
});

// node_modules/@langchain/core/dist/tracers/run_collector.js
var run_collector_exports, RunCollectorCallbackHandler;
var init_run_collector = __esm({
  "node_modules/@langchain/core/dist/tracers/run_collector.js"() {
    init_rolldown_runtime();
    init_base3();
    run_collector_exports = {};
    __export2(run_collector_exports, { RunCollectorCallbackHandler: () => RunCollectorCallbackHandler });
    RunCollectorCallbackHandler = class extends BaseTracer {
      /** The name of the callback handler. */
      name = "run_collector";
      /** The ID of the example. */
      exampleId;
      /** An array of traced runs. */
      tracedRuns;
      /**
      * Creates a new instance of the RunCollectorCallbackHandler class.
      * @param exampleId The ID of the example.
      */
      constructor({ exampleId } = {}) {
        super({ _awaitHandler: true });
        this.exampleId = exampleId;
        this.tracedRuns = [];
      }
      /**
      * Persists the given run object.
      * @param run The run object to persist.
      */
      async persistRun(run) {
        const run_ = { ...run };
        run_.reference_example_id = this.exampleId;
        this.tracedRuns.push(run_);
      }
    };
  }
});

// node_modules/@langchain/core/dist/types/stream.js
var stream_exports2;
var init_stream2 = __esm({
  "node_modules/@langchain/core/dist/types/stream.js"() {
    stream_exports2 = {};
  }
});

// node_modules/@langchain/core/dist/utils/chunk_array.js
var chunk_array_exports, chunkArray;
var init_chunk_array = __esm({
  "node_modules/@langchain/core/dist/utils/chunk_array.js"() {
    init_rolldown_runtime();
    chunk_array_exports = {};
    __export2(chunk_array_exports, { chunkArray: () => chunkArray });
    chunkArray = (arr3, chunkSize) => arr3.reduce((chunks, elem, index2) => {
      const chunkIndex = Math.floor(index2 / chunkSize);
      const chunk = chunks[chunkIndex] || [];
      chunks[chunkIndex] = chunk.concat([elem]);
      return chunks;
    }, []);
  }
});

// node_modules/@langchain/core/dist/utils/context.js
function context(strings, ...values) {
  const raw = strings.raw;
  let result = "";
  for (let i = 0; i < raw.length; i++) {
    const next = raw[i].replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
    result += next;
    if (i < values.length) {
      const value = alignValue(values[i], result);
      result += typeof value === "string" ? value : JSON.stringify(value);
    }
  }
  result = stripIndent(result);
  result = result.trim();
  result = result.replace(/\\n/g, "\n");
  return result;
}
function alignValue(value, precedingText) {
  if (typeof value !== "string" || !value.includes("\n")) return value;
  const currentLine = precedingText.slice(precedingText.lastIndexOf("\n") + 1);
  const indentMatch = currentLine.match(/^(\s+)/);
  if (indentMatch) {
    const indent = indentMatch[1];
    return value.replace(/\n/g, `
${indent}`);
  }
  return value;
}
function stripIndent(text2) {
  const lines = text2.split("\n");
  let minIndent = null;
  for (const line of lines) {
    const match = line.match(/^(\s+)\S+/);
    if (match) {
      const indent = match[1].length;
      if (minIndent === null) minIndent = indent;
      else minIndent = Math.min(minIndent, indent);
    }
  }
  if (minIndent === null) return text2;
  return lines.map((line) => line[0] === " " || line[0] === "	" ? line.slice(minIndent) : line).join("\n");
}
var context_exports;
var init_context2 = __esm({
  "node_modules/@langchain/core/dist/utils/context.js"() {
    init_rolldown_runtime();
    context_exports = {};
    __export2(context_exports, { context: () => context });
  }
});

// node_modules/@langchain/core/dist/utils/event_source_parse.js
async function getBytes(stream, onChunk) {
  if (stream instanceof ReadableStream) {
    const reader = stream.getReader();
    while (true) {
      const result = await reader.read();
      if (result.done) {
        onChunk(new Uint8Array(), true);
        break;
      }
      onChunk(result.value);
    }
  } else try {
    for await (const chunk of stream) onChunk(new Uint8Array(chunk));
    onChunk(new Uint8Array(), true);
  } catch (e) {
    throw new Error([
      "Parsing event source stream failed.",
      "Ensure your implementation of fetch returns a web or Node readable stream.",
      `Error: ${e.message}`
    ].join("\n"));
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr3, flush) {
    if (flush) {
      onLine(arr3, 0, true);
      return;
    }
    if (buffer === void 0) {
      buffer = arr3;
      position = 0;
      fieldLength = -1;
    } else buffer = concat2(buffer, arr3);
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === ControlChars.NewLine) lineStart = ++position;
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) switch (buffer[position]) {
        case ControlChars.Colon:
          if (fieldLength === -1) fieldLength = position - lineStart;
          break;
        case ControlChars.CarriageReturn:
          discardTrailingNewline = true;
        case ControlChars.NewLine:
          lineEnd = position;
          break;
      }
      if (lineEnd === -1) break;
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) buffer = void 0;
    else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onMessage, onId, onRetry) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength, flush) {
    if (flush) {
      if (!isEmpty(message)) {
        onMessage?.(message);
        message = newMessage();
      }
      return;
    }
    if (line.length === 0) {
      onMessage?.(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field) {
        case "data":
          message.data = message.data ? message.data + "\n" + value : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId?.(message.id = value);
          break;
        case "retry": {
          const retry = parseInt(value, 10);
          if (!Number.isNaN(retry)) onRetry?.(message.retry = retry);
          break;
        }
      }
    }
  };
}
function concat2(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
function convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {
  const dataStream = new ReadableStream({ async start(controller) {
    const enqueueLine = getMessages((msg) => {
      if (msg.event === "error") throw new Error(msg.data ?? "Unspecified event streaming error.");
      else if (msg.event === "metadata") onMetadataEvent?.(msg);
      else if (msg.data) controller.enqueue(msg.data);
    });
    const onLine = (line, fieldLength, flush) => {
      enqueueLine(line, fieldLength, flush);
      if (flush) controller.close();
    };
    await getBytes(stream, getLines(onLine));
  } });
  return IterableReadableStream.fromReadableStream(dataStream);
}
function isEmpty(message) {
  return message.data === "" && message.event === "" && message.id === "" && message.retry === void 0;
}
var event_source_parse_exports, EventStreamContentType, ControlChars;
var init_event_source_parse = __esm({
  "node_modules/@langchain/core/dist/utils/event_source_parse.js"() {
    init_rolldown_runtime();
    init_stream();
    event_source_parse_exports = {};
    __export2(event_source_parse_exports, {
      EventStreamContentType: () => EventStreamContentType,
      convertEventStreamToIterableReadableDataStream: () => convertEventStreamToIterableReadableDataStream,
      getBytes: () => getBytes,
      getLines: () => getLines,
      getMessages: () => getMessages
    });
    EventStreamContentType = "text/event-stream";
    ControlChars = /* @__PURE__ */ function(ControlChars$1) {
      ControlChars$1[ControlChars$1["NewLine"] = 10] = "NewLine";
      ControlChars$1[ControlChars$1["CarriageReturn"] = 13] = "CarriageReturn";
      ControlChars$1[ControlChars$1["Space"] = 32] = "Space";
      ControlChars$1[ControlChars$1["Colon"] = 58] = "Colon";
      return ControlChars$1;
    }(ControlChars || {});
  }
});

// node_modules/@langchain/core/dist/utils/format.js
var format_exports;
var init_format3 = __esm({
  "node_modules/@langchain/core/dist/utils/format.js"() {
    format_exports = {};
  }
});

// node_modules/@langchain/core/dist/utils/function_calling.js
function convertToOpenAIFunction(tool2, fields) {
  const fieldsCopy = typeof fields === "number" ? void 0 : fields;
  return {
    name: tool2.name,
    description: tool2.description,
    parameters: toJsonSchema(tool2.schema),
    ...fieldsCopy?.strict !== void 0 ? { strict: fieldsCopy.strict } : {}
  };
}
function convertToOpenAITool(tool2, fields) {
  const fieldsCopy = typeof fields === "number" ? void 0 : fields;
  let toolDef;
  if (isLangChainTool(tool2)) toolDef = {
    type: "function",
    function: convertToOpenAIFunction(tool2)
  };
  else toolDef = tool2;
  if (fieldsCopy?.strict !== void 0) toolDef.function.strict = fieldsCopy.strict;
  return toolDef;
}
var function_calling_exports;
var init_function_calling = __esm({
  "node_modules/@langchain/core/dist/utils/function_calling.js"() {
    init_rolldown_runtime();
    init_json_schema2();
    init_types4();
    function_calling_exports = {};
    __export2(function_calling_exports, {
      convertToOpenAIFunction: () => convertToOpenAIFunction,
      convertToOpenAITool: () => convertToOpenAITool,
      isLangChainTool: () => isLangChainTool,
      isRunnableToolLike: () => isRunnableToolLike,
      isStructuredTool: () => isStructuredTool,
      isStructuredToolParams: () => isStructuredToolParams
    });
  }
});

// node_modules/@langchain/core/dist/utils/ml-distance/similarities.js
function cosine(a, b) {
  let p = 0;
  let p2 = 0;
  let q2 = 0;
  for (let i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (Math.sqrt(p2) * Math.sqrt(q2));
}
var init_similarities = __esm({
  "node_modules/@langchain/core/dist/utils/ml-distance/similarities.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/ml-distance/distances.js
function innerProduct(a, b) {
  let ans = 0;
  for (let i = 0; i < a.length; i++) ans += a[i] * b[i];
  return ans;
}
var init_distances = __esm({
  "node_modules/@langchain/core/dist/utils/ml-distance/distances.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js
function squaredEuclidean(p, q) {
  let d = 0;
  for (let i = 0; i < p.length; i++) d += (p[i] - q[i]) * (p[i] - q[i]);
  return d;
}
function euclidean(p, q) {
  return Math.sqrt(squaredEuclidean(p, q));
}
var init_euclidean = __esm({
  "node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js"() {
  }
});

// node_modules/@langchain/core/dist/utils/math.js
function matrixFunc(X, Y, func) {
  if (X.length === 0 || X[0].length === 0 || Y.length === 0 || Y[0].length === 0) return [[]];
  if (X[0].length !== Y[0].length) throw new Error(`Number of columns in X and Y must be the same. X has shape ${[X.length, X[0].length]} and Y has shape ${[Y.length, Y[0].length]}.`);
  return X.map((xVector) => Y.map((yVector) => func(xVector, yVector)).map((similarity) => Number.isNaN(similarity) ? 0 : similarity));
}
function normalize(M, similarity = false) {
  const max = matrixMaxVal(M);
  return M.map((row) => row.map((val) => similarity ? 1 - val / max : val / max));
}
function cosineSimilarity(X, Y) {
  return matrixFunc(X, Y, cosine);
}
function innerProduct$1(X, Y) {
  return matrixFunc(X, Y, innerProduct);
}
function euclideanDistance(X, Y) {
  return matrixFunc(X, Y, euclidean);
}
function maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k = 4) {
  if (Math.min(k, embeddingList.length) <= 0) return [];
  const queryEmbeddingExpanded = Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding];
  const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];
  const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;
  const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];
  const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];
  while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {
    let bestScore = -Infinity;
    let bestIndex = -1;
    const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);
    similarityToQuery.forEach((queryScore, queryScoreIndex) => {
      if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) return;
      const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);
      const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;
      if (score > bestScore) {
        bestScore = score;
        bestIndex = queryScoreIndex;
      }
    });
    selectedEmbeddings.push(embeddingList[bestIndex]);
    selectedEmbeddingsIndexes.push(bestIndex);
  }
  return selectedEmbeddingsIndexes;
}
function argMax(array2) {
  if (array2.length === 0) return {
    maxIndex: -1,
    maxValue: NaN
  };
  let maxValue = array2[0];
  let maxIndex = 0;
  for (let i = 1; i < array2.length; i += 1) if (array2[i] > maxValue) {
    maxIndex = i;
    maxValue = array2[i];
  }
  return {
    maxIndex,
    maxValue
  };
}
function matrixMaxVal(arrays) {
  return arrays.reduce((acc, array2) => Math.max(acc, argMax(array2).maxValue), 0);
}
var math_exports;
var init_math = __esm({
  "node_modules/@langchain/core/dist/utils/math.js"() {
    init_rolldown_runtime();
    init_similarities();
    init_distances();
    init_euclidean();
    math_exports = {};
    __export2(math_exports, {
      cosineSimilarity: () => cosineSimilarity,
      euclideanDistance: () => euclideanDistance,
      innerProduct: () => innerProduct$1,
      matrixFunc: () => matrixFunc,
      maximalMarginalRelevance: () => maximalMarginalRelevance,
      normalize: () => normalize
    });
  }
});

// node_modules/@langchain/core/dist/utils/testing/chat_models.js
var FakeChatModel, FakeStreamingChatModel, FakeListChatModel;
var init_chat_models2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/chat_models.js"() {
    init_ai();
    init_outputs();
    init_json_schema2();
    init_base4();
    init_messages2();
    init_chat_models();
    FakeChatModel = class extends BaseChatModel {
      _combineLLMOutput() {
        return [];
      }
      _llmType() {
        return "fake";
      }
      async _generate(messages, options, runManager) {
        if (options?.stop?.length) return { generations: [{
          message: new AIMessage(options.stop[0]),
          text: options.stop[0]
        }] };
        const text2 = messages.map((m) => {
          if (typeof m.content === "string") return m.content;
          return JSON.stringify(m.content, null, 2);
        }).join("\n");
        await runManager?.handleLLMNewToken(text2);
        return {
          generations: [{
            message: new AIMessage(text2),
            text: text2
          }],
          llmOutput: {}
        };
      }
    };
    FakeStreamingChatModel = class FakeStreamingChatModel2 extends BaseChatModel {
      sleep = 50;
      responses = [];
      chunks = [];
      toolStyle = "openai";
      thrownErrorString;
      tools = [];
      constructor({ sleep: sleep2 = 50, responses = [], chunks = [], toolStyle = "openai", thrownErrorString, ...rest }) {
        super(rest);
        this.sleep = sleep2;
        this.responses = responses;
        this.chunks = chunks;
        this.toolStyle = toolStyle;
        this.thrownErrorString = thrownErrorString;
      }
      _llmType() {
        return "fake";
      }
      bindTools(tools2) {
        const merged = [...this.tools, ...tools2];
        const toolDicts = merged.map((t) => {
          switch (this.toolStyle) {
            case "openai":
              return {
                type: "function",
                function: {
                  name: t.name,
                  description: t.description,
                  parameters: toJsonSchema(t.schema)
                }
              };
            case "anthropic":
              return {
                name: t.name,
                description: t.description,
                input_schema: toJsonSchema(t.schema)
              };
            case "bedrock":
              return { toolSpec: {
                name: t.name,
                description: t.description,
                inputSchema: toJsonSchema(t.schema)
              } };
            case "google":
              return {
                name: t.name,
                description: t.description,
                parameters: toJsonSchema(t.schema)
              };
            default:
              throw new Error(`Unsupported tool style: ${this.toolStyle}`);
          }
        });
        const wrapped = this.toolStyle === "google" ? [{ functionDeclarations: toolDicts }] : toolDicts;
        const next = new FakeStreamingChatModel2({
          sleep: this.sleep,
          responses: this.responses,
          chunks: this.chunks,
          toolStyle: this.toolStyle,
          thrownErrorString: this.thrownErrorString
        });
        next.tools = merged;
        return next.withConfig({ tools: wrapped });
      }
      async _generate(messages, _options, _runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const content = this.responses?.[0]?.content ?? messages[0].content ?? "";
        const generation = { generations: [{
          text: "",
          message: new AIMessage({
            content,
            tool_calls: this.chunks?.[0]?.tool_calls
          })
        }] };
        return generation;
      }
      async *_streamResponseChunks(_messages, options, runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        if (this.chunks?.length) {
          for (const msgChunk of this.chunks) {
            const cg = new ChatGenerationChunk({
              message: new AIMessageChunk({
                content: msgChunk.content,
                tool_calls: msgChunk.tool_calls,
                additional_kwargs: msgChunk.additional_kwargs ?? {}
              }),
              text: msgChunk.content?.toString() ?? ""
            });
            if (options.signal?.aborted) break;
            yield cg;
            await runManager?.handleLLMNewToken(msgChunk.content, void 0, void 0, void 0, void 0, { chunk: cg });
          }
          return;
        }
        const fallback = this.responses?.[0] ?? new AIMessage(typeof _messages[0].content === "string" ? _messages[0].content : "");
        const text2 = typeof fallback.content === "string" ? fallback.content : "";
        for (const ch of text2) {
          await new Promise((r) => setTimeout(r, this.sleep));
          const cg = new ChatGenerationChunk({
            message: new AIMessageChunk({ content: ch }),
            text: ch
          });
          if (options.signal?.aborted) break;
          yield cg;
          await runManager?.handleLLMNewToken(ch, void 0, void 0, void 0, void 0, { chunk: cg });
        }
      }
    };
    FakeListChatModel = class FakeListChatModel2 extends BaseChatModel {
      static lc_name() {
        return "FakeListChatModel";
      }
      lc_serializable = true;
      responses;
      i = 0;
      sleep;
      emitCustomEvent = false;
      generationInfo;
      tools = [];
      toolStyle = "openai";
      constructor(params) {
        super(params);
        const { responses, sleep: sleep2, emitCustomEvent, generationInfo } = params;
        this.responses = responses;
        this.sleep = sleep2;
        this.emitCustomEvent = emitCustomEvent ?? this.emitCustomEvent;
        this.generationInfo = generationInfo;
      }
      _combineLLMOutput() {
        return [];
      }
      _llmType() {
        return "fake-list";
      }
      async _generate(_messages, options, runManager) {
        await this._sleepIfRequested();
        if (options?.thrownErrorString) throw new Error(options.thrownErrorString);
        if (this.emitCustomEvent) await runManager?.handleCustomEvent("some_test_event", { someval: true });
        if (options?.stop?.length) return { generations: [this._formatGeneration(options.stop[0])] };
        else {
          const response = this._currentResponse();
          this._incrementResponse();
          return {
            generations: [this._formatGeneration(response)],
            llmOutput: {}
          };
        }
      }
      _formatGeneration(text2) {
        return {
          message: new AIMessage(text2),
          text: text2
        };
      }
      async *_streamResponseChunks(_messages, options, runManager) {
        const response = this._currentResponse();
        this._incrementResponse();
        if (this.emitCustomEvent) await runManager?.handleCustomEvent("some_test_event", { someval: true });
        const responseChars = [...response];
        for (let i = 0; i < responseChars.length; i++) {
          const text2 = responseChars[i];
          const isLastChunk = i === responseChars.length - 1;
          await this._sleepIfRequested();
          if (options?.thrownErrorString) throw new Error(options.thrownErrorString);
          const chunk = this._createResponseChunk(text2, isLastChunk ? this.generationInfo : void 0);
          if (options.signal?.aborted) break;
          yield chunk;
          runManager?.handleLLMNewToken(text2);
        }
      }
      async _sleepIfRequested() {
        if (this.sleep !== void 0) await this._sleep();
      }
      async _sleep() {
        return new Promise((resolve) => {
          setTimeout(() => resolve(), this.sleep);
        });
      }
      _createResponseChunk(text2, generationInfo) {
        return new ChatGenerationChunk({
          message: new AIMessageChunk({ content: text2 }),
          text: text2,
          generationInfo
        });
      }
      _currentResponse() {
        return this.responses[this.i];
      }
      _incrementResponse() {
        if (this.i < this.responses.length - 1) this.i += 1;
        else this.i = 0;
      }
      bindTools(tools2) {
        const merged = [...this.tools, ...tools2];
        const toolDicts = merged.map((t) => {
          switch (this.toolStyle) {
            case "openai":
              return {
                type: "function",
                function: {
                  name: t.name,
                  description: t.description,
                  parameters: toJsonSchema(t.schema)
                }
              };
            case "anthropic":
              return {
                name: t.name,
                description: t.description,
                input_schema: toJsonSchema(t.schema)
              };
            case "bedrock":
              return { toolSpec: {
                name: t.name,
                description: t.description,
                inputSchema: toJsonSchema(t.schema)
              } };
            case "google":
              return {
                name: t.name,
                description: t.description,
                parameters: toJsonSchema(t.schema)
              };
            default:
              throw new Error(`Unsupported tool style: ${this.toolStyle}`);
          }
        });
        const wrapped = this.toolStyle === "google" ? [{ functionDeclarations: toolDicts }] : toolDicts;
        const next = new FakeListChatModel2({
          responses: this.responses,
          sleep: this.sleep,
          emitCustomEvent: this.emitCustomEvent,
          generationInfo: this.generationInfo
        });
        next.tools = merged;
        next.toolStyle = this.toolStyle;
        next.i = this.i;
        return next.withConfig({ tools: wrapped });
      }
      withStructuredOutput(_params, _config) {
        return RunnableLambda.from(async (input) => {
          const message = await this.invoke(input);
          if (message.tool_calls?.[0]?.args) return message.tool_calls[0].args;
          if (typeof message.content === "string") return JSON.parse(message.content);
          throw new Error("No structured output found");
        });
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/embeddings.js
var SyntheticEmbeddings, FakeEmbeddings;
var init_embeddings2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/embeddings.js"() {
    init_embeddings();
    SyntheticEmbeddings = class extends Embeddings {
      vectorSize;
      constructor(params) {
        super(params ?? {});
        this.vectorSize = params?.vectorSize ?? 4;
      }
      /**
      * Generates synthetic embeddings for a list of documents.
      * @param documents List of documents to generate embeddings for.
      * @returns A promise that resolves with a list of synthetic embeddings for each document.
      */
      async embedDocuments(documents) {
        return Promise.all(documents.map((doc) => this.embedQuery(doc)));
      }
      /**
      * Generates a synthetic embedding for a document. The document is
      * converted into chunks, a numerical value is calculated for each chunk,
      * and an array of these values is returned as the embedding.
      * @param document The document to generate an embedding for.
      * @returns A promise that resolves with a synthetic embedding for the document.
      */
      async embedQuery(document) {
        let doc = document;
        doc = doc.toLowerCase().replaceAll(/[^a-z ]/g, "");
        const padMod = doc.length % this.vectorSize;
        const padGapSize = padMod === 0 ? 0 : this.vectorSize - padMod;
        const padSize = doc.length + padGapSize;
        doc = doc.padEnd(padSize, " ");
        const chunkSize = doc.length / this.vectorSize;
        const docChunk = [];
        for (let co = 0; co < doc.length; co += chunkSize) docChunk.push(doc.slice(co, co + chunkSize));
        const ret = docChunk.map((s) => {
          let sum = 0;
          for (let co = 0; co < s.length; co += 1) sum += s === " " ? 0 : s.charCodeAt(co);
          const ret$1 = sum % 26 / 26;
          return ret$1;
        });
        return ret;
      }
    };
    FakeEmbeddings = class extends Embeddings {
      constructor(params) {
        super(params ?? {});
      }
      /**
      * Generates fixed embeddings for a list of documents.
      * @param documents List of documents to generate embeddings for.
      * @returns A promise that resolves with a list of fixed embeddings for each document.
      */
      embedDocuments(documents) {
        return Promise.resolve(documents.map(() => [
          0.1,
          0.2,
          0.3,
          0.4
        ]));
      }
      /**
      * Generates a fixed embedding for a query.
      * @param _ The query to generate an embedding for.
      * @returns A promise that resolves with a fixed embedding for the query.
      */
      embedQuery(_) {
        return Promise.resolve([
          0.1,
          0.2,
          0.3,
          0.4
        ]);
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/llms.js
var FakeLLM, FakeStreamingLLM;
var init_llms2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/llms.js"() {
    init_llms();
    FakeLLM = class extends LLM {
      response;
      thrownErrorString;
      constructor(fields) {
        super(fields);
        this.response = fields.response;
        this.thrownErrorString = fields.thrownErrorString;
      }
      _llmType() {
        return "fake";
      }
      async _call(prompt, _options, runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const response = this.response ?? prompt;
        await runManager?.handleLLMNewToken(response);
        return response;
      }
    };
    FakeStreamingLLM = class extends LLM {
      sleep = 50;
      responses;
      thrownErrorString;
      constructor(fields) {
        super(fields);
        this.sleep = fields.sleep ?? this.sleep;
        this.responses = fields.responses;
        this.thrownErrorString = fields.thrownErrorString;
      }
      _llmType() {
        return "fake";
      }
      async _call(prompt) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const response = this.responses?.[0];
        this.responses = this.responses?.slice(1);
        return response ?? prompt;
      }
      async *_streamResponseChunks(input, _options, runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const response = this.responses?.[0];
        this.responses = this.responses?.slice(1);
        for (const c of response ?? input) {
          await new Promise((resolve) => setTimeout(resolve, this.sleep));
          yield {
            text: c,
            generationInfo: {}
          };
          await runManager?.handleLLMNewToken(c);
        }
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/message_history.js
var FakeChatMessageHistory, FakeListChatMessageHistory, FakeTracer;
var init_message_history = __esm({
  "node_modules/@langchain/core/dist/utils/testing/message_history.js"() {
    init_human();
    init_ai();
    init_base3();
    init_messages2();
    init_chat_history();
    FakeChatMessageHistory = class extends BaseChatMessageHistory {
      lc_namespace = [
        "langchain_core",
        "message",
        "fake"
      ];
      messages = [];
      constructor() {
        super();
      }
      async getMessages() {
        return this.messages;
      }
      async addMessage(message) {
        this.messages.push(message);
      }
      async addUserMessage(message) {
        this.messages.push(new HumanMessage(message));
      }
      async addAIMessage(message) {
        this.messages.push(new AIMessage(message));
      }
      async clear() {
        this.messages = [];
      }
    };
    FakeListChatMessageHistory = class extends BaseListChatMessageHistory {
      lc_namespace = [
        "langchain_core",
        "message",
        "fake"
      ];
      messages = [];
      constructor() {
        super();
      }
      async addMessage(message) {
        this.messages.push(message);
      }
      async getMessages() {
        return this.messages;
      }
    };
    FakeTracer = class extends BaseTracer {
      name = "fake_tracer";
      runs = [];
      constructor() {
        super();
      }
      persistRun(run) {
        this.runs.push(run);
        return Promise.resolve();
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/output_parsers.js
var FakeSplitIntoListParser;
var init_output_parsers2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/output_parsers.js"() {
    init_base9();
    FakeSplitIntoListParser = class extends BaseOutputParser {
      lc_namespace = ["tests", "fake"];
      getFormatInstructions() {
        return "";
      }
      async parse(text2) {
        return text2.split(",").map((value) => value.trim());
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/retrievers.js
var FakeRetriever;
var init_retrievers2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/retrievers.js"() {
    init_retrievers();
    init_document();
    FakeRetriever = class extends BaseRetriever {
      lc_namespace = ["test", "fake"];
      output = [new Document({ pageContent: "foo" }), new Document({ pageContent: "bar" })];
      constructor(fields) {
        super();
        this.output = fields?.output ?? this.output;
      }
      async _getRelevantDocuments(_query) {
        return this.output;
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/runnables.js
var FakeRunnable;
var init_runnables2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/runnables.js"() {
    init_base4();
    FakeRunnable = class extends Runnable {
      lc_namespace = ["tests", "fake"];
      returnOptions;
      constructor(fields) {
        super(fields);
        this.returnOptions = fields.returnOptions;
      }
      async invoke(input, options) {
        if (this.returnOptions) return options ?? {};
        return { input };
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/tools.js
var FakeTool;
var init_tools3 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/tools.js"() {
    init_tools2();
    FakeTool = class extends StructuredTool {
      name;
      description;
      schema;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
        this.description = fields.description;
        this.schema = fields.schema;
      }
      async _call(arg, _runManager) {
        return JSON.stringify(arg);
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/tracers.js
var SingleRunExtractor;
var init_tracers = __esm({
  "node_modules/@langchain/core/dist/utils/testing/tracers.js"() {
    init_base3();
    SingleRunExtractor = class extends BaseTracer {
      runPromiseResolver;
      runPromise;
      /** The name of the callback handler. */
      name = "single_run_extractor";
      constructor() {
        super();
        this.runPromise = new Promise((extract) => {
          this.runPromiseResolver = extract;
        });
      }
      async persistRun(run) {
        this.runPromiseResolver(run);
      }
      async extract() {
        return this.runPromise;
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/vectorstores.js
var FakeVectorStore;
var init_vectorstores2 = __esm({
  "node_modules/@langchain/core/dist/utils/testing/vectorstores.js"() {
    init_vectorstores();
    init_document();
    init_similarities();
    FakeVectorStore = class FakeVectorStore2 extends VectorStore {
      memoryVectors = [];
      similarity;
      _vectorstoreType() {
        return "memory";
      }
      constructor(embeddings, { similarity, ...rest } = {}) {
        super(embeddings, rest);
        this.similarity = similarity ?? cosine;
      }
      /**
      * Method to add documents to the memory vector store. It extracts the
      * text from each document, generates embeddings for them, and adds the
      * resulting vectors to the store.
      * @param documents Array of `Document` instances to be added to the store.
      * @returns Promise that resolves when all documents have been added.
      */
      async addDocuments(documents) {
        const texts = documents.map(({ pageContent }) => pageContent);
        return this.addVectors(await this.embeddings.embedDocuments(texts), documents);
      }
      /**
      * Method to add vectors to the memory vector store. It creates
      * `MemoryVector` instances for each vector and document pair and adds
      * them to the store.
      * @param vectors Array of vectors to be added to the store.
      * @param documents Array of `Document` instances corresponding to the vectors.
      * @returns Promise that resolves when all vectors have been added.
      */
      async addVectors(vectors, documents) {
        const memoryVectors = vectors.map((embedding, idx) => ({
          content: documents[idx].pageContent,
          embedding,
          metadata: documents[idx].metadata
        }));
        this.memoryVectors = this.memoryVectors.concat(memoryVectors);
      }
      /**
      * Method to perform a similarity search in the memory vector store. It
      * calculates the similarity between the query vector and each vector in
      * the store, sorts the results by similarity, and returns the top `k`
      * results along with their scores.
      * @param query Query vector to compare against the vectors in the store.
      * @param k Number of top results to return.
      * @param filter Optional filter function to apply to the vectors before performing the search.
      * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.
      */
      async similaritySearchVectorWithScore(query, k, filter) {
        const filterFunction = (memoryVector) => {
          if (!filter) return true;
          const doc = new Document({
            metadata: memoryVector.metadata,
            pageContent: memoryVector.content
          });
          return filter(doc);
        };
        const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);
        const searches = filteredMemoryVectors.map((vector, index2) => ({
          similarity: this.similarity(query, vector.embedding),
          index: index2
        })).sort((a, b) => a.similarity > b.similarity ? -1 : 0).slice(0, k);
        const result = searches.map((search) => [new Document({
          metadata: filteredMemoryVectors[search.index].metadata,
          pageContent: filteredMemoryVectors[search.index].content
        }), search.similarity]);
        return result;
      }
      /**
      * Static method to create a `FakeVectorStore` instance from an array of
      * texts. It creates a `Document` for each text and metadata pair, and
      * adds them to the store.
      * @param texts Array of texts to be added to the store.
      * @param metadatas Array or single object of metadata corresponding to the texts.
      * @param embeddings `Embeddings` instance used to generate embeddings for the texts.
      * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.
      * @returns Promise that resolves with a new `FakeVectorStore` instance.
      */
      static async fromTexts(texts, metadatas, embeddings, dbConfig) {
        const docs = [];
        for (let i = 0; i < texts.length; i += 1) {
          const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
          const newDoc = new Document({
            pageContent: texts[i],
            metadata
          });
          docs.push(newDoc);
        }
        return FakeVectorStore2.fromDocuments(docs, embeddings, dbConfig);
      }
      /**
      * Static method to create a `FakeVectorStore` instance from an array of
      * `Document` instances. It adds the documents to the store.
      * @param docs Array of `Document` instances to be added to the store.
      * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
      * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.
      * @returns Promise that resolves with a new `FakeVectorStore` instance.
      */
      static async fromDocuments(docs, embeddings, dbConfig) {
        const instance = new this(embeddings, dbConfig);
        await instance.addDocuments(docs);
        return instance;
      }
      /**
      * Static method to create a `FakeVectorStore` instance from an existing
      * index. It creates a new `FakeVectorStore` instance without adding any
      * documents or vectors.
      * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
      * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.
      * @returns Promise that resolves with a new `FakeVectorStore` instance.
      */
      static async fromExistingIndex(embeddings, dbConfig) {
        const instance = new this(embeddings, dbConfig);
        return instance;
      }
    };
  }
});

// node_modules/@langchain/core/dist/utils/testing/index.js
var testing_exports;
var init_testing = __esm({
  "node_modules/@langchain/core/dist/utils/testing/index.js"() {
    init_rolldown_runtime();
    init_chat_models2();
    init_embeddings2();
    init_llms2();
    init_message_history();
    init_output_parsers2();
    init_retrievers2();
    init_runnables2();
    init_tools3();
    init_tracers();
    init_vectorstores2();
    testing_exports = {};
    __export2(testing_exports, {
      FakeChatMessageHistory: () => FakeChatMessageHistory,
      FakeChatModel: () => FakeChatModel,
      FakeEmbeddings: () => FakeEmbeddings,
      FakeLLM: () => FakeLLM,
      FakeListChatMessageHistory: () => FakeListChatMessageHistory,
      FakeListChatModel: () => FakeListChatModel,
      FakeRetriever: () => FakeRetriever,
      FakeRunnable: () => FakeRunnable,
      FakeSplitIntoListParser: () => FakeSplitIntoListParser,
      FakeStreamingChatModel: () => FakeStreamingChatModel,
      FakeStreamingLLM: () => FakeStreamingLLM,
      FakeTool: () => FakeTool,
      FakeTracer: () => FakeTracer,
      FakeVectorStore: () => FakeVectorStore,
      SingleRunExtractor: () => SingleRunExtractor,
      SyntheticEmbeddings: () => SyntheticEmbeddings
    });
  }
});

// node_modules/@langchain/core/dist/utils/types/index.js
var types_exports;
var init_types5 = __esm({
  "node_modules/@langchain/core/dist/utils/types/index.js"() {
    init_rolldown_runtime();
    init_zod2();
    types_exports = {};
    __export2(types_exports, {
      extendInteropZodObject: () => extendInteropZodObject,
      getInteropZodDefaultGetter: () => getInteropZodDefaultGetter,
      getInteropZodObjectShape: () => getInteropZodObjectShape,
      getSchemaDescription: () => getSchemaDescription,
      interopParse: () => interopParse,
      interopParseAsync: () => interopParseAsync,
      interopSafeParse: () => interopSafeParse,
      interopSafeParseAsync: () => interopSafeParseAsync,
      interopZodObjectMakeFieldsOptional: () => interopZodObjectMakeFieldsOptional,
      interopZodObjectPartial: () => interopZodObjectPartial,
      interopZodObjectPassthrough: () => interopZodObjectPassthrough,
      interopZodObjectStrict: () => interopZodObjectStrict,
      interopZodTransformInputSchema: () => interopZodTransformInputSchema,
      isInteropZodError: () => isInteropZodError,
      isInteropZodLiteral: () => isInteropZodLiteral,
      isInteropZodObject: () => isInteropZodObject,
      isInteropZodSchema: () => isInteropZodSchema,
      isShapelessZodSchema: () => isShapelessZodSchema,
      isSimpleStringZodSchema: () => isSimpleStringZodSchema,
      isZodArrayV4: () => isZodArrayV4,
      isZodLiteralV3: () => isZodLiteralV3,
      isZodLiteralV4: () => isZodLiteralV4,
      isZodNullableV4: () => isZodNullableV4,
      isZodObjectV3: () => isZodObjectV3,
      isZodObjectV4: () => isZodObjectV4,
      isZodOptionalV4: () => isZodOptionalV4,
      isZodSchema: () => isZodSchema,
      isZodSchemaV3: () => isZodSchemaV3,
      isZodSchemaV4: () => isZodSchemaV4
    });
  }
});

// node_modules/@langchain/core/dist/load/import_map.js
var import_map_exports;
var init_import_map = __esm({
  "node_modules/@langchain/core/dist/load/import_map.js"() {
    init_rolldown_runtime();
    init_agents();
    init_serializable();
    init_tool();
    init_env();
    init_base2();
    init_base3();
    init_console();
    init_tracer_langchain();
    init_promises();
    init_manager();
    init_singletons();
    init_stream();
    init_log_stream();
    init_outputs();
    init_async_caller2();
    init_json_schema2();
    init_graph();
    init_messages2();
    init_chat_history();
    init_embeddings();
    init_dist2();
    init_memory();
    init_prompt_values();
    init_stores();
    init_retrievers();
    init_vectorstores();
    init_hash2();
    init_caches();
    init_base5();
    init_langsmith2();
    init_documents();
    init_example_selectors();
    init_indexing();
    init_tiktoken();
    init_base8();
    init_chat_models();
    init_llms();
    init_profile();
    init_runnables();
    init_json_patch();
    init_output_parsers();
    init_openai_functions();
    init_openai_tools();
    init_prompts2();
    init_document_compressors();
    init_structured_query();
    init_tools2();
    init_run_collector();
    init_stream2();
    init_chunk_array();
    init_context2();
    init_event_source_parse();
    init_format3();
    init_function_calling();
    init_math();
    init_testing();
    init_types5();
    import_map_exports = {};
    __export2(import_map_exports, {
      agents: () => agents_exports,
      caches: () => caches_exports,
      callbacks__base: () => base_exports,
      callbacks__manager: () => manager_exports,
      callbacks__promises: () => promises_exports,
      chat_history: () => chat_history_exports,
      document_loaders__base: () => base_exports3,
      document_loaders__langsmith: () => langsmith_exports,
      documents: () => documents_exports,
      embeddings: () => embeddings_exports,
      example_selectors: () => example_selectors_exports,
      index: () => src_exports,
      indexing: () => indexing_exports,
      language_models__base: () => base_exports4,
      language_models__chat_models: () => chat_models_exports,
      language_models__llms: () => llms_exports,
      language_models__profile: () => profile_exports,
      load__serializable: () => serializable_exports,
      memory: () => memory_exports,
      messages: () => messages_exports,
      messages__tool: () => tool_exports,
      output_parsers: () => output_parsers_exports,
      output_parsers__openai_functions: () => openai_functions_exports,
      output_parsers__openai_tools: () => openai_tools_exports,
      outputs: () => outputs_exports,
      prompt_values: () => prompt_values_exports,
      prompts: () => prompts_exports,
      retrievers: () => retrievers_exports,
      retrievers__document_compressors: () => document_compressors_exports,
      runnables: () => runnables_exports,
      runnables__graph: () => graph_exports,
      singletons: () => singletons_exports,
      stores: () => stores_exports,
      structured_query: () => structured_query_exports,
      tools: () => tools_exports,
      tracers__base: () => base_exports2,
      tracers__console: () => console_exports,
      tracers__log_stream: () => log_stream_exports,
      tracers__run_collector: () => run_collector_exports,
      tracers__tracer_langchain: () => tracer_langchain_exports,
      types__stream: () => stream_exports2,
      utils__async_caller: () => async_caller_exports,
      utils__chunk_array: () => chunk_array_exports,
      utils__context: () => context_exports,
      utils__env: () => env_exports,
      utils__event_source_parse: () => event_source_parse_exports,
      utils__format: () => format_exports,
      utils__function_calling: () => function_calling_exports,
      utils__hash: () => hash_exports,
      utils__json_patch: () => json_patch_exports,
      utils__json_schema: () => json_schema_exports2,
      utils__math: () => math_exports,
      utils__stream: () => stream_exports,
      utils__testing: () => testing_exports,
      utils__tiktoken: () => tiktoken_exports,
      utils__types: () => types_exports,
      vectorstores: () => vectorstores_exports
    });
  }
});

// node_modules/@langchain/core/dist/load/index.js
function combineAliasesAndInvert(constructor) {
  const aliases = {};
  for (let current = constructor; current && current.prototype; current = Object.getPrototypeOf(current)) Object.assign(aliases, Reflect.get(current.prototype, "lc_aliases"));
  return Object.entries(aliases).reduce((acc, [key, value]) => {
    acc[value] = key;
    return acc;
  }, {});
}
async function reviver(value) {
  const { optionalImportsMap, optionalImportEntrypoints: optionalImportEntrypoints$1, importMap, secretsMap, secretsFromEnv, path: path3, depth, maxDepth } = this;
  const pathStr = path3.join(".");
  if (depth > maxDepth) throw new Error(`Maximum recursion depth (${maxDepth}) exceeded during deserialization. This may indicate a malicious payload or you may need to increase maxDepth.`);
  if (typeof value !== "object" || value == null) return value;
  if (Array.isArray(value)) return Promise.all(value.map((v, i) => reviver.call({
    ...this,
    path: [...path3, `${i}`],
    depth: depth + 1
  }, v)));
  const record2 = value;
  if (isEscapedObject(record2)) return unescapeValue(record2);
  if ("lc" in record2 && "type" in record2 && "id" in record2 && record2.lc === 1 && record2.type === "secret") {
    const serialized = record2;
    const [key] = serialized.id;
    if (key in secretsMap) return secretsMap[key];
    else if (secretsFromEnv) {
      const secretValueInEnv = getEnvironmentVariable(key);
      if (secretValueInEnv) return secretValueInEnv;
    }
    throw new Error(`Missing secret "${key}" at ${pathStr}`);
  }
  if ("lc" in record2 && "type" in record2 && "id" in record2 && record2.lc === 1 && record2.type === "not_implemented") {
    const serialized = record2;
    const str2 = JSON.stringify(serialized);
    throw new Error(`Trying to load an object that doesn't implement serialization: ${pathStr} -> ${str2}`);
  }
  if ("lc" in record2 && "type" in record2 && "id" in record2 && "kwargs" in record2 && record2.lc === 1 && record2.type === "constructor") {
    const serialized = record2;
    const str2 = JSON.stringify(serialized);
    const [name, ...namespaceReverse] = serialized.id.slice().reverse();
    const namespace = namespaceReverse.reverse();
    const importMaps = {
      langchain_core: import_map_exports,
      langchain: importMap
    };
    let module = null;
    const optionalImportNamespaceAliases = [namespace.join("/")];
    if (namespace[0] === "langchain_community") optionalImportNamespaceAliases.push(["langchain", ...namespace.slice(1)].join("/"));
    const matchingNamespaceAlias = optionalImportNamespaceAliases.find((alias) => alias in optionalImportsMap);
    if (optionalImportEntrypoints.concat(optionalImportEntrypoints$1).includes(namespace.join("/")) || matchingNamespaceAlias) if (matchingNamespaceAlias !== void 0) module = await optionalImportsMap[matchingNamespaceAlias];
    else throw new Error(`Missing key "${namespace.join("/")}" for ${pathStr} in load(optionalImportsMap={})`);
    else {
      let finalImportMap;
      if (namespace[0] === "langchain" || namespace[0] === "langchain_core") {
        finalImportMap = importMaps[namespace[0]];
        namespace.shift();
      } else throw new Error(`Invalid namespace: ${pathStr} -> ${str2}`);
      if (namespace.length === 0) throw new Error(`Invalid namespace: ${pathStr} -> ${str2}`);
      let importMapKey;
      do {
        importMapKey = namespace.join("__");
        if (importMapKey in finalImportMap) break;
        else namespace.pop();
      } while (namespace.length > 0);
      if (importMapKey in finalImportMap) module = finalImportMap[importMapKey];
    }
    if (typeof module !== "object" || module === null) throw new Error(`Invalid namespace: ${pathStr} -> ${str2}`);
    const builder = module[name] ?? Object.values(module).find((v) => typeof v === "function" && get_lc_unique_name(v) === name);
    if (typeof builder !== "function") throw new Error(`Invalid identifer: ${pathStr} -> ${str2}`);
    const kwargs = await reviver.call({
      ...this,
      path: [...path3, "kwargs"],
      depth: depth + 1
    }, serialized.kwargs);
    const instance = new builder(mapKeys(kwargs, keyFromJson, combineAliasesAndInvert(builder)));
    Object.defineProperty(instance.constructor, "name", { value: name });
    return instance;
  }
  const result = {};
  for (const [key, val] of Object.entries(record2)) result[key] = await reviver.call({
    ...this,
    path: [...path3, key],
    depth: depth + 1
  }, val);
  return result;
}
async function load(text2, options) {
  const json2 = JSON.parse(text2);
  const context2 = {
    optionalImportsMap: options?.optionalImportsMap ?? {},
    optionalImportEntrypoints: options?.optionalImportEntrypoints ?? [],
    secretsMap: options?.secretsMap ?? {},
    secretsFromEnv: options?.secretsFromEnv ?? false,
    importMap: options?.importMap ?? {},
    path: ["$"],
    depth: 0,
    maxDepth: options?.maxDepth ?? DEFAULT_MAX_DEPTH
  };
  return reviver.call(context2, json2);
}
var DEFAULT_MAX_DEPTH;
var init_load = __esm({
  "node_modules/@langchain/core/dist/load/index.js"() {
    init_map_keys();
    init_validation();
    init_serializable();
    init_env();
    init_import_constants();
    init_import_map();
    DEFAULT_MAX_DEPTH = 50;
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js
function isLangChainSerializedObject(value) {
  return value !== null && value.lc === 1 && value.type === "constructor" && Array.isArray(value.id);
}
async function _reviver(value) {
  if (value && typeof value === "object") if (Array.isArray(value)) {
    const revivedArray = await Promise.all(value.map((item) => _reviver(item)));
    return revivedArray;
  } else {
    const revivedObj = {};
    for (const [k, v] of Object.entries(value)) revivedObj[k] = await _reviver(v);
    if (revivedObj.lc === 2 && revivedObj.type === "undefined") return void 0;
    else if (revivedObj.lc === 2 && revivedObj.type === "constructor" && Array.isArray(revivedObj.id)) try {
      const constructorName = revivedObj.id[revivedObj.id.length - 1];
      let constructor;
      switch (constructorName) {
        case "Set":
          constructor = Set;
          break;
        case "Map":
          constructor = Map;
          break;
        case "RegExp":
          constructor = RegExp;
          break;
        case "Error":
          constructor = Error;
          break;
        default:
          return revivedObj;
      }
      if (revivedObj.method) return constructor[revivedObj.method](...revivedObj.args || []);
      else return new constructor(...revivedObj.args || []);
    } catch (error40) {
      return revivedObj;
    }
    else if (isLangChainSerializedObject(revivedObj)) return load(JSON.stringify(revivedObj));
    return revivedObj;
  }
  return value;
}
function _encodeConstructorArgs(constructor, method, args, kwargs) {
  return {
    lc: 2,
    type: "constructor",
    id: [constructor.name],
    method: method ?? null,
    args: args ?? [],
    kwargs: kwargs ?? {}
  };
}
function _default3(obj) {
  if (obj === void 0) return {
    lc: 2,
    type: "undefined"
  };
  else if (obj instanceof Set || obj instanceof Map) return _encodeConstructorArgs(obj.constructor, void 0, [Array.from(obj)]);
  else if (obj instanceof RegExp) return _encodeConstructorArgs(RegExp, void 0, [obj.source, obj.flags]);
  else if (obj instanceof Error) return _encodeConstructorArgs(obj.constructor, void 0, [obj.message]);
  else if (obj?.lg_name === "Send") return {
    node: obj.node,
    args: obj.args
  };
  else return obj;
}
var JsonPlusSerializer;
var init_jsonplus = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js"() {
    init_fast_safe_stringify2();
    init_load();
    JsonPlusSerializer = class {
      _dumps(obj) {
        const encoder2 = new TextEncoder();
        return encoder2.encode(stringify(obj, (_, value) => {
          return _default3(value);
        }));
      }
      async dumpsTyped(obj) {
        if (obj instanceof Uint8Array) return ["bytes", obj];
        else return ["json", this._dumps(obj)];
      }
      async _loads(data) {
        const parsed = JSON.parse(data);
        return _reviver(parsed);
      }
      async loadsTyped(type, data) {
        if (type === "bytes") return typeof data === "string" ? new TextEncoder().encode(data) : data;
        else if (type === "json") return this._loads(typeof data === "string" ? data : new TextDecoder().decode(data));
        else throw new Error(`Unknown serialization type: ${type}`);
      }
    };
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/base.js
function deepCopy(obj) {
  if (typeof obj !== "object" || obj === null) return obj;
  const newObj = Array.isArray(obj) ? [] : {};
  for (const key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = deepCopy(obj[key]);
  return newObj;
}
function emptyCheckpoint() {
  return {
    v: 4,
    id: uuid6(-2),
    ts: (/* @__PURE__ */ new Date()).toISOString(),
    channel_values: {},
    channel_versions: {},
    versions_seen: {}
  };
}
function copyCheckpoint(checkpoint) {
  return {
    v: checkpoint.v,
    id: checkpoint.id,
    ts: checkpoint.ts,
    channel_values: { ...checkpoint.channel_values },
    channel_versions: { ...checkpoint.channel_versions },
    versions_seen: deepCopy(checkpoint.versions_seen)
  };
}
function compareChannelVersions(a, b) {
  if (typeof a === "number" && typeof b === "number") return Math.sign(a - b);
  return String(a).localeCompare(String(b));
}
function maxChannelVersion(...versions) {
  return versions.reduce((max, version2, idx) => {
    if (idx === 0) return version2;
    return compareChannelVersions(max, version2) >= 0 ? max : version2;
  });
}
var WRITES_IDX_MAP;
var init_base12 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/base.js"() {
    init_id();
    init_types2();
    init_jsonplus();
    WRITES_IDX_MAP = {
      [ERROR2]: -1,
      [SCHEDULED]: -2,
      [INTERRUPT]: -3,
      [RESUME]: -4
    };
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/memory.js
var init_memory2 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/memory.js"() {
    init_types2();
    init_base12();
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/store/base.js
function validateNamespace(namespace) {
  if (namespace.length === 0) throw new InvalidNamespaceError("Namespace cannot be empty.");
  for (const label of namespace) {
    if (typeof label !== "string") throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels must be strings, but got ${typeof label}.`);
    if (label.includes(".")) throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels cannot contain periods ('.').`);
    if (label === "") throw new InvalidNamespaceError(`Namespace labels cannot be empty strings. Got ${label} in ${namespace}`);
  }
  if (namespace[0] === "langgraph") throw new InvalidNamespaceError(`Root label for namespace cannot be "langgraph". Got: ${namespace}`);
}
var InvalidNamespaceError, BaseStore2;
var init_base13 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/store/base.js"() {
    InvalidNamespaceError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidNamespaceError";
      }
    };
    BaseStore2 = class {
      /**
      * Retrieve a single item by its namespace and key.
      *
      * @param namespace Hierarchical path for the item
      * @param key Unique identifier within the namespace
      * @returns Promise resolving to the item or null if not found
      */
      async get(namespace, key) {
        return (await this.batch([{
          namespace,
          key
        }]))[0];
      }
      /**
      * Search for items within a namespace prefix.
      * Supports both metadata filtering and vector similarity search.
      *
      * @param namespacePrefix Hierarchical path prefix to search within
      * @param options Search options for filtering and pagination
      * @returns Promise resolving to list of matching items with relevance scores
      *
      * @example
      * // Search with filters
      * await store.search(["documents"], {
      *   filter: { type: "report", status: "active" },
      *   limit: 5,
      *   offset: 10
      * });
      *
      * // Vector similarity search
      * await store.search(["users", "content"], {
      *   query: "technical documentation about APIs",
      *   limit: 20
      * });
      */
      async search(namespacePrefix, options = {}) {
        const { filter, limit: limit2 = 10, offset = 0, query } = options;
        return (await this.batch([{
          namespacePrefix,
          filter,
          limit: limit2,
          offset,
          query
        }]))[0];
      }
      /**
      * Store or update an item.
      *
      * @param namespace Hierarchical path for the item
      * @param key Unique identifier within the namespace
      * @param value Object containing the item's data
      * @param index Optional indexing configuration
      *
      * @example
      * // Simple storage
      * await store.put(["docs"], "report", { title: "Annual Report" });
      *
      * // With specific field indexing
      * await store.put(
      *   ["docs"],
      *   "report",
      *   {
      *     title: "Q4 Report",
      *     chapters: [{ content: "..." }, { content: "..." }]
      *   },
      *   ["title", "chapters[*].content"]
      * );
      */
      async put(namespace, key, value, index2) {
        validateNamespace(namespace);
        await this.batch([{
          namespace,
          key,
          value,
          index: index2
        }]);
      }
      /**
      * Delete an item from the store.
      *
      * @param namespace Hierarchical path for the item
      * @param key Unique identifier within the namespace
      */
      async delete(namespace, key) {
        await this.batch([{
          namespace,
          key,
          value: null
        }]);
      }
      /**
      * List and filter namespaces in the store.
      * Used to explore data organization and navigate the namespace hierarchy.
      *
      * @param options Options for listing namespaces
      * @returns Promise resolving to list of namespace paths
      *
      * @example
      * // List all namespaces under "documents"
      * await store.listNamespaces({
      *   prefix: ["documents"],
      *   maxDepth: 2
      * });
      *
      * // List namespaces ending with "v1"
      * await store.listNamespaces({
      *   suffix: ["v1"],
      *   limit: 50
      * });
      */
      async listNamespaces(options = {}) {
        const { prefix, suffix, maxDepth, limit: limit2 = 100, offset = 0 } = options;
        const matchConditions = [];
        if (prefix) matchConditions.push({
          matchType: "prefix",
          path: prefix
        });
        if (suffix) matchConditions.push({
          matchType: "suffix",
          path: suffix
        });
        return (await this.batch([{
          matchConditions: matchConditions.length ? matchConditions : void 0,
          maxDepth,
          limit: limit2,
          offset
        }]))[0];
      }
      /**
      * Start the store. Override if initialization is needed.
      */
      start() {
      }
      /**
      * Stop the store. Override if cleanup is needed.
      */
      stop() {
      }
    };
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/store/batch.js
var extractStore, AsyncBatchedStore;
var init_batch = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/store/batch.js"() {
    init_base13();
    extractStore = (input) => {
      if ("lg_name" in input && input.lg_name === "AsyncBatchedStore") return input.store;
      return input;
    };
    AsyncBatchedStore = class extends BaseStore2 {
      lg_name = "AsyncBatchedStore";
      store;
      queue = /* @__PURE__ */ new Map();
      nextKey = 0;
      running = false;
      processingTask = null;
      constructor(store) {
        super();
        this.store = extractStore(store);
      }
      get isRunning() {
        return this.running;
      }
      /**
      * @ignore
      * Batch is not implemented here as we're only extending `BaseStore`
      * to allow it to be passed where `BaseStore` is expected, and implement
      * the convenience methods (get, search, put, delete).
      */
      async batch(_operations) {
        throw new Error("The `batch` method is not implemented on `AsyncBatchedStore`.\n Instead, it calls the `batch` method on the wrapped store.\n If you are seeing this error, something is wrong.");
      }
      async get(namespace, key) {
        return this.enqueueOperation({
          namespace,
          key
        });
      }
      async search(namespacePrefix, options) {
        const { filter, limit: limit2 = 10, offset = 0, query } = options || {};
        return this.enqueueOperation({
          namespacePrefix,
          filter,
          limit: limit2,
          offset,
          query
        });
      }
      async put(namespace, key, value) {
        return this.enqueueOperation({
          namespace,
          key,
          value
        });
      }
      async delete(namespace, key) {
        return this.enqueueOperation({
          namespace,
          key,
          value: null
        });
      }
      start() {
        if (!this.running) {
          this.running = true;
          this.processingTask = this.processBatchQueue();
        }
      }
      async stop() {
        this.running = false;
        if (this.processingTask) await this.processingTask;
      }
      enqueueOperation(operation) {
        return new Promise((resolve, reject) => {
          const key = this.nextKey;
          this.nextKey += 1;
          this.queue.set(key, {
            operation,
            resolve,
            reject
          });
        });
      }
      async processBatchQueue() {
        while (this.running) {
          await new Promise((resolve) => {
            setTimeout(resolve, 0);
          });
          if (this.queue.size === 0) continue;
          const batch = new Map(this.queue);
          this.queue.clear();
          try {
            const operations = Array.from(batch.values()).map(({ operation }) => operation);
            const results = await this.store.batch(operations);
            batch.forEach(({ resolve }, key) => {
              const index2 = Array.from(batch.keys()).indexOf(key);
              resolve(results[index2]);
            });
          } catch (e) {
            batch.forEach(({ reject }) => {
              reject(e);
            });
          }
        }
      }
      toJSON() {
        return {
          queue: this.queue,
          nextKey: this.nextKey,
          running: this.running,
          store: "[LangGraphStore]"
        };
      }
    };
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/store/utils.js
var init_utils7 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/store/utils.js"() {
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/store/memory.js
var init_memory3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/store/memory.js"() {
    init_base13();
    init_utils7();
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js
var BaseCache2;
var init_base14 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js"() {
    init_jsonplus();
    BaseCache2 = class {
      serde = new JsonPlusSerializer();
      /**
      * Initialize the cache with a serializer.
      *
      * @param serde - The serializer to use.
      */
      constructor(serde) {
        this.serde = serde || this.serde;
      }
    };
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.js
var init_memory4 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.js"() {
    init_base14();
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/cache/index.js
var init_cache = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/cache/index.js"() {
    init_base14();
    init_memory4();
  }
});

// node_modules/@langchain/langgraph-checkpoint/dist/index.js
var init_dist3 = __esm({
  "node_modules/@langchain/langgraph-checkpoint/dist/index.js"() {
    init_id();
    init_types2();
    init_base12();
    init_memory2();
    init_base13();
    init_batch();
    init_memory3();
    init_base14();
    init_memory4();
    init_cache();
  }
});

// node_modules/@langchain/langgraph/dist/channels/base.js
function isBaseChannel(obj) {
  return obj != null && obj.lg_is_channel === true;
}
function getOnlyChannels(channels) {
  if (channels[IS_ONLY_BASE_CHANNEL] === true) return channels;
  const newChannels = {};
  for (const k in channels) {
    if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;
    const value = channels[k];
    if (isBaseChannel(value)) newChannels[k] = value;
  }
  Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });
  return newChannels;
}
function emptyChannels(channels, checkpoint) {
  const filteredChannels = getOnlyChannels(channels);
  const newChannels = {};
  for (const k in filteredChannels) {
    if (!Object.prototype.hasOwnProperty.call(filteredChannels, k)) continue;
    const channelValue = checkpoint.channel_values[k];
    newChannels[k] = filteredChannels[k].fromCheckpoint(channelValue);
  }
  Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });
  return newChannels;
}
function createCheckpoint(checkpoint, channels, step, options) {
  let values;
  if (channels === void 0) values = checkpoint.channel_values;
  else {
    values = {};
    for (const k in channels) {
      if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;
      try {
        values[k] = channels[k].checkpoint();
      } catch (error40) {
        if (error40.name === EmptyChannelError.unminifiable_name) {
        } else throw error40;
      }
    }
  }
  return {
    v: 4,
    id: options?.id ?? uuid6(step),
    ts: (/* @__PURE__ */ new Date()).toISOString(),
    channel_values: values,
    channel_versions: checkpoint.channel_versions,
    versions_seen: checkpoint.versions_seen
  };
}
var BaseChannel, IS_ONLY_BASE_CHANNEL;
var init_base15 = __esm({
  "node_modules/@langchain/langgraph/dist/channels/base.js"() {
    init_errors3();
    init_dist3();
    BaseChannel = class {
      ValueType;
      UpdateType;
      /** @ignore */
      lg_is_channel = true;
      /**
      * Mark the current value of the channel as consumed. By default, no-op.
      * A channel can use this method to modify its state, preventing the value
      * from being consumed again.
      *
      * Returns True if the channel was updated, False otherwise.
      */
      consume() {
        return false;
      }
      /**
      * Notify the channel that the Pregel run is finishing. By default, no-op.
      * A channel can use this method to modify its state, preventing finish.
      *
      * Returns True if the channel was updated, False otherwise.
      */
      finish() {
        return false;
      }
      /**
      * Return True if the channel is available (not empty), False otherwise.
      * Subclasses should override this method to provide a more efficient
      * implementation than calling get() and catching EmptyChannelError.
      */
      isAvailable() {
        try {
          this.get();
          return true;
        } catch (error40) {
          if (error40.name === EmptyChannelError.unminifiable_name) return false;
          throw error40;
        }
      }
      /**
      * Compare this channel with another channel for equality.
      * Used to determine if two channels with the same key are semantically equivalent.
      * Subclasses should override this method to provide a meaningful comparison.
      *
      * @param {BaseChannel} other - The other channel to compare with.
      * @returns {boolean} True if the channels are equal, false otherwise.
      */
      equals(other) {
        return this === other;
      }
    };
    IS_ONLY_BASE_CHANNEL = Symbol.for("LG_IS_ONLY_BASE_CHANNEL");
  }
});

// node_modules/@langchain/langgraph/dist/channels/binop.js
var isBinaryOperatorAggregate, BinaryOperatorAggregate;
var init_binop = __esm({
  "node_modules/@langchain/langgraph/dist/channels/binop.js"() {
    init_errors3();
    init_base15();
    isBinaryOperatorAggregate = (value) => {
      return value != null && value.lc_graph_name === "BinaryOperatorAggregate";
    };
    BinaryOperatorAggregate = class BinaryOperatorAggregate2 extends BaseChannel {
      lc_graph_name = "BinaryOperatorAggregate";
      value;
      operator;
      initialValueFactory;
      constructor(operator, initialValueFactory) {
        super();
        this.operator = operator;
        this.initialValueFactory = initialValueFactory;
        this.value = initialValueFactory?.();
      }
      fromCheckpoint(checkpoint) {
        const empty = new BinaryOperatorAggregate2(this.operator, this.initialValueFactory);
        if (typeof checkpoint !== "undefined") empty.value = checkpoint;
        return empty;
      }
      update(values) {
        let newValues = values;
        if (!newValues.length) return false;
        if (this.value === void 0) {
          [this.value] = newValues;
          newValues = newValues.slice(1);
        }
        for (const value of newValues) if (this.value !== void 0) this.value = this.operator(this.value, value);
        return true;
      }
      get() {
        if (this.value === void 0) throw new EmptyChannelError();
        return this.value;
      }
      checkpoint() {
        if (this.value === void 0) throw new EmptyChannelError();
        return this.value;
      }
      isAvailable() {
        return this.value !== void 0;
      }
      /**
      * Compare this channel with another channel for equality.
      * Two BinaryOperatorAggregate channels are equal if they have the same operator function.
      * This follows the Python implementation which compares operator references.
      */
      equals(other) {
        if (this === other) return true;
        if (!isBinaryOperatorAggregate(other)) return false;
        return this.operator === other.operator;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/channels/last_value.js
var LastValue, LastValueAfterFinish;
var init_last_value = __esm({
  "node_modules/@langchain/langgraph/dist/channels/last_value.js"() {
    init_errors3();
    init_base15();
    LastValue = class LastValue2 extends BaseChannel {
      lc_graph_name = "LastValue";
      value = [];
      constructor(initialValueFactory) {
        super();
        this.initialValueFactory = initialValueFactory;
        if (initialValueFactory) this.value = [initialValueFactory()];
      }
      fromCheckpoint(checkpoint) {
        const empty = new LastValue2(this.initialValueFactory);
        if (typeof checkpoint !== "undefined") empty.value = [checkpoint];
        return empty;
      }
      update(values) {
        if (values.length === 0) return false;
        if (values.length !== 1) throw new InvalidUpdateError("LastValue can only receive one value per step.", { lc_error_code: "INVALID_CONCURRENT_GRAPH_UPDATE" });
        this.value = [values[values.length - 1]];
        return true;
      }
      get() {
        if (this.value.length === 0) throw new EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) throw new EmptyChannelError();
        return this.value[0];
      }
      isAvailable() {
        return this.value.length !== 0;
      }
    };
    LastValueAfterFinish = class LastValueAfterFinish2 extends BaseChannel {
      lc_graph_name = "LastValueAfterFinish";
      value = [];
      finished = false;
      fromCheckpoint(checkpoint) {
        const empty = new LastValueAfterFinish2();
        if (typeof checkpoint !== "undefined") {
          const [value, finished] = checkpoint;
          empty.value = [value];
          empty.finished = finished;
        }
        return empty;
      }
      update(values) {
        if (values.length === 0) return false;
        this.finished = false;
        this.value = [values[values.length - 1]];
        return true;
      }
      get() {
        if (this.value.length === 0 || !this.finished) throw new EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) return void 0;
        return [this.value[0], this.finished];
      }
      consume() {
        if (this.finished) {
          this.finished = false;
          this.value = [];
          return true;
        }
        return false;
      }
      finish() {
        if (!this.finished && this.value.length > 0) {
          this.finished = true;
          return true;
        }
        return false;
      }
      isAvailable() {
        return this.value.length !== 0 && this.finished;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/graph/annotation.js
function getChannel(reducer) {
  if (typeof reducer === "object" && reducer && "reducer" in reducer && reducer.reducer) return new BinaryOperatorAggregate(reducer.reducer, reducer.default);
  if (typeof reducer === "object" && reducer && "value" in reducer && reducer.value) return new BinaryOperatorAggregate(reducer.value, reducer.default);
  return new LastValue();
}
var AnnotationRoot, Annotation;
var init_annotation = __esm({
  "node_modules/@langchain/langgraph/dist/graph/annotation.js"() {
    init_binop();
    init_last_value();
    AnnotationRoot = class {
      lc_graph_name = "AnnotationRoot";
      spec;
      constructor(s) {
        this.spec = s;
      }
      static isInstance(value) {
        return typeof value === "object" && value !== null && "lc_graph_name" in value && value.lc_graph_name === "AnnotationRoot";
      }
    };
    Annotation = function(annotation) {
      if (annotation) return getChannel(annotation);
      else return new LastValue();
    };
    Annotation.Root = (sd) => new AnnotationRoot(sd);
  }
});

// node_modules/@langchain/langgraph/dist/constants.js
function _isSendInterface(x) {
  const operation = x;
  return operation !== null && operation !== void 0 && typeof operation.node === "string" && operation.args !== void 0;
}
function _isSend(x) {
  return x instanceof Send;
}
function isInterrupted(values) {
  if (!values || typeof values !== "object") return false;
  if (!(INTERRUPT2 in values)) return false;
  return Array.isArray(values[INTERRUPT2]);
}
function isCommand(x) {
  if (typeof x !== "object") return false;
  if (x === null || x === void 0) return false;
  if ("lg_name" in x && x.lg_name === "Command") return true;
  return false;
}
function _deserializeCommandSendObjectGraph(x, seen = /* @__PURE__ */ new Map()) {
  if (x !== void 0 && x !== null && typeof x === "object") {
    if (seen.has(x)) return seen.get(x);
    let result;
    if (Array.isArray(x)) {
      result = [];
      seen.set(x, result);
      x.forEach((item, index2) => {
        result[index2] = _deserializeCommandSendObjectGraph(item, seen);
      });
    } else if (isCommand(x) && !(x instanceof Command)) {
      result = new Command(x);
      seen.set(x, result);
    } else if (_isSendInterface(x) && !(x instanceof Send)) {
      result = new Send(x.node, x.args);
      seen.set(x, result);
    } else if (isCommand(x) || _isSend(x)) {
      result = x;
      seen.set(x, result);
    } else if ("lc_serializable" in x && x.lc_serializable) {
      result = x;
      seen.set(x, result);
    } else {
      result = {};
      seen.set(x, result);
      for (const [key, value] of Object.entries(x)) result[key] = _deserializeCommandSendObjectGraph(value, seen);
    }
    return result;
  }
  return x;
}
var START, END, INPUT, COPY, ERROR3, CACHE_NS_WRITES, CONFIG_KEY_SEND, CONFIG_KEY_CALL, CONFIG_KEY_READ, CONFIG_KEY_CHECKPOINTER, CONFIG_KEY_RESUMING, CONFIG_KEY_TASK_ID, CONFIG_KEY_STREAM, CONFIG_KEY_RESUME_VALUE, CONFIG_KEY_RESUME_MAP, CONFIG_KEY_SCRATCHPAD, CONFIG_KEY_PREVIOUS_STATE, CONFIG_KEY_DURABILITY, CONFIG_KEY_CHECKPOINT_ID, CONFIG_KEY_CHECKPOINT_NS, CONFIG_KEY_NODE_FINISHED, CONFIG_KEY_CHECKPOINT_MAP, CONFIG_KEY_ABORT_SIGNALS, INTERRUPT2, RESUME2, NO_WRITES, RETURN, PREVIOUS, TAG_HIDDEN, TAG_NOSTREAM, SELF, TASKS2, PUSH, PULL, NULL_TASK_ID, RESERVED, CHECKPOINT_NAMESPACE_SEPARATOR, CHECKPOINT_NAMESPACE_END, COMMAND_SYMBOL, CommandInstance, Send, Command;
var init_constants3 = __esm({
  "node_modules/@langchain/langgraph/dist/constants.js"() {
    START = "__start__";
    END = "__end__";
    INPUT = "__input__";
    COPY = "__copy__";
    ERROR3 = "__error__";
    CACHE_NS_WRITES = "__pregel_ns_writes";
    CONFIG_KEY_SEND = "__pregel_send";
    CONFIG_KEY_CALL = "__pregel_call";
    CONFIG_KEY_READ = "__pregel_read";
    CONFIG_KEY_CHECKPOINTER = "__pregel_checkpointer";
    CONFIG_KEY_RESUMING = "__pregel_resuming";
    CONFIG_KEY_TASK_ID = "__pregel_task_id";
    CONFIG_KEY_STREAM = "__pregel_stream";
    CONFIG_KEY_RESUME_VALUE = "__pregel_resume_value";
    CONFIG_KEY_RESUME_MAP = "__pregel_resume_map";
    CONFIG_KEY_SCRATCHPAD = "__pregel_scratchpad";
    CONFIG_KEY_PREVIOUS_STATE = "__pregel_previous";
    CONFIG_KEY_DURABILITY = "__pregel_durability";
    CONFIG_KEY_CHECKPOINT_ID = "checkpoint_id";
    CONFIG_KEY_CHECKPOINT_NS = "checkpoint_ns";
    CONFIG_KEY_NODE_FINISHED = "__pregel_node_finished";
    CONFIG_KEY_CHECKPOINT_MAP = "checkpoint_map";
    CONFIG_KEY_ABORT_SIGNALS = "__pregel_abort_signals";
    INTERRUPT2 = "__interrupt__";
    RESUME2 = "__resume__";
    NO_WRITES = "__no_writes__";
    RETURN = "__return__";
    PREVIOUS = "__previous__";
    TAG_HIDDEN = "langsmith:hidden";
    TAG_NOSTREAM = "langsmith:nostream";
    SELF = "__self__";
    TASKS2 = "__pregel_tasks";
    PUSH = "__pregel_push";
    PULL = "__pregel_pull";
    NULL_TASK_ID = "00000000-0000-0000-0000-000000000000";
    RESERVED = [
      TAG_HIDDEN,
      INPUT,
      INTERRUPT2,
      RESUME2,
      ERROR3,
      NO_WRITES,
      CONFIG_KEY_SEND,
      CONFIG_KEY_READ,
      CONFIG_KEY_CHECKPOINTER,
      CONFIG_KEY_DURABILITY,
      CONFIG_KEY_STREAM,
      CONFIG_KEY_RESUMING,
      CONFIG_KEY_TASK_ID,
      CONFIG_KEY_CALL,
      CONFIG_KEY_RESUME_VALUE,
      CONFIG_KEY_SCRATCHPAD,
      CONFIG_KEY_PREVIOUS_STATE,
      CONFIG_KEY_CHECKPOINT_MAP,
      CONFIG_KEY_CHECKPOINT_NS,
      CONFIG_KEY_CHECKPOINT_ID
    ];
    CHECKPOINT_NAMESPACE_SEPARATOR = "|";
    CHECKPOINT_NAMESPACE_END = ":";
    COMMAND_SYMBOL = Symbol.for("langgraph.command");
    CommandInstance = class {
      [COMMAND_SYMBOL];
      constructor(args) {
        this[COMMAND_SYMBOL] = args;
      }
    };
    Send = class {
      lg_name = "Send";
      node;
      args;
      constructor(node, args) {
        this.node = node;
        this.args = _deserializeCommandSendObjectGraph(args);
      }
      toJSON() {
        return {
          lg_name: this.lg_name,
          node: this.node,
          args: this.args
        };
      }
    };
    Command = class extends CommandInstance {
      lg_name = "Command";
      lc_direct_tool_output = true;
      /**
      * Graph to send the command to. Supported values are:
      *   - None: the current graph (default)
      *   - The specific name of the graph to send the command to
      *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)
      */
      graph;
      /**
      * Update to apply to the graph's state as a result of executing the node that is returning the command.
      * Written to the state as if the node had simply returned this value instead of the Command object.
      */
      update;
      /**
      * Value to resume execution with. To be used together with {@link interrupt}.
      */
      resume;
      /**
      * Can be one of the following:
      *   - name of the node to navigate to next (any node that belongs to the specified `graph`)
      *   - sequence of node names to navigate to next
      *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)
      *   - sequence of {@link Send} objects
      */
      goto = [];
      static PARENT = "__parent__";
      constructor(args) {
        super(args);
        this.resume = args.resume;
        this.graph = args.graph;
        this.update = args.update;
        if (args.goto) this.goto = Array.isArray(args.goto) ? _deserializeCommandSendObjectGraph(args.goto) : [_deserializeCommandSendObjectGraph(args.goto)];
      }
      /**
      * Convert the update field to a list of {@link PendingWrite} tuples
      * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.
      * @internal
      */
      _updateAsTuples() {
        if (this.update && typeof this.update === "object" && !Array.isArray(this.update)) return Object.entries(this.update);
        else if (Array.isArray(this.update) && this.update.every((t) => Array.isArray(t) && t.length === 2 && typeof t[0] === "string")) return this.update;
        else return [["__root__", this.update]];
      }
      toJSON() {
        let serializedGoto;
        if (typeof this.goto === "string") serializedGoto = this.goto;
        else if (_isSend(this.goto)) serializedGoto = this.goto.toJSON();
        else serializedGoto = this.goto?.map((innerGoto) => {
          if (typeof innerGoto === "string") return innerGoto;
          else return innerGoto.toJSON();
        });
        return {
          lg_name: this.lg_name,
          update: this.update,
          resume: this.resume,
          goto: serializedGoto
        };
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/utils/config.js
function ensureLangGraphConfig(...configs) {
  const empty = {
    tags: [],
    metadata: {},
    callbacks: void 0,
    recursionLimit: DEFAULT_RECURSION_LIMIT2,
    configurable: {}
  };
  const implicitConfig = AsyncLocalStorageProviderSingleton2.getRunnableConfig();
  if (implicitConfig !== void 0) {
    for (const [k, v] of Object.entries(implicitConfig)) if (v !== void 0) if (COPIABLE_KEYS.includes(k)) {
      let copiedValue;
      if (Array.isArray(v)) copiedValue = [...v];
      else if (typeof v === "object") if (k === "callbacks" && "copy" in v && typeof v.copy === "function") copiedValue = v.copy();
      else copiedValue = { ...v };
      else copiedValue = v;
      empty[k] = copiedValue;
    } else empty[k] = v;
  }
  for (const config2 of configs) {
    if (config2 === void 0) continue;
    for (const [k, v] of Object.entries(config2)) if (v !== void 0 && CONFIG_KEYS.includes(k)) empty[k] = v;
  }
  for (const [key, value] of Object.entries(empty.configurable)) {
    empty.metadata = empty.metadata ?? {};
    if (!key.startsWith("__") && (typeof value === "string" || typeof value === "number" || typeof value === "boolean") && !(key in empty.metadata)) empty.metadata[key] = value;
  }
  return empty;
}
function getConfig() {
  return AsyncLocalStorageProviderSingleton2.getRunnableConfig();
}
function recastCheckpointNamespace(namespace) {
  return namespace.split(CHECKPOINT_NAMESPACE_SEPARATOR).filter((part) => !part.match(/^\d+$/)).map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0]).join(CHECKPOINT_NAMESPACE_SEPARATOR);
}
function getParentCheckpointNamespace(namespace) {
  const parts = namespace.split(CHECKPOINT_NAMESPACE_SEPARATOR);
  while (parts.length > 1 && parts[parts.length - 1].match(/^\d+$/)) parts.pop();
  return parts.slice(0, -1).join(CHECKPOINT_NAMESPACE_SEPARATOR);
}
var COPIABLE_KEYS, CONFIG_KEYS, DEFAULT_RECURSION_LIMIT2;
var init_config2 = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/utils/config.js"() {
    init_constants3();
    init_singletons();
    COPIABLE_KEYS = [
      "tags",
      "metadata",
      "callbacks",
      "configurable"
    ];
    CONFIG_KEYS = [
      "tags",
      "metadata",
      "callbacks",
      "runName",
      "maxConcurrency",
      "recursionLimit",
      "configurable",
      "runId",
      "outputKeys",
      "streamMode",
      "store",
      "writer",
      "interrupt",
      "context",
      "interruptBefore",
      "interruptAfter",
      "checkpointDuring",
      "durability",
      "signal"
    ];
    DEFAULT_RECURSION_LIMIT2 = 25;
  }
});

// node_modules/@langchain/langgraph/dist/hash.js
function assert2(a) {
  if (!a) throw new Error("Assert failed");
}
function bswap64(a) {
  const scratchbuf = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(8));
  scratchbuf.setBigUint64(0, a, true);
  return scratchbuf.getBigUint64(0, false);
}
function bswap32(input) {
  let a = input;
  a = (a & n(65535)) << n(16) | (a & n(4294901760)) >> n(16);
  a = (a & n(16711935)) << n(8) | (a & n(4278255360)) >> n(8);
  return a;
}
function XXH_mult32to64(a, b) {
  return (a & mask32) * (b & mask32) & mask64;
}
function rotl32(a, b) {
  return (a << b | a >> n(32) - b) & mask32;
}
function XXH3_accumulate_512(acc, dataView, keyView) {
  for (let i = 0; i < ACC_NB; i += 1) {
    const data_val = dataView.getBigUint64(i * 8, true);
    const data_key = data_val ^ keyView.getBigUint64(i * 8, true);
    acc[i ^ 1] += data_val;
    acc[i] += XXH_mult32to64(data_key, data_key >> n(32));
  }
  return acc;
}
function XXH3_accumulate(acc, dataView, keyView, nbStripes) {
  for (let n2 = 0; n2 < nbStripes; n2 += 1) XXH3_accumulate_512(acc, view(dataView, n2 * STRIPE_LEN), view(keyView, n2 * 8));
  return acc;
}
function XXH3_scrambleAcc(acc, key) {
  for (let i = 0; i < ACC_NB; i += 1) {
    const key64 = key.getBigUint64(i * 8, true);
    let acc64 = acc[i];
    acc64 = xorshift64(acc64, n(47));
    acc64 ^= key64;
    acc64 *= PRIME32_1;
    acc[i] = acc64 & mask64;
  }
  return acc;
}
function XXH3_mix2Accs(acc, key) {
  return XXH3_mul128_fold64(acc[0] ^ key.getBigUint64(0, true), acc[1] ^ key.getBigUint64(_U64, true));
}
function XXH3_mergeAccs(acc, key, start) {
  let result64 = start;
  result64 += XXH3_mix2Accs(acc.slice(0), view(key, 0 * _U32));
  result64 += XXH3_mix2Accs(acc.slice(2), view(key, 4 * _U32));
  result64 += XXH3_mix2Accs(acc.slice(4), view(key, 8 * _U32));
  result64 += XXH3_mix2Accs(acc.slice(6), view(key, 12 * _U32));
  return XXH3_avalanche(result64 & mask64);
}
function XXH3_hashLong(input, data, secret, f_acc, f_scramble) {
  let acc = input;
  const nbStripesPerBlock = Math.floor((secret.byteLength - STRIPE_LEN) / 8);
  const block_len = STRIPE_LEN * nbStripesPerBlock;
  const nb_blocks = Math.floor((data.byteLength - 1) / block_len);
  for (let n2 = 0; n2 < nb_blocks; n2 += 1) {
    acc = XXH3_accumulate(acc, view(data, n2 * block_len), secret, nbStripesPerBlock);
    acc = f_scramble(acc, view(secret, secret.byteLength - STRIPE_LEN));
  }
  {
    const nbStripes = Math.floor((data.byteLength - 1 - block_len * nb_blocks) / STRIPE_LEN);
    acc = XXH3_accumulate(acc, view(data, nb_blocks * block_len), secret, nbStripes);
    acc = f_acc(acc, view(data, data.byteLength - STRIPE_LEN), view(secret, secret.byteLength - STRIPE_LEN - 7));
  }
  return acc;
}
function XXH3_hashLong_128b(data, secret) {
  let acc = new BigUint64Array([
    PRIME32_3,
    PRIME64_1,
    PRIME64_2,
    PRIME64_3,
    PRIME64_4,
    PRIME32_2,
    PRIME64_5,
    PRIME32_1
  ]);
  assert2(data.byteLength > 128);
  acc = XXH3_hashLong(acc, data, secret, XXH3_accumulate_512, XXH3_scrambleAcc);
  assert2(acc.length * 8 === 64);
  {
    const low64 = XXH3_mergeAccs(acc, view(secret, 11), n(data.byteLength) * PRIME64_1 & mask64);
    return XXH3_mergeAccs(acc, view(secret, secret.byteLength - STRIPE_LEN - 11), ~(n(data.byteLength) * PRIME64_2) & mask64) << n(64) | low64;
  }
}
function XXH3_mul128_fold64(a, b) {
  const lll = a * b & mask128;
  return lll & mask64 ^ lll >> n(64);
}
function XXH3_mix16B(dataView, keyView, seed) {
  return XXH3_mul128_fold64((dataView.getBigUint64(0, true) ^ keyView.getBigUint64(0, true) + seed) & mask64, (dataView.getBigUint64(8, true) ^ keyView.getBigUint64(8, true) - seed) & mask64);
}
function XXH3_mix32B(acc, data1, data2, key, seed) {
  let accl = acc & mask64;
  let acch = acc >> n(64) & mask64;
  accl += XXH3_mix16B(data1, key, seed);
  accl ^= data2.getBigUint64(0, true) + data2.getBigUint64(8, true);
  accl &= mask64;
  acch += XXH3_mix16B(data2, view(key, 16), seed);
  acch ^= data1.getBigUint64(0, true) + data1.getBigUint64(8, true);
  acch &= mask64;
  return acch << n(64) | accl;
}
function XXH3_avalanche(input) {
  let h64 = input;
  h64 ^= h64 >> n(37);
  h64 *= PRIME_MX1;
  h64 &= mask64;
  h64 ^= h64 >> n(32);
  return h64;
}
function XXH3_avalanche64(input) {
  let h64 = input;
  h64 ^= h64 >> n(33);
  h64 *= PRIME64_2;
  h64 &= mask64;
  h64 ^= h64 >> n(29);
  h64 *= PRIME64_3;
  h64 &= mask64;
  h64 ^= h64 >> n(32);
  return h64;
}
function XXH3_len_1to3_128b(data, key32, seed) {
  const len = data.byteLength;
  assert2(len > 0 && len <= 3);
  const combined = n(data.getUint8(len - 1)) | n(len << 8) | n(data.getUint8(0) << 16) | n(data.getUint8(len >> 1) << 24);
  const low = (combined ^ (n(key32.getUint32(0, true)) ^ n(key32.getUint32(4, true))) + seed) & mask64;
  const bhigh = (n(key32.getUint32(8, true)) ^ n(key32.getUint32(12, true))) - seed;
  return (XXH3_avalanche64((rotl32(bswap32(combined), n(13)) ^ bhigh) & mask64) & mask64) << n(64) | XXH3_avalanche64(low);
}
function xorshift64(b, shift) {
  return b ^ b >> shift;
}
function XXH3_len_4to8_128b(data, key32, seed) {
  const len = data.byteLength;
  assert2(len >= 4 && len <= 8);
  {
    const l1 = data.getUint32(0, true);
    const l2 = data.getUint32(len - 4, true);
    let m128 = ((n(l1) | n(l2) << n(32)) ^ (key32.getBigUint64(16, true) ^ key32.getBigUint64(24, true)) + seed & mask64) * (PRIME64_1 + (n(len) << n(2))) & mask128;
    m128 += (m128 & mask64) << n(65);
    m128 &= mask128;
    m128 ^= m128 >> n(67);
    return xorshift64(xorshift64(m128 & mask64, n(35)) * PRIME_MX2 & mask64, n(28)) | XXH3_avalanche(m128 >> n(64)) << n(64);
  }
}
function XXH3_len_9to16_128b(data, key64, seed) {
  const len = data.byteLength;
  assert2(len >= 9 && len <= 16);
  {
    const bitflipl = (key64.getBigUint64(32, true) ^ key64.getBigUint64(40, true)) + seed & mask64;
    const bitfliph = (key64.getBigUint64(48, true) ^ key64.getBigUint64(56, true)) - seed & mask64;
    const ll1 = data.getBigUint64(0, true);
    let ll2 = data.getBigUint64(len - 8, true);
    let m128 = (ll1 ^ ll2 ^ bitflipl) * PRIME64_1;
    const m128_l = (m128 & mask64) + (n(len - 1) << n(54));
    m128 = m128 & (mask128 ^ mask64) | m128_l;
    ll2 ^= bitfliph;
    m128 += ll2 + (ll2 & mask32) * (PRIME32_2 - n(1)) << n(64);
    m128 &= mask128;
    m128 ^= bswap64(m128 >> n(64));
    let h128 = (m128 & mask64) * PRIME64_2;
    h128 += (m128 >> n(64)) * PRIME64_2 << n(64);
    h128 &= mask128;
    return XXH3_avalanche(h128 & mask64) | XXH3_avalanche(h128 >> n(64)) << n(64);
  }
}
function XXH3_len_0to16_128b(data, seed) {
  const len = data.byteLength;
  assert2(len <= 16);
  if (len > 8) return XXH3_len_9to16_128b(data, kkey, seed);
  if (len >= 4) return XXH3_len_4to8_128b(data, kkey, seed);
  if (len > 0) return XXH3_len_1to3_128b(data, kkey, seed);
  return XXH3_avalanche64(seed ^ kkey.getBigUint64(64, true) ^ kkey.getBigUint64(72, true)) | XXH3_avalanche64(seed ^ kkey.getBigUint64(80, true) ^ kkey.getBigUint64(88, true)) << n(64);
}
function inv64(x) {
  return ~x + n(1) & mask64;
}
function XXH3_len_17to128_128b(data, secret, seed) {
  let acc = n(data.byteLength) * PRIME64_1 & mask64;
  let i = n(data.byteLength - 1) / n(32);
  while (i >= 0) {
    const ni = Number(i);
    acc = XXH3_mix32B(acc, view(data, 16 * ni), view(data, data.byteLength - 16 * (ni + 1)), view(secret, 32 * ni), seed);
    i -= n(1);
  }
  let h128l = acc + (acc >> n(64)) & mask64;
  h128l = XXH3_avalanche(h128l);
  let h128h = (acc & mask64) * PRIME64_1 + (acc >> n(64)) * PRIME64_4 + (n(data.byteLength) - seed & mask64) * PRIME64_2;
  h128h &= mask64;
  h128h = inv64(XXH3_avalanche(h128h));
  return h128l | h128h << n(64);
}
function XXH3_len_129to240_128b(data, secret, seed) {
  let acc = n(data.byteLength) * PRIME64_1 & mask64;
  for (let i = 32; i < 160; i += 32) acc = XXH3_mix32B(acc, view(data, i - 32), view(data, i - 16), view(secret, i - 32), seed);
  acc = XXH3_avalanche(acc & mask64) | XXH3_avalanche(acc >> n(64)) << n(64);
  for (let i = 160; i <= data.byteLength; i += 32) acc = XXH3_mix32B(acc, view(data, i - 32), view(data, i - 16), view(secret, 3 + i - 160), seed);
  acc = XXH3_mix32B(acc, view(data, data.byteLength - 16), view(data, data.byteLength - 32), view(secret, 103), inv64(seed));
  let h128l = acc + (acc >> n(64)) & mask64;
  h128l = XXH3_avalanche(h128l);
  let h128h = (acc & mask64) * PRIME64_1 + (acc >> n(64)) * PRIME64_4 + (n(data.byteLength) - seed & mask64) * PRIME64_2;
  h128h &= mask64;
  h128h = inv64(XXH3_avalanche(h128h));
  return h128l | h128h << n(64);
}
function XXH3(input, seed = n(0)) {
  const encoder2 = new TextEncoder();
  const data = view(typeof input === "string" ? encoder2.encode(input) : input);
  const len = data.byteLength;
  const hexDigest = (data2) => data2.toString(16).padStart(32, "0");
  if (len <= 16) return hexDigest(XXH3_len_0to16_128b(data, seed));
  if (len <= 128) return hexDigest(XXH3_len_17to128_128b(data, kkey, seed));
  if (len <= 240) return hexDigest(XXH3_len_129to240_128b(data, kkey, seed));
  return hexDigest(XXH3_hashLong_128b(data, kkey));
}
function isXXH3(value) {
  return /^[0-9a-f]{32}$/.test(value);
}
var n, view, PRIME32_1, PRIME32_2, PRIME32_3, PRIME64_1, PRIME64_2, PRIME64_3, PRIME64_4, PRIME64_5, PRIME_MX1, PRIME_MX2, hexToUint8Array, kkey, mask128, mask64, mask32, STRIPE_LEN, ACC_NB, _U64, _U32;
var init_hash3 = __esm({
  "node_modules/@langchain/langgraph/dist/hash.js"() {
    n = (n2) => BigInt(n2);
    view = (data, offset = 0) => new DataView(data.buffer, data.byteOffset + offset, data.byteLength - offset);
    PRIME32_1 = n("0x9E3779B1");
    PRIME32_2 = n("0x85EBCA77");
    PRIME32_3 = n("0xC2B2AE3D");
    PRIME64_1 = n("0x9E3779B185EBCA87");
    PRIME64_2 = n("0xC2B2AE3D27D4EB4F");
    PRIME64_3 = n("0x165667B19E3779F9");
    PRIME64_4 = n("0x85EBCA77C2B2AE63");
    PRIME64_5 = n("0x27D4EB2F165667C5");
    PRIME_MX1 = n("0x165667919E3779F9");
    PRIME_MX2 = n("0x9FB21C651E98DF25");
    hexToUint8Array = (hex) => {
      const strLen = hex.length;
      if (strLen % 2 !== 0) throw new Error("String should have an even number of characters");
      const maxLength = strLen / 2;
      const bytes = new Uint8Array(maxLength);
      let read = 0;
      let write = 0;
      while (write < maxLength) {
        const slice = hex.slice(read, read += 2);
        bytes[write] = Number.parseInt(slice, 16);
        write += 1;
      }
      return view(bytes);
    };
    kkey = hexToUint8Array("b8fe6c3923a44bbe7c01812cf721ad1cded46de9839097db7240a4a4b7b3671fcb79e64eccc0e578825ad07dccff7221b8084674f743248ee03590e6813a264c3c2852bb91c300cb88d0658b1b532ea371644897a20df94e3819ef46a9deacd8a8fa763fe39c343ff9dcbbc7c70b4f1d8a51e04bcdb45931c89f7ec9d9787364eac5ac8334d3ebc3c581a0fffa1363eb170ddd51b7f0da49d316552629d4689e2b16be587d47a1fc8ff8b8d17ad031ce45cb3a8f95160428afd7fbcabb4b407e");
    mask128 = (n(1) << n(128)) - n(1);
    mask64 = (n(1) << n(64)) - n(1);
    mask32 = (n(1) << n(32)) - n(1);
    STRIPE_LEN = 64;
    ACC_NB = STRIPE_LEN / 8;
    _U64 = 8;
    _U32 = 4;
  }
});

// node_modules/@langchain/langgraph/dist/interrupt.js
function interrupt(value) {
  const config2 = AsyncLocalStorageProviderSingleton2.getRunnableConfig();
  if (!config2) throw new Error("Called interrupt() outside the context of a graph.");
  const conf = config2.configurable;
  if (!conf) throw new Error("No configurable found in config");
  if (!conf[CONFIG_KEY_CHECKPOINTER]) throw new GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
  const scratchpad = conf[CONFIG_KEY_SCRATCHPAD];
  scratchpad.interruptCounter += 1;
  const idx = scratchpad.interruptCounter;
  if (scratchpad.resume.length > 0 && idx < scratchpad.resume.length) {
    conf[CONFIG_KEY_SEND]?.([[RESUME2, scratchpad.resume]]);
    return scratchpad.resume[idx];
  }
  if (scratchpad.nullResume !== void 0) {
    if (scratchpad.resume.length !== idx) throw new Error(`Resume length mismatch: ${scratchpad.resume.length} !== ${idx}`);
    const v = scratchpad.consumeNullResume();
    scratchpad.resume.push(v);
    conf[CONFIG_KEY_SEND]?.([[RESUME2, scratchpad.resume]]);
    return v;
  }
  const ns = conf[CONFIG_KEY_CHECKPOINT_NS]?.split(CHECKPOINT_NAMESPACE_SEPARATOR);
  throw new GraphInterrupt([{
    id: ns ? XXH3(ns.join(CHECKPOINT_NAMESPACE_SEPARATOR)) : void 0,
    value
  }]);
}
var init_interrupt = __esm({
  "node_modules/@langchain/langgraph/dist/interrupt.js"() {
    init_errors3();
    init_constants3();
    init_hash3();
    init_singletons();
  }
});

// node_modules/@langchain/langgraph/dist/utils.js
function* prefixGenerator(generator, prefix) {
  if (prefix === void 0) yield* generator;
  else for (const value of generator) yield [prefix, value];
}
async function gatherIterator(i) {
  const out = [];
  for await (const item of await i) out.push(item);
  return out;
}
function gatherIteratorSync(i) {
  const out = [];
  for (const item of i) out.push(item);
  return out;
}
function patchConfigurable(config2, patch) {
  if (!config2) return { configurable: patch };
  else if (!("configurable" in config2)) return {
    ...config2,
    configurable: patch
  };
  else return {
    ...config2,
    configurable: {
      ...config2.configurable,
      ...patch
    }
  };
}
function isAsyncGeneratorFunction(val) {
  return val != null && typeof val === "function" && val instanceof Object.getPrototypeOf(async function* () {
  }).constructor;
}
function isGeneratorFunction(val) {
  return val != null && typeof val === "function" && val instanceof Object.getPrototypeOf(function* () {
  }).constructor;
}
var RunnableCallable;
var init_utils8 = __esm({
  "node_modules/@langchain/langgraph/dist/utils.js"() {
    init_config2();
    init_singletons();
    init_runnables();
    RunnableCallable = class extends Runnable {
      lc_namespace = ["langgraph"];
      func;
      tags;
      config;
      trace = true;
      recurse = true;
      constructor(fields) {
        super();
        this.name = fields.name ?? fields.func.name;
        this.func = fields.func;
        this.config = fields.tags ? { tags: fields.tags } : void 0;
        this.trace = fields.trace ?? this.trace;
        this.recurse = fields.recurse ?? this.recurse;
      }
      async _tracedInvoke(input, config2, runManager) {
        return new Promise((resolve, reject) => {
          const childConfig = patchConfig(config2, { callbacks: runManager?.getChild() });
          AsyncLocalStorageProviderSingleton2.runWithConfig(childConfig, async () => {
            try {
              resolve(await this.func(input, childConfig));
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async invoke(input, options) {
        let returnValue;
        const config2 = ensureLangGraphConfig(options);
        const mergedConfig = mergeConfigs(this.config, config2);
        if (this.trace) returnValue = await this._callWithConfig(this._tracedInvoke, input, mergedConfig);
        else returnValue = await AsyncLocalStorageProviderSingleton2.runWithConfig(mergedConfig, async () => this.func(input, mergedConfig));
        if (Runnable.isRunnable(returnValue) && this.recurse) return await AsyncLocalStorageProviderSingleton2.runWithConfig(mergedConfig, async () => returnValue.invoke(input, mergedConfig));
        return returnValue;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/write.js
function _isSkipWrite(x) {
  return typeof x === "object" && x?.[Symbol.for("LG_SKIP_WRITE")] !== void 0;
}
function _isPassthrough(x) {
  return typeof x === "object" && x?.[Symbol.for("LG_PASSTHROUGH")] !== void 0;
}
function _isChannelWriteEntry(x) {
  return x !== void 0 && typeof x.channel === "string";
}
function _isChannelWriteTupleEntry(x) {
  return x !== void 0 && !_isChannelWriteEntry(x) && Runnable.isRunnable(x.mapper);
}
var SKIP_WRITE, PASSTHROUGH, IS_WRITER, ChannelWrite;
var init_write = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/write.js"() {
    init_errors3();
    init_constants3();
    init_utils8();
    init_runnables();
    SKIP_WRITE = { [Symbol.for("LG_SKIP_WRITE")]: true };
    PASSTHROUGH = { [Symbol.for("LG_PASSTHROUGH")]: true };
    IS_WRITER = Symbol("IS_WRITER");
    ChannelWrite = class ChannelWrite2 extends RunnableCallable {
      writes;
      constructor(writes, tags) {
        const name = `ChannelWrite<${writes.map((packet) => {
          if (_isSend(packet)) return packet.node;
          else if ("channel" in packet) return packet.channel;
          return "...";
        }).join(",")}>`;
        super({
          writes,
          name,
          tags,
          func: async (input, config2) => {
            return this._write(input, config2 ?? {});
          }
        });
        this.writes = writes;
      }
      async _write(input, config2) {
        const writes = this.writes.map((write) => {
          if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) return {
            mapper: write.mapper,
            value: input
          };
          else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) return {
            channel: write.channel,
            value: input,
            skipNone: write.skipNone,
            mapper: write.mapper
          };
          else return write;
        });
        await ChannelWrite2.doWrite(config2, writes);
        return input;
      }
      static async doWrite(config2, writes) {
        for (const w of writes) {
          if (_isChannelWriteEntry(w)) {
            if (w.channel === TASKS2) throw new InvalidUpdateError("Cannot write to the reserved channel TASKS");
            if (_isPassthrough(w.value)) throw new InvalidUpdateError("PASSTHROUGH value must be replaced");
          }
          if (_isChannelWriteTupleEntry(w)) {
            if (_isPassthrough(w.value)) throw new InvalidUpdateError("PASSTHROUGH value must be replaced");
          }
        }
        const writeEntries = [];
        for (const w of writes) if (_isSend(w)) writeEntries.push([TASKS2, w]);
        else if (_isChannelWriteTupleEntry(w)) {
          const mappedResult = await w.mapper.invoke(w.value, config2);
          if (mappedResult != null && mappedResult.length > 0) writeEntries.push(...mappedResult);
        } else if (_isChannelWriteEntry(w)) {
          const mappedValue = w.mapper !== void 0 ? await w.mapper.invoke(w.value, config2) : w.value;
          if (_isSkipWrite(mappedValue)) continue;
          if (w.skipNone && mappedValue === void 0) continue;
          writeEntries.push([w.channel, mappedValue]);
        } else throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);
        const write = config2.configurable?.[CONFIG_KEY_SEND];
        write(writeEntries);
      }
      static isWriter(runnable) {
        return runnable instanceof ChannelWrite2 || IS_WRITER in runnable && !!runnable[IS_WRITER];
      }
      static registerWriter(runnable) {
        return Object.defineProperty(runnable, IS_WRITER, { value: true });
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/read.js
var ChannelRead, defaultRunnableBound, PregelNode;
var init_read = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/read.js"() {
    init_constants3();
    init_utils8();
    init_write();
    init_runnables();
    ChannelRead = class ChannelRead2 extends RunnableCallable {
      lc_graph_name = "ChannelRead";
      channel;
      fresh = false;
      mapper;
      constructor(channel, mapper, fresh = false) {
        super({ func: (_, config2) => ChannelRead2.doRead(config2, this.channel, this.fresh, this.mapper) });
        this.fresh = fresh;
        this.mapper = mapper;
        this.channel = channel;
        this.name = Array.isArray(channel) ? `ChannelRead<${channel.join(",")}>` : `ChannelRead<${channel}>`;
      }
      static doRead(config2, channel, fresh, mapper) {
        const read = config2.configurable?.[CONFIG_KEY_READ];
        if (!read) throw new Error("Runnable is not configured with a read function. Make sure to call in the context of a Pregel process");
        if (mapper) return mapper(read(channel, fresh));
        else return read(channel, fresh);
      }
    };
    defaultRunnableBound = /* @__PURE__ */ new RunnablePassthrough();
    PregelNode = class PregelNode2 extends RunnableBinding {
      lc_graph_name = "PregelNode";
      channels;
      triggers = [];
      mapper;
      writers = [];
      bound = defaultRunnableBound;
      kwargs = {};
      metadata = {};
      tags = [];
      retryPolicy;
      cachePolicy;
      subgraphs;
      ends;
      constructor(fields) {
        const { channels, triggers, mapper, writers, bound, kwargs, metadata, retryPolicy, cachePolicy, tags, subgraphs, ends } = fields;
        const mergedTags = [...fields.config?.tags ? fields.config.tags : [], ...tags ?? []];
        super({
          ...fields,
          bound: fields.bound ?? defaultRunnableBound,
          config: {
            ...fields.config ? fields.config : {},
            tags: mergedTags
          }
        });
        this.channels = channels;
        this.triggers = triggers;
        this.mapper = mapper;
        this.writers = writers ?? this.writers;
        this.bound = bound ?? this.bound;
        this.kwargs = kwargs ?? this.kwargs;
        this.metadata = metadata ?? this.metadata;
        this.tags = mergedTags;
        this.retryPolicy = retryPolicy;
        this.cachePolicy = cachePolicy;
        this.subgraphs = subgraphs;
        this.ends = ends;
      }
      getWriters() {
        const newWriters = [...this.writers];
        while (newWriters.length > 1 && newWriters[newWriters.length - 1] instanceof ChannelWrite && newWriters[newWriters.length - 2] instanceof ChannelWrite) {
          const endWriters = newWriters.slice(-2);
          const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);
          newWriters[newWriters.length - 2] = new ChannelWrite(combinedWrites, endWriters[0].config?.tags);
          newWriters.pop();
        }
        return newWriters;
      }
      getNode() {
        const writers = this.getWriters();
        if (this.bound === defaultRunnableBound && writers.length === 0) return;
        else if (this.bound === defaultRunnableBound && writers.length === 1) return writers[0];
        else if (this.bound === defaultRunnableBound) return new RunnableSequence({
          first: writers[0],
          middle: writers.slice(1, writers.length - 1),
          last: writers[writers.length - 1],
          omitSequenceTags: true
        });
        else if (writers.length > 0) return new RunnableSequence({
          first: this.bound,
          middle: writers.slice(0, writers.length - 1),
          last: writers[writers.length - 1],
          omitSequenceTags: true
        });
        else return this.bound;
      }
      join(channels) {
        if (!Array.isArray(channels)) throw new Error("channels must be a list");
        if (typeof this.channels !== "object") throw new Error("all channels must be named when using .join()");
        return new PregelNode2({
          channels: {
            ...this.channels,
            ...Object.fromEntries(channels.map((chan) => [chan, chan]))
          },
          triggers: this.triggers,
          mapper: this.mapper,
          writers: this.writers,
          bound: this.bound,
          kwargs: this.kwargs,
          config: this.config,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
      }
      pipe(coerceable) {
        if (ChannelWrite.isWriter(coerceable)) return new PregelNode2({
          channels: this.channels,
          triggers: this.triggers,
          mapper: this.mapper,
          writers: [...this.writers, coerceable],
          bound: this.bound,
          config: this.config,
          kwargs: this.kwargs,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
        else if (this.bound === defaultRunnableBound) return new PregelNode2({
          channels: this.channels,
          triggers: this.triggers,
          mapper: this.mapper,
          writers: this.writers,
          bound: _coerceToRunnable(coerceable),
          config: this.config,
          kwargs: this.kwargs,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
        else return new PregelNode2({
          channels: this.channels,
          triggers: this.triggers,
          mapper: this.mapper,
          writers: this.writers,
          bound: this.bound.pipe(coerceable),
          config: this.config,
          kwargs: this.kwargs,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js
function isRunnableSequence(x) {
  return "steps" in x && Array.isArray(x.steps);
}
function isPregelLike(x) {
  return "lg_is_pregel" in x && x.lg_is_pregel === true;
}
function findSubgraphPregel(candidate) {
  const candidates = [candidate];
  for (const candidate2 of candidates) if (isPregelLike(candidate2)) return candidate2;
  else if (isRunnableSequence(candidate2)) candidates.push(...candidate2.steps);
}
var init_subgraph = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js"() {
  }
});

// node_modules/@langchain/langgraph/dist/pregel/io.js
function readChannel(channels, chan, catchErrors = true, returnException = false) {
  try {
    return channels[chan].get();
  } catch (e) {
    if (e.name === EmptyChannelError.unminifiable_name) {
      if (returnException) return e;
      else if (catchErrors) return null;
    }
    throw e;
  }
}
function readChannels(channels, select, skipEmpty = true) {
  if (Array.isArray(select)) {
    const values = {};
    for (const k of select) try {
      values[k] = readChannel(channels, k, !skipEmpty);
    } catch (e) {
      if (e.name === EmptyChannelError.unminifiable_name) continue;
    }
    return values;
  } else return readChannel(channels, select);
}
function* mapCommand(cmd, pendingWrites) {
  if (cmd.graph === Command.PARENT) throw new InvalidUpdateError("There is no parent graph.");
  if (cmd.goto) {
    let sends;
    if (Array.isArray(cmd.goto)) sends = cmd.goto;
    else sends = [cmd.goto];
    for (const send of sends) if (_isSend(send)) yield [
      NULL_TASK_ID,
      TASKS2,
      send
    ];
    else if (typeof send === "string") yield [
      NULL_TASK_ID,
      `branch:to:${send}`,
      "__start__"
    ];
    else throw new Error(`In Command.send, expected Send or string, got ${typeof send}`);
  }
  if (cmd.resume) if (typeof cmd.resume === "object" && Object.keys(cmd.resume).length && Object.keys(cmd.resume).every(isXXH3)) for (const [tid, resume] of Object.entries(cmd.resume)) {
    const existing = pendingWrites.filter((w) => w[0] === tid && w[1] === RESUME2).map((w) => w[2]).slice(0, 1) ?? [];
    existing.push(resume);
    yield [
      tid,
      RESUME2,
      existing
    ];
  }
  else yield [
    NULL_TASK_ID,
    RESUME2,
    cmd.resume
  ];
  if (cmd.update) {
    if (typeof cmd.update !== "object" || !cmd.update) throw new Error("Expected cmd.update to be a dict mapping channel names to update values");
    if (Array.isArray(cmd.update)) for (const [k, v] of cmd.update) yield [
      NULL_TASK_ID,
      k,
      v
    ];
    else for (const [k, v] of Object.entries(cmd.update)) yield [
      NULL_TASK_ID,
      k,
      v
    ];
  }
}
function* mapInput(inputChannels, chunk) {
  if (chunk !== void 0 && chunk !== null) if (Array.isArray(inputChannels) && typeof chunk === "object" && !Array.isArray(chunk)) {
    for (const k in chunk) if (inputChannels.includes(k)) yield [k, chunk[k]];
  } else if (Array.isArray(inputChannels)) throw new Error(`Input chunk must be an object when "inputChannels" is an array`);
  else yield [inputChannels, chunk];
}
function* mapOutputValues(outputChannels, pendingWrites, channels) {
  if (Array.isArray(outputChannels)) {
    if (pendingWrites === true || pendingWrites.find(([chan, _]) => outputChannels.includes(chan))) yield readChannels(channels, outputChannels);
  } else if (pendingWrites === true || pendingWrites.some(([chan, _]) => chan === outputChannels)) yield readChannel(channels, outputChannels);
}
function* mapOutputUpdates(outputChannels, tasks, cached2) {
  const outputTasks = tasks.filter(([task2, ww]) => {
    return (task2.config === void 0 || !task2.config.tags?.includes(TAG_HIDDEN)) && ww[0][0] !== ERROR3 && ww[0][0] !== INTERRUPT2;
  });
  if (!outputTasks.length) return;
  let updated;
  if (outputTasks.some(([task2]) => task2.writes.some(([chan, _]) => chan === RETURN))) updated = outputTasks.flatMap(([task2]) => task2.writes.filter(([chan, _]) => chan === RETURN).map(([_, value]) => [task2.name, value]));
  else if (!Array.isArray(outputChannels)) updated = outputTasks.flatMap(([task2]) => task2.writes.filter(([chan, _]) => chan === outputChannels).map(([_, value]) => [task2.name, value]));
  else updated = outputTasks.flatMap(([task2]) => {
    const { writes } = task2;
    const counts = {};
    for (const [chan] of writes) if (outputChannels.includes(chan)) counts[chan] = (counts[chan] || 0) + 1;
    if (Object.values(counts).some((count) => count > 1)) return writes.filter(([chan]) => outputChannels.includes(chan)).map(([chan, value]) => [task2.name, { [chan]: value }]);
    else return [[task2.name, Object.fromEntries(writes.filter(([chan]) => outputChannels.includes(chan)))]];
  });
  const grouped = {};
  for (const [node, value] of updated) {
    if (!(node in grouped)) grouped[node] = [];
    grouped[node].push(value);
  }
  const flattened = {};
  for (const node in grouped) if (grouped[node].length === 1) {
    const [write] = grouped[node];
    flattened[node] = write;
  } else flattened[node] = grouped[node];
  if (cached2) flattened["__metadata__"] = { cached: cached2 };
  yield flattened;
}
var init_io = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/io.js"() {
    init_errors3();
    init_constants3();
    init_hash3();
  }
});

// node_modules/@langchain/langgraph/dist/pregel/utils/index.js
function getNullChannelVersion(currentVersions) {
  const startVersion = typeof currentVersions[START];
  if (startVersion === "number") return 0;
  if (startVersion === "string") return "";
  for (const key in currentVersions) {
    if (!Object.prototype.hasOwnProperty.call(currentVersions, key)) continue;
    const versionType = typeof currentVersions[key];
    if (versionType === "number") return 0;
    if (versionType === "string") return "";
    break;
  }
}
function getNewChannelVersions(previousVersions, currentVersions) {
  if (Object.keys(previousVersions).length > 0) {
    const nullVersion = getNullChannelVersion(currentVersions);
    return Object.fromEntries(Object.entries(currentVersions).filter(([k, v]) => v > (previousVersions[k] ?? nullVersion)));
  } else return currentVersions;
}
function _coerceToDict3(value, defaultKey) {
  return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
}
function patchConfigurable2(config2, patch) {
  if (config2 === null) return { configurable: patch };
  else if (config2?.configurable === void 0) return {
    ...config2,
    configurable: patch
  };
  else return {
    ...config2,
    configurable: {
      ...config2.configurable,
      ...patch
    }
  };
}
function patchCheckpointMap(config2, metadata) {
  const parents = metadata?.parents ?? {};
  if (Object.keys(parents).length > 0) return patchConfigurable2(config2, { [CONFIG_KEY_CHECKPOINT_MAP]: {
    ...parents,
    [config2.configurable?.checkpoint_ns ?? ""]: config2.configurable?.checkpoint_id
  } });
  else return config2;
}
function combineAbortSignals(...x) {
  const signals = [...new Set(x.filter(Boolean))];
  if (signals.length === 0) return {
    signal: void 0,
    dispose: void 0
  };
  if (signals.length === 1) return {
    signal: signals[0],
    dispose: void 0
  };
  const combinedController = new AbortController();
  const listener = () => {
    const reason = signals.find((s) => s.aborted)?.reason;
    combinedController.abort(reason);
    signals.forEach((s) => s.removeEventListener("abort", listener));
  };
  signals.forEach((s) => s.addEventListener("abort", listener, { once: true }));
  const hasAlreadyAbortedSignal = signals.find((s) => s.aborted);
  if (hasAlreadyAbortedSignal) combinedController.abort(hasAlreadyAbortedSignal.reason);
  return {
    signal: combinedController.signal,
    dispose: () => {
      signals.forEach((s) => s.removeEventListener("abort", listener));
    }
  };
}
var combineCallbacks;
var init_utils9 = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/utils/index.js"() {
    init_constants3();
    combineCallbacks = (callback1, callback2) => {
      if (!callback1 && !callback2) return;
      if (!callback1) return callback2;
      if (!callback2) return callback1;
      if (Array.isArray(callback1) && Array.isArray(callback2)) return [...callback1, ...callback2];
      if (Array.isArray(callback1)) return [...callback1, callback2];
      if (Array.isArray(callback2)) return [callback1, ...callback2];
      return [callback1, callback2];
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/types.js
function isCall(value) {
  return typeof value === "object" && value !== null && "__lg_type" in value && value.__lg_type === "call";
}
var Call;
var init_types6 = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/types.js"() {
    Call = class {
      func;
      name;
      input;
      retry;
      cache;
      callbacks;
      __lg_type = "call";
      constructor({ func, name, input, retry, cache: cache2, callbacks }) {
        this.func = func;
        this.name = name;
        this.input = input;
        this.retry = retry;
        this.cache = cache2;
        this.callbacks = callbacks;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/call.js
function getRunnableForFunc(name, func) {
  return new RunnableSequence({
    name,
    first: new RunnableCallable({
      func: (input) => func(...input),
      name,
      trace: false,
      recurse: false
    }),
    last: new ChannelWrite([{
      channel: RETURN,
      value: PASSTHROUGH
    }], [TAG_HIDDEN])
  });
}
function getRunnableForEntrypoint(name, func) {
  return new RunnableCallable({
    func: (input, config2) => {
      return func(input, config2);
    },
    name,
    trace: false,
    recurse: false
  });
}
var init_call = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/call.js"() {
    init_constants3();
    init_utils8();
    init_write();
    init_singletons();
    init_runnables();
  }
});

// node_modules/@langchain/langgraph/dist/pregel/algo.js
function triggersNextStep(updatedChannels, triggerToNodes) {
  if (triggerToNodes == null) return false;
  for (const chan of updatedChannels) if (triggerToNodes[chan]) return true;
  return false;
}
function maxChannelMapVersion(channelVersions) {
  let maxVersion;
  for (const chan in channelVersions) {
    if (!Object.prototype.hasOwnProperty.call(channelVersions, chan)) continue;
    if (maxVersion == null) maxVersion = channelVersions[chan];
    else maxVersion = maxChannelVersion(maxVersion, channelVersions[chan]);
  }
  return maxVersion;
}
function shouldInterrupt(checkpoint, interruptNodes, tasks) {
  const nullVersion = getNullChannelVersion(checkpoint.channel_versions);
  const seen = checkpoint.versions_seen[INTERRUPT2] ?? {};
  let anyChannelUpdated = false;
  if ((checkpoint.channel_versions[START] ?? nullVersion) > (seen[START] ?? nullVersion)) anyChannelUpdated = true;
  else for (const chan in checkpoint.channel_versions) {
    if (!Object.prototype.hasOwnProperty.call(checkpoint.channel_versions, chan)) continue;
    if (checkpoint.channel_versions[chan] > (seen[chan] ?? nullVersion)) {
      anyChannelUpdated = true;
      break;
    }
  }
  const anyTriggeredNodeInInterruptNodes = tasks.some((task2) => interruptNodes === "*" ? !task2.config?.tags?.includes(TAG_HIDDEN) : interruptNodes.includes(task2.name));
  return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;
}
function _localRead(checkpoint, channels, task2, select, fresh = false) {
  let updated = /* @__PURE__ */ new Set();
  if (!Array.isArray(select)) {
    for (const [c] of task2.writes) if (c === select) {
      updated = /* @__PURE__ */ new Set([c]);
      break;
    }
    updated = updated || /* @__PURE__ */ new Set();
  } else updated = new Set(select.filter((c) => task2.writes.some(([key, _]) => key === c)));
  let values;
  if (fresh && updated.size > 0) {
    const localChannels = Object.fromEntries(Object.entries(channels).filter(([k, _]) => updated.has(k)));
    const newCheckpoint = createCheckpoint(checkpoint, localChannels, -1);
    const newChannels = emptyChannels(localChannels, newCheckpoint);
    _applyWrites(copyCheckpoint(newCheckpoint), newChannels, [task2], void 0, void 0);
    values = readChannels({
      ...channels,
      ...newChannels
    }, select);
  } else values = readChannels(channels, select);
  return values;
}
function _localWrite(commit, processes, writes) {
  for (const [chan, value] of writes) if ([PUSH, TASKS2].includes(chan) && value != null) {
    if (!_isSend(value)) throw new InvalidUpdateError(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(value)}`);
    if (!(value.node in processes)) throw new InvalidUpdateError(`Invalid node name "${value.node}" in Send packet`);
  }
  commit(writes);
}
function _applyWrites(checkpoint, channels, tasks, getNextVersion, triggerToNodes) {
  tasks.sort((a, b) => {
    const aPath = a.path?.slice(0, 3) || [];
    const bPath = b.path?.slice(0, 3) || [];
    for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {
      if (aPath[i] < bPath[i]) return -1;
      if (aPath[i] > bPath[i]) return 1;
    }
    return aPath.length - bPath.length;
  });
  const bumpStep = tasks.some((task2) => task2.triggers.length > 0);
  const onlyChannels = getOnlyChannels(channels);
  for (const task2 of tasks) {
    checkpoint.versions_seen[task2.name] ??= {};
    for (const chan of task2.triggers) if (chan in checkpoint.channel_versions) checkpoint.versions_seen[task2.name][chan] = checkpoint.channel_versions[chan];
  }
  let maxVersion = maxChannelMapVersion(checkpoint.channel_versions);
  const channelsToConsume = new Set(tasks.flatMap((task2) => task2.triggers).filter((chan) => !RESERVED.includes(chan)));
  let usedNewVersion = false;
  for (const chan of channelsToConsume) if (chan in onlyChannels && onlyChannels[chan].consume()) {
    if (getNextVersion !== void 0) {
      checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
      usedNewVersion = true;
    }
  }
  const pendingWritesByChannel = {};
  for (const task2 of tasks) for (const [chan, val] of task2.writes) if (IGNORE.has(chan)) {
  } else if (chan in onlyChannels) {
    pendingWritesByChannel[chan] ??= [];
    pendingWritesByChannel[chan].push(val);
  }
  if (maxVersion != null && getNextVersion != null) maxVersion = usedNewVersion ? getNextVersion(maxVersion) : maxVersion;
  const updatedChannels = /* @__PURE__ */ new Set();
  for (const [chan, vals] of Object.entries(pendingWritesByChannel)) if (chan in onlyChannels) {
    const channel = onlyChannels[chan];
    let updated;
    try {
      updated = channel.update(vals);
    } catch (e) {
      if (e.name === InvalidUpdateError.unminifiable_name) {
        const wrappedError = new InvalidUpdateError(`Invalid update for channel "${chan}" with values ${JSON.stringify(vals)}: ${e.message}`);
        wrappedError.lc_error_code = e.lc_error_code;
        throw wrappedError;
      } else throw e;
    }
    if (updated && getNextVersion !== void 0) {
      checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
      if (channel.isAvailable()) updatedChannels.add(chan);
    }
  }
  if (bumpStep) for (const chan in onlyChannels) {
    if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;
    const channel = onlyChannels[chan];
    if (channel.isAvailable() && !updatedChannels.has(chan)) {
      if (channel.update([]) && getNextVersion !== void 0) {
        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
        if (channel.isAvailable()) updatedChannels.add(chan);
      }
    }
  }
  if (bumpStep && !triggersNextStep(updatedChannels, triggerToNodes)) for (const chan in onlyChannels) {
    if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;
    const channel = onlyChannels[chan];
    if (channel.finish() && getNextVersion !== void 0) {
      checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
      if (channel.isAvailable()) updatedChannels.add(chan);
    }
  }
  return updatedChannels;
}
function* candidateNodes(checkpoint, processes, extra) {
  if (extra.updatedChannels != null && extra.triggerToNodes != null) {
    const triggeredNodes = /* @__PURE__ */ new Set();
    for (const channel of extra.updatedChannels) {
      const nodeIds = extra.triggerToNodes[channel];
      for (const id of nodeIds ?? []) triggeredNodes.add(id);
    }
    yield* [...triggeredNodes].sort();
    return;
  }
  if ((() => {
    for (const chan in checkpoint.channel_versions) if (checkpoint.channel_versions[chan] !== null) return false;
    return true;
  })()) return;
  for (const name in processes) {
    if (!Object.prototype.hasOwnProperty.call(processes, name)) continue;
    yield name;
  }
}
function _prepareNextTasks(checkpoint, pendingWrites, processes, channels, config2, forExecution, extra) {
  const tasks = {};
  const tasksChannel = channels[TASKS2];
  if (tasksChannel?.isAvailable()) {
    const len = tasksChannel.get().length;
    for (let i = 0; i < len; i += 1) {
      const task2 = _prepareSingleTask([PUSH, i], checkpoint, pendingWrites, processes, channels, config2, forExecution, extra);
      if (task2 !== void 0) tasks[task2.id] = task2;
    }
  }
  for (const name of candidateNodes(checkpoint, processes, extra)) {
    const task2 = _prepareSingleTask([PULL, name], checkpoint, pendingWrites, processes, channels, config2, forExecution, extra);
    if (task2 !== void 0) tasks[task2.id] = task2;
  }
  return tasks;
}
function _prepareSingleTask(taskPath, checkpoint, pendingWrites, processes, channels, config2, forExecution, extra) {
  const { step, checkpointer, manager } = extra;
  const configurable = config2.configurable ?? {};
  const parentNamespace = configurable.checkpoint_ns ?? "";
  if (taskPath[0] === PUSH && isCall(taskPath[taskPath.length - 1])) {
    const call3 = taskPath[taskPath.length - 1];
    const proc = getRunnableForFunc(call3.name, call3.func);
    const triggers = [PUSH];
    const checkpointNamespace = parentNamespace === "" ? call3.name : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${call3.name}`;
    const id = uuid5(JSON.stringify([
      checkpointNamespace,
      step.toString(),
      call3.name,
      PUSH,
      taskPath[1],
      taskPath[2]
    ]), checkpoint.id);
    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${id}`;
    const outputTaskPath = [...taskPath.slice(0, 3), true];
    const metadata = {
      langgraph_step: step,
      langgraph_node: call3.name,
      langgraph_triggers: triggers,
      langgraph_path: outputTaskPath,
      langgraph_checkpoint_ns: taskCheckpointNamespace
    };
    if (forExecution) {
      const writes = [];
      return {
        name: call3.name,
        input: call3.input,
        proc,
        writes,
        config: patchConfig(mergeConfigs(config2, {
          metadata,
          store: extra.store ?? config2.store
        }), {
          runName: call3.name,
          callbacks: manager?.getChild(`graph:step:${step}`),
          configurable: {
            [CONFIG_KEY_TASK_ID]: id,
            [CONFIG_KEY_SEND]: (writes_) => _localWrite((items) => writes.push(...items), processes, writes_),
            [CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, {
              name: call3.name,
              writes,
              triggers,
              path: outputTaskPath
            }, select_, fresh_),
            [CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],
            [CONFIG_KEY_CHECKPOINT_MAP]: {
              ...configurable[CONFIG_KEY_CHECKPOINT_MAP],
              [parentNamespace]: checkpoint.id
            },
            [CONFIG_KEY_SCRATCHPAD]: _scratchpad({
              pendingWrites: pendingWrites ?? [],
              taskId: id,
              currentTaskInput: call3.input,
              resumeMap: config2.configurable?.[CONFIG_KEY_RESUME_MAP],
              namespaceHash: XXH3(taskCheckpointNamespace)
            }),
            [CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[PREVIOUS],
            checkpoint_id: void 0,
            checkpoint_ns: taskCheckpointNamespace
          }
        }),
        triggers,
        retry_policy: call3.retry,
        cache_key: call3.cache ? {
          key: XXH3((call3.cache.keyFunc ?? JSON.stringify)([call3.input])),
          ns: [CACHE_NS_WRITES, call3.name ?? "__dynamic__"],
          ttl: call3.cache.ttl
        } : void 0,
        id,
        path: outputTaskPath,
        writers: []
      };
    } else return {
      id,
      name: call3.name,
      interrupts: [],
      path: outputTaskPath
    };
  } else if (taskPath[0] === PUSH) {
    const index2 = typeof taskPath[1] === "number" ? taskPath[1] : parseInt(taskPath[1], 10);
    if (!channels[TASKS2]?.isAvailable()) return;
    const sends = channels[TASKS2].get();
    if (index2 < 0 || index2 >= sends.length) return;
    const packet = _isSendInterface(sends[index2]) && !_isSend(sends[index2]) ? new Send(sends[index2].node, sends[index2].args) : sends[index2];
    if (!_isSendInterface(packet)) {
      console.warn(`Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`);
      return;
    }
    if (!(packet.node in processes)) {
      console.warn(`Ignoring unknown node name ${packet.node} in pending sends.`);
      return;
    }
    const triggers = [PUSH];
    const checkpointNamespace = parentNamespace === "" ? packet.node : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;
    const taskId = uuid5(JSON.stringify([
      checkpointNamespace,
      step.toString(),
      packet.node,
      PUSH,
      index2.toString()
    ]), checkpoint.id);
    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;
    let metadata = {
      langgraph_step: step,
      langgraph_node: packet.node,
      langgraph_triggers: triggers,
      langgraph_path: taskPath.slice(0, 3),
      langgraph_checkpoint_ns: taskCheckpointNamespace
    };
    if (forExecution) {
      const proc = processes[packet.node];
      const node = proc.getNode();
      if (node !== void 0) {
        if (proc.metadata !== void 0) metadata = {
          ...metadata,
          ...proc.metadata
        };
        const writes = [];
        return {
          name: packet.node,
          input: packet.args,
          proc: node,
          subgraphs: proc.subgraphs,
          writes,
          config: patchConfig(mergeConfigs(config2, {
            metadata,
            tags: proc.tags,
            store: extra.store ?? config2.store
          }), {
            runName: packet.node,
            callbacks: manager?.getChild(`graph:step:${step}`),
            configurable: {
              [CONFIG_KEY_TASK_ID]: taskId,
              [CONFIG_KEY_SEND]: (writes_) => _localWrite((items) => writes.push(...items), processes, writes_),
              [CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, {
                name: packet.node,
                writes,
                triggers,
                path: taskPath
              }, select_, fresh_),
              [CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],
              [CONFIG_KEY_CHECKPOINT_MAP]: {
                ...configurable[CONFIG_KEY_CHECKPOINT_MAP],
                [parentNamespace]: checkpoint.id
              },
              [CONFIG_KEY_SCRATCHPAD]: _scratchpad({
                pendingWrites: pendingWrites ?? [],
                taskId,
                currentTaskInput: packet.args,
                resumeMap: config2.configurable?.[CONFIG_KEY_RESUME_MAP],
                namespaceHash: XXH3(taskCheckpointNamespace)
              }),
              [CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[PREVIOUS],
              checkpoint_id: void 0,
              checkpoint_ns: taskCheckpointNamespace
            }
          }),
          triggers,
          retry_policy: proc.retryPolicy,
          cache_key: proc.cachePolicy ? {
            key: XXH3((proc.cachePolicy.keyFunc ?? JSON.stringify)([packet.args])),
            ns: [
              CACHE_NS_WRITES,
              proc.name ?? "__dynamic__",
              packet.node
            ],
            ttl: proc.cachePolicy.ttl
          } : void 0,
          id: taskId,
          path: taskPath,
          writers: proc.getWriters()
        };
      }
    } else return {
      id: taskId,
      name: packet.node,
      interrupts: [],
      path: taskPath
    };
  } else if (taskPath[0] === PULL) {
    const name = taskPath[1].toString();
    const proc = processes[name];
    if (proc === void 0) return;
    if (pendingWrites?.length) {
      const checkpointNamespace = parentNamespace === "" ? name : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;
      const taskId = uuid5(JSON.stringify([
        checkpointNamespace,
        step.toString(),
        name,
        PULL,
        name
      ]), checkpoint.id);
      if (pendingWrites.some((w) => w[0] === taskId && w[1] !== ERROR3)) return;
    }
    const nullVersion = getNullChannelVersion(checkpoint.channel_versions);
    if (nullVersion === void 0) return;
    const seen = checkpoint.versions_seen[name] ?? {};
    const trigger = proc.triggers.find((chan) => {
      if (!channels[chan].isAvailable()) return false;
      return (checkpoint.channel_versions[chan] ?? nullVersion) > (seen[chan] ?? nullVersion);
    });
    if (trigger !== void 0) {
      const val = _procInput(proc, channels, forExecution);
      if (val === void 0) return;
      const checkpointNamespace = parentNamespace === "" ? name : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;
      const taskId = uuid5(JSON.stringify([
        checkpointNamespace,
        step.toString(),
        name,
        PULL,
        [trigger]
      ]), checkpoint.id);
      const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;
      let metadata = {
        langgraph_step: step,
        langgraph_node: name,
        langgraph_triggers: [trigger],
        langgraph_path: taskPath,
        langgraph_checkpoint_ns: taskCheckpointNamespace
      };
      if (forExecution) {
        const node = proc.getNode();
        if (node !== void 0) {
          if (proc.metadata !== void 0) metadata = {
            ...metadata,
            ...proc.metadata
          };
          const writes = [];
          return {
            name,
            input: val,
            proc: node,
            subgraphs: proc.subgraphs,
            writes,
            config: patchConfig(mergeConfigs(config2, {
              metadata,
              tags: proc.tags,
              store: extra.store ?? config2.store
            }), {
              runName: name,
              callbacks: manager?.getChild(`graph:step:${step}`),
              configurable: {
                [CONFIG_KEY_TASK_ID]: taskId,
                [CONFIG_KEY_SEND]: (writes_) => _localWrite((items) => {
                  writes.push(...items);
                }, processes, writes_),
                [CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, {
                  name,
                  writes,
                  triggers: [trigger],
                  path: taskPath
                }, select_, fresh_),
                [CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],
                [CONFIG_KEY_CHECKPOINT_MAP]: {
                  ...configurable[CONFIG_KEY_CHECKPOINT_MAP],
                  [parentNamespace]: checkpoint.id
                },
                [CONFIG_KEY_SCRATCHPAD]: _scratchpad({
                  pendingWrites: pendingWrites ?? [],
                  taskId,
                  currentTaskInput: val,
                  resumeMap: config2.configurable?.[CONFIG_KEY_RESUME_MAP],
                  namespaceHash: XXH3(taskCheckpointNamespace)
                }),
                [CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[PREVIOUS],
                checkpoint_id: void 0,
                checkpoint_ns: taskCheckpointNamespace
              }
            }),
            triggers: [trigger],
            retry_policy: proc.retryPolicy,
            cache_key: proc.cachePolicy ? {
              key: XXH3((proc.cachePolicy.keyFunc ?? JSON.stringify)([val])),
              ns: [
                CACHE_NS_WRITES,
                proc.name ?? "__dynamic__",
                name
              ],
              ttl: proc.cachePolicy.ttl
            } : void 0,
            id: taskId,
            path: taskPath,
            writers: proc.getWriters()
          };
        }
      } else return {
        id: taskId,
        name,
        interrupts: [],
        path: taskPath
      };
    }
  }
}
function _procInput(proc, channels, forExecution) {
  let val;
  if (typeof proc.channels === "object" && !Array.isArray(proc.channels)) {
    val = {};
    for (const [k, chan] of Object.entries(proc.channels)) if (proc.triggers.includes(chan)) try {
      val[k] = readChannel(channels, chan, false);
    } catch (e) {
      if (e.name === EmptyChannelError.unminifiable_name) return;
      else throw e;
    }
    else if (chan in channels) try {
      val[k] = readChannel(channels, chan, false);
    } catch (e) {
      if (e.name === EmptyChannelError.unminifiable_name) continue;
      else throw e;
    }
  } else if (Array.isArray(proc.channels)) {
    let successfulRead = false;
    for (const chan of proc.channels) try {
      val = readChannel(channels, chan, false);
      successfulRead = true;
      break;
    } catch (e) {
      if (e.name === EmptyChannelError.unminifiable_name) continue;
      else throw e;
    }
    if (!successfulRead) return;
  } else throw new Error(`Invalid channels type, expected list or dict, got ${proc.channels}`);
  if (forExecution && proc.mapper !== void 0) val = proc.mapper(val);
  return val;
}
function sanitizeUntrackedValuesInSend(packet, channels) {
  if (typeof packet.args !== "object" || packet.args === null) return packet;
  const sanitizedArg = {};
  for (const [key, value] of Object.entries(packet.args)) {
    const channel = channels[key];
    if (!channel || channel.lc_graph_name !== "UntrackedValue") sanitizedArg[key] = value;
  }
  return new Send(packet.node, sanitizedArg);
}
function _scratchpad({ pendingWrites, taskId, currentTaskInput, resumeMap, namespaceHash }) {
  const nullResume = pendingWrites.find(([writeTaskId, chan]) => writeTaskId === NULL_TASK_ID && chan === RESUME2)?.[2];
  const scratchpad = {
    callCounter: 0,
    interruptCounter: -1,
    resume: (() => {
      const result = pendingWrites.filter(([writeTaskId, chan]) => writeTaskId === taskId && chan === RESUME2).flatMap(([_writeTaskId, _chan, resume]) => resume);
      if (resumeMap != null && namespaceHash in resumeMap) {
        const mappedResume = resumeMap[namespaceHash];
        result.push(mappedResume);
      }
      return result;
    })(),
    nullResume,
    subgraphCounter: 0,
    currentTaskInput,
    consumeNullResume: () => {
      if (scratchpad.nullResume) {
        delete scratchpad.nullResume;
        pendingWrites.splice(pendingWrites.findIndex(([writeTaskId, chan]) => writeTaskId === NULL_TASK_ID && chan === RESUME2), 1);
        return nullResume;
      }
    }
  };
  return scratchpad;
}
var increment, IGNORE;
var init_algo = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/algo.js"() {
    init_errors3();
    init_base15();
    init_constants3();
    init_hash3();
    init_io();
    init_types6();
    init_utils9();
    init_call();
    init_dist3();
    init_runnables();
    increment = (current) => {
      return current !== void 0 ? current + 1 : 1;
    };
    IGNORE = /* @__PURE__ */ new Set([
      NO_WRITES,
      PUSH,
      RESUME2,
      INTERRUPT2,
      RETURN,
      ERROR3
    ]);
  }
});

// node_modules/@langchain/langgraph/dist/pregel/debug.js
function* mapDebugTasks(tasks) {
  for (const { id, name, input, config: config2, triggers, writes } of tasks) {
    if (config2?.tags?.includes(TAG_HIDDEN)) continue;
    yield {
      id,
      name,
      input,
      triggers,
      interrupts: writes.filter(([writeId, n2]) => {
        return writeId === id && n2 === INTERRUPT2;
      }).map(([, v]) => {
        return v;
      })
    };
  }
}
function isMultipleChannelWrite(value) {
  if (typeof value !== "object" || value === null) return false;
  return "$writes" in value && Array.isArray(value.$writes);
}
function mapTaskResultWrites(writes) {
  const result = {};
  for (const [channel, value] of writes) {
    const strChannel = String(channel);
    if (strChannel in result) {
      const channelWrites = isMultipleChannelWrite(result[strChannel]) ? result[strChannel].$writes : [result[strChannel]];
      channelWrites.push(value);
      result[strChannel] = { $writes: channelWrites };
    } else result[strChannel] = value;
  }
  return result;
}
function* mapDebugTaskResults(tasks, streamChannels) {
  for (const [{ id, name, config: config2 }, writes] of tasks) {
    if (config2?.tags?.includes(TAG_HIDDEN)) continue;
    yield {
      id,
      name,
      result: mapTaskResultWrites(writes.filter(([channel]) => {
        return Array.isArray(streamChannels) ? streamChannels.includes(channel) : channel === streamChannels;
      })),
      interrupts: writes.filter((w) => w[0] === INTERRUPT2).map((w) => w[1])
    };
  }
}
function* mapDebugCheckpoint(config2, channels, streamChannels, metadata, tasks, pendingWrites, parentConfig, outputKeys) {
  function formatConfig(config3) {
    const pyConfig = {};
    if (config3.callbacks != null) pyConfig.callbacks = config3.callbacks;
    if (config3.configurable != null) pyConfig.configurable = config3.configurable;
    if (config3.maxConcurrency != null) pyConfig.max_concurrency = config3.maxConcurrency;
    if (config3.metadata != null) pyConfig.metadata = config3.metadata;
    if (config3.recursionLimit != null) pyConfig.recursion_limit = config3.recursionLimit;
    if (config3.runId != null) pyConfig.run_id = config3.runId;
    if (config3.runName != null) pyConfig.run_name = config3.runName;
    if (config3.tags != null) pyConfig.tags = config3.tags;
    return pyConfig;
  }
  const parentNs = config2.configurable?.checkpoint_ns;
  const taskStates = {};
  for (const task2 of tasks) {
    if (!(task2.subgraphs?.length ? task2.subgraphs : [task2.proc]).find(findSubgraphPregel)) continue;
    let taskNs = `${task2.name}:${task2.id}`;
    if (parentNs) taskNs = `${parentNs}|${taskNs}`;
    taskStates[task2.id] = { configurable: {
      thread_id: config2.configurable?.thread_id,
      checkpoint_ns: taskNs
    } };
  }
  yield {
    config: formatConfig(config2),
    values: readChannels(channels, streamChannels),
    metadata,
    next: tasks.map((task2) => task2.name),
    tasks: tasksWithWrites(tasks, pendingWrites, taskStates, outputKeys),
    parentConfig: parentConfig ? formatConfig(parentConfig) : void 0
  };
}
function tasksWithWrites(tasks, pendingWrites, states, outputKeys) {
  return tasks.map((task2) => {
    const error40 = pendingWrites.find(([id, n2]) => id === task2.id && n2 === ERROR3)?.[2];
    const interrupts = pendingWrites.filter(([id, n2]) => id === task2.id && n2 === INTERRUPT2).map(([, , v]) => v);
    const result = (() => {
      if (error40 || interrupts.length || !pendingWrites.length) return void 0;
      const idx = pendingWrites.findIndex(([tid, n2]) => tid === task2.id && n2 === RETURN);
      if (idx >= 0) return pendingWrites[idx][2];
      if (typeof outputKeys === "string") return pendingWrites.find(([tid, n2]) => tid === task2.id && n2 === outputKeys)?.[2];
      if (Array.isArray(outputKeys)) {
        const results = pendingWrites.filter(([tid, n2]) => tid === task2.id && outputKeys.includes(n2)).map(([, n2, v]) => [n2, v]);
        if (!results.length) return void 0;
        return mapTaskResultWrites(results);
      }
    })();
    if (error40) return {
      id: task2.id,
      name: task2.name,
      path: task2.path,
      error: error40,
      interrupts,
      result
    };
    const taskState = states?.[task2.id];
    return {
      id: task2.id,
      name: task2.name,
      path: task2.path,
      interrupts,
      ...taskState !== void 0 ? { state: taskState } : {},
      result
    };
  });
}
function printStepCheckpoint(step, channels, whitelist) {
  console.log([
    `${wrap2(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,
    `\x1B[1m State at the end of step ${step}:\x1B[0m
`,
    JSON.stringify(readChannels(channels, whitelist), null, 2)
  ].join(""));
}
function printStepTasks(step, nextTasks) {
  const nTasks = nextTasks.length;
  console.log([
    `${wrap2(COLORS_MAP.blue, `[${step}:tasks]`)}`,
    `\x1B[1m Starting step ${step} with ${nTasks} task${nTasks === 1 ? "" : "s"}:\x1B[0m
`,
    nextTasks.map((task2) => `- ${wrap2(COLORS_MAP.green, String(task2.name))} -> ${JSON.stringify(task2.input, null, 2)}`).join("\n")
  ].join(""));
}
function printStepWrites(step, writes, whitelist) {
  const byChannel = {};
  for (const [channel, value] of writes) if (whitelist.includes(channel)) {
    if (!byChannel[channel]) byChannel[channel] = [];
    byChannel[channel].push(value);
  }
  console.log([
    `${wrap2(COLORS_MAP.blue, `[${step}:writes]`)}`,
    `\x1B[1m Finished step ${step} with writes to ${Object.keys(byChannel).length} channel${Object.keys(byChannel).length !== 1 ? "s" : ""}:\x1B[0m
`,
    Object.entries(byChannel).map(([name, vals]) => `- ${wrap2(COLORS_MAP.yellow, name)} -> ${vals.map((v) => JSON.stringify(v)).join(", ")}`).join("\n")
  ].join(""));
}
var COLORS_MAP, wrap2;
var init_debug = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/debug.js"() {
    init_constants3();
    init_io();
    init_subgraph();
    COLORS_MAP = {
      blue: {
        start: "\x1B[34m",
        end: "\x1B[0m"
      },
      green: {
        start: "\x1B[32m",
        end: "\x1B[0m"
      },
      yellow: {
        start: "\x1B[33;1m",
        end: "\x1B[0m"
      }
    };
    wrap2 = (color2, text2) => `${color2.start}${text2}${color2.end}`;
  }
});

// node_modules/@langchain/langgraph/dist/pregel/stream.js
function _stringifyAsDict(obj) {
  return JSON.stringify(obj, function(key, value) {
    const rawValue2 = this[key];
    if (rawValue2 != null && typeof rawValue2 === "object" && "toDict" in rawValue2 && typeof rawValue2.toDict === "function") {
      const { type, data } = rawValue2.toDict();
      return {
        ...data,
        type
      };
    }
    return value;
  });
}
function _serializeError(error40) {
  if (error40 instanceof Error) return {
    error: error40.name,
    message: error40.message
  };
  return {
    error: "Error",
    message: JSON.stringify(error40)
  };
}
function _isRunnableConfig(config2) {
  if (typeof config2 !== "object" || config2 == null) return false;
  return "configurable" in config2 && typeof config2.configurable === "object" && config2.configurable != null;
}
function _extractCheckpointFromConfig(config2) {
  if (!_isRunnableConfig(config2) || !config2.configurable.thread_id) return null;
  return {
    thread_id: config2.configurable.thread_id,
    checkpoint_ns: config2.configurable.checkpoint_ns || "",
    checkpoint_id: config2.configurable.checkpoint_id || null,
    checkpoint_map: config2.configurable.checkpoint_map || null
  };
}
function _serializeConfig(config2) {
  if (_isRunnableConfig(config2)) {
    const configurable = Object.fromEntries(Object.entries(config2.configurable).filter(([key]) => !key.startsWith("__")));
    const newConfig = {
      ...config2,
      configurable
    };
    delete newConfig.callbacks;
    return newConfig;
  }
  return config2;
}
function _serializeCheckpoint(payload) {
  const result = {
    ...payload,
    checkpoint: _extractCheckpointFromConfig(payload.config),
    parent_checkpoint: _extractCheckpointFromConfig(payload.parentConfig),
    config: _serializeConfig(payload.config),
    parent_config: _serializeConfig(payload.parentConfig),
    tasks: payload.tasks.map((task2) => {
      if (_isRunnableConfig(task2.state)) {
        const checkpoint = _extractCheckpointFromConfig(task2.state);
        if (checkpoint != null) {
          const cloneTask = {
            ...task2,
            checkpoint
          };
          delete cloneTask.state;
          return cloneTask;
        }
      }
      return task2;
    })
  };
  delete result.parentConfig;
  return result;
}
function toEventStream(stream) {
  const encoder2 = new TextEncoder();
  return new ReadableStream({ async start(controller) {
    const enqueueChunk = (sse) => {
      controller.enqueue(encoder2.encode(`event: ${sse.event}
data: ${_stringifyAsDict(sse.data)}

`));
    };
    try {
      for await (const payload of stream) {
        const [ns, mode, chunk] = payload;
        let data = chunk;
        if (mode === "debug") {
          const debugChunk = chunk;
          if (debugChunk.type === "checkpoint") data = {
            ...debugChunk,
            payload: _serializeCheckpoint(debugChunk.payload)
          };
        }
        if (mode === "checkpoints") data = _serializeCheckpoint(chunk);
        enqueueChunk({
          event: ns?.length ? `${mode}|${ns.join("|")}` : mode,
          data
        });
      }
    } catch (error40) {
      enqueueChunk({
        event: "error",
        data: _serializeError(error40)
      });
    }
    controller.close();
  } });
}
var IterableReadableStreamWithAbortSignal, IterableReadableWritableStream;
var init_stream3 = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/stream.js"() {
    init_stream();
    IterableReadableStreamWithAbortSignal = class extends IterableReadableStream {
      _abortController;
      _innerReader;
      /**
      * @param readableStream - The stream to wrap.
      * @param abortController - The abort controller to use. Optional. One will be created if not provided.
      */
      constructor(readableStream, abortController) {
        const reader = readableStream.getReader();
        const ac = abortController ?? new AbortController();
        super({ start(controller) {
          return pump();
          function pump() {
            return reader.read().then(({ done, value }) => {
              if (done) {
                controller.close();
                return;
              }
              controller.enqueue(value);
              return pump();
            });
          }
        } });
        this._abortController = ac;
        this._innerReader = reader;
      }
      /**
      * Aborts the stream, abandoning any pending operations in progress. Calling this triggers an
      * {@link AbortSignal} that is propagated to the tasks that are producing the data for this stream.
      * @param reason - The reason for aborting the stream. Optional.
      */
      async cancel(reason) {
        this._abortController.abort(reason);
        this._innerReader.releaseLock();
      }
      /**
      * The {@link AbortSignal} for the stream. Aborted when {@link cancel} is called.
      */
      get signal() {
        return this._abortController.signal;
      }
    };
    IterableReadableWritableStream = class extends IterableReadableStream {
      modes;
      controller;
      passthroughFn;
      _closed = false;
      get closed() {
        return this._closed;
      }
      constructor(params) {
        let streamControllerPromiseResolver;
        const streamControllerPromise = new Promise((resolve) => {
          streamControllerPromiseResolver = resolve;
        });
        super({ start: (controller) => {
          streamControllerPromiseResolver(controller);
        } });
        streamControllerPromise.then((controller) => {
          this.controller = controller;
        });
        this.passthroughFn = params.passthroughFn;
        this.modes = params.modes;
      }
      push(chunk) {
        this.passthroughFn?.(chunk);
        this.controller.enqueue(chunk);
      }
      close() {
        try {
          this.controller.close();
        } catch (e) {
        } finally {
          this._closed = true;
        }
      }
      error(e) {
        this.controller.error(e);
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/loop.js
function createDuplexStream(...streams) {
  return new IterableReadableWritableStream({
    passthroughFn: (value) => {
      for (const stream of streams) if (stream.modes.has(value[1])) stream.push(value);
    },
    modes: new Set(streams.flatMap((s) => Array.from(s.modes)))
  });
}
var INPUT_DONE, INPUT_RESUMING, DEFAULT_LOOP_LIMIT, AsyncBatchedCache, PregelLoop;
var init_loop = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/loop.js"() {
    init_errors3();
    init_base15();
    init_constants3();
    init_utils8();
    init_hash3();
    init_io();
    init_utils9();
    init_algo();
    init_debug();
    init_stream3();
    init_dist3();
    INPUT_DONE = Symbol.for("INPUT_DONE");
    INPUT_RESUMING = Symbol.for("INPUT_RESUMING");
    DEFAULT_LOOP_LIMIT = 25;
    AsyncBatchedCache = class extends BaseCache2 {
      cache;
      queue = Promise.resolve();
      constructor(cache2) {
        super();
        this.cache = cache2;
      }
      async get(keys) {
        return this.enqueueOperation("get", keys);
      }
      async set(pairs) {
        return this.enqueueOperation("set", pairs);
      }
      async clear(namespaces) {
        return this.enqueueOperation("clear", namespaces);
      }
      async stop() {
        await this.queue;
      }
      enqueueOperation(type, ...args) {
        const newPromise = this.queue.then(() => {
          return this.cache[type](...args);
        });
        this.queue = newPromise.then(() => void 0, () => void 0);
        return newPromise;
      }
    };
    PregelLoop = class PregelLoop2 {
      input;
      output;
      config;
      checkpointer;
      checkpointerGetNextVersion;
      channels;
      checkpoint;
      checkpointIdSaved;
      checkpointConfig;
      checkpointMetadata;
      checkpointNamespace;
      checkpointPendingWrites = [];
      checkpointPreviousVersions;
      step;
      stop;
      durability;
      outputKeys;
      streamKeys;
      nodes;
      skipDoneTasks;
      prevCheckpointConfig;
      updatedChannels;
      status = "pending";
      tasks = {};
      stream;
      checkpointerPromises = [];
      isNested;
      _checkpointerChainedPromise = Promise.resolve();
      store;
      cache;
      manager;
      interruptAfter;
      interruptBefore;
      toInterrupt = [];
      debug = false;
      triggerToNodes;
      get isResuming() {
        let hasChannelVersions = false;
        if (START in this.checkpoint.channel_versions) hasChannelVersions = true;
        else for (const chan in this.checkpoint.channel_versions) if (Object.prototype.hasOwnProperty.call(this.checkpoint.channel_versions, chan)) {
          hasChannelVersions = true;
          break;
        }
        const configIsResuming = this.config.configurable?.[CONFIG_KEY_RESUMING] !== void 0 && this.config.configurable?.[CONFIG_KEY_RESUMING];
        const inputIsNullOrUndefined = this.input === null || this.input === void 0;
        const inputIsCommandResuming = isCommand(this.input) && this.input.resume != null;
        const inputIsResuming = this.input === INPUT_RESUMING;
        const runIdMatchesPrevious = !this.isNested && this.config.metadata?.run_id !== void 0 && this.checkpointMetadata?.run_id !== void 0 && this.config.metadata.run_id === this.checkpointMetadata?.run_id;
        return hasChannelVersions && (configIsResuming || inputIsNullOrUndefined || inputIsCommandResuming || inputIsResuming || runIdMatchesPrevious);
      }
      constructor(params) {
        this.input = params.input;
        this.checkpointer = params.checkpointer;
        if (this.checkpointer !== void 0) this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(this.checkpointer);
        else this.checkpointerGetNextVersion = increment;
        this.checkpoint = params.checkpoint;
        this.checkpointMetadata = params.checkpointMetadata;
        this.checkpointPreviousVersions = params.checkpointPreviousVersions;
        this.channels = params.channels;
        this.checkpointPendingWrites = params.checkpointPendingWrites;
        this.step = params.step;
        this.stop = params.stop;
        this.config = params.config;
        this.checkpointConfig = params.checkpointConfig;
        this.isNested = params.isNested;
        this.manager = params.manager;
        this.outputKeys = params.outputKeys;
        this.streamKeys = params.streamKeys;
        this.nodes = params.nodes;
        this.skipDoneTasks = params.skipDoneTasks;
        this.store = params.store;
        this.cache = params.cache ? new AsyncBatchedCache(params.cache) : void 0;
        this.stream = params.stream;
        this.checkpointNamespace = params.checkpointNamespace;
        this.prevCheckpointConfig = params.prevCheckpointConfig;
        this.interruptAfter = params.interruptAfter;
        this.interruptBefore = params.interruptBefore;
        this.durability = params.durability;
        this.debug = params.debug;
        this.triggerToNodes = params.triggerToNodes;
      }
      static async initialize(params) {
        let { config: config2, stream } = params;
        if (stream !== void 0 && config2.configurable?.[CONFIG_KEY_STREAM] !== void 0) stream = createDuplexStream(stream, config2.configurable[CONFIG_KEY_STREAM]);
        const skipDoneTasks = config2.configurable ? !("checkpoint_id" in config2.configurable) : true;
        const scratchpad = config2.configurable?.[CONFIG_KEY_SCRATCHPAD];
        if (config2.configurable && scratchpad) {
          if (scratchpad.subgraphCounter > 0) config2 = patchConfigurable2(config2, { [CONFIG_KEY_CHECKPOINT_NS]: [config2.configurable[CONFIG_KEY_CHECKPOINT_NS], scratchpad.subgraphCounter.toString()].join(CHECKPOINT_NAMESPACE_SEPARATOR) });
          scratchpad.subgraphCounter += 1;
        }
        const isNested = CONFIG_KEY_READ in (config2.configurable ?? {});
        if (!isNested && config2.configurable?.checkpoint_ns !== void 0 && config2.configurable?.checkpoint_ns !== "") config2 = patchConfigurable2(config2, {
          checkpoint_ns: "",
          checkpoint_id: void 0
        });
        let checkpointConfig = config2;
        if (config2.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] !== void 0 && config2.configurable?.[CONFIG_KEY_CHECKPOINT_MAP]?.[config2.configurable?.checkpoint_ns]) checkpointConfig = patchConfigurable2(config2, { checkpoint_id: config2.configurable[CONFIG_KEY_CHECKPOINT_MAP][config2.configurable?.checkpoint_ns] });
        const checkpointNamespace = config2.configurable?.checkpoint_ns?.split(CHECKPOINT_NAMESPACE_SEPARATOR) ?? [];
        const saved = await params.checkpointer?.getTuple(checkpointConfig) ?? {
          config: config2,
          checkpoint: emptyCheckpoint(),
          metadata: {
            source: "input",
            step: -2,
            parents: {}
          },
          pendingWrites: []
        };
        checkpointConfig = {
          ...config2,
          ...saved.config,
          configurable: {
            checkpoint_ns: "",
            ...config2.configurable,
            ...saved.config.configurable
          }
        };
        const prevCheckpointConfig = saved.parentConfig;
        const checkpoint = copyCheckpoint(saved.checkpoint);
        const checkpointMetadata = { ...saved.metadata };
        const checkpointPendingWrites = saved.pendingWrites ?? [];
        const channels = emptyChannels(params.channelSpecs, checkpoint);
        const step = (checkpointMetadata.step ?? 0) + 1;
        const stop = step + (config2.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;
        const checkpointPreviousVersions = { ...checkpoint.channel_versions };
        const store = params.store ? new AsyncBatchedStore(params.store) : void 0;
        if (store) await store.start();
        return new PregelLoop2({
          input: params.input,
          config: config2,
          checkpointer: params.checkpointer,
          checkpoint,
          checkpointMetadata,
          checkpointConfig,
          prevCheckpointConfig,
          checkpointNamespace,
          channels,
          isNested,
          manager: params.manager,
          skipDoneTasks,
          step,
          stop,
          checkpointPreviousVersions,
          checkpointPendingWrites,
          outputKeys: params.outputKeys ?? [],
          streamKeys: params.streamKeys ?? [],
          nodes: params.nodes,
          stream,
          store,
          cache: params.cache,
          interruptAfter: params.interruptAfter,
          interruptBefore: params.interruptBefore,
          durability: params.durability,
          debug: params.debug,
          triggerToNodes: params.triggerToNodes
        });
      }
      _checkpointerPutAfterPrevious(input) {
        this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(() => {
          return this.checkpointer?.put(input.config, input.checkpoint, input.metadata, input.newVersions);
        });
        this.checkpointerPromises.push(this._checkpointerChainedPromise);
      }
      /**
      * Put writes for a task, to be read by the next tick.
      * @param taskId
      * @param writes
      */
      putWrites(taskId, writes) {
        let writesCopy = writes;
        if (writesCopy.length === 0) return;
        if (writesCopy.every(([key]) => key in WRITES_IDX_MAP)) writesCopy = Array.from(new Map(writesCopy.map((w) => [w[0], w])).values());
        let hasUntrackedChannels = false;
        for (const key in this.channels) if (Object.prototype.hasOwnProperty.call(this.channels, key)) {
          if (this.channels[key].lc_graph_name === "UntrackedValue") {
            hasUntrackedChannels = true;
            break;
          }
        }
        let writesToSave = writesCopy;
        if (hasUntrackedChannels) writesToSave = writesCopy.filter(([c]) => {
          const channel = this.channels[c];
          return !channel || channel.lc_graph_name !== "UntrackedValue";
        }).map(([c, v]) => {
          if (c === TASKS2 && _isSend(v)) return [c, sanitizeUntrackedValuesInSend(v, this.channels)];
          return [c, v];
        });
        this.checkpointPendingWrites = this.checkpointPendingWrites.filter((w) => w[0] !== taskId);
        for (const [c, v] of writesToSave) this.checkpointPendingWrites.push([
          taskId,
          c,
          v
        ]);
        const config2 = patchConfigurable2(this.checkpointConfig, {
          [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? "",
          [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id
        });
        if (this.durability !== "exit" && this.checkpointer != null) this.checkpointerPromises.push(this.checkpointer.putWrites(config2, writesToSave, taskId));
        if (this.tasks) this._outputWrites(taskId, writesCopy);
        if (!writes.length || !this.cache || !this.tasks) return;
        const task2 = this.tasks[taskId];
        if (task2 == null || task2.cache_key == null) return;
        if (writes[0][0] === ERROR3 || writes[0][0] === INTERRUPT2) return;
        this.cache.set([{
          key: [task2.cache_key.ns, task2.cache_key.key],
          value: task2.writes,
          ttl: task2.cache_key.ttl
        }]);
      }
      _outputWrites(taskId, writes, cached2 = false) {
        const task2 = this.tasks[taskId];
        if (task2 !== void 0) {
          if (task2.config !== void 0 && (task2.config.tags ?? []).includes(TAG_HIDDEN)) return;
          if (writes.length > 0) {
            if (writes[0][0] === INTERRUPT2) {
              if (task2.path?.[0] === PUSH && task2.path?.[task2.path.length - 1] === true) return;
              const interruptWrites = writes.filter((w) => w[0] === INTERRUPT2).flatMap((w) => w[1]);
              this._emit([["updates", { [INTERRUPT2]: interruptWrites }], ["values", { [INTERRUPT2]: interruptWrites }]]);
            } else if (writes[0][0] !== ERROR3) this._emit(gatherIteratorSync(prefixGenerator(mapOutputUpdates(this.outputKeys, [[task2, writes]], cached2), "updates")));
          }
          if (!cached2) this._emit(gatherIteratorSync(prefixGenerator(mapDebugTaskResults([[task2, writes]], this.streamKeys), "tasks")));
        }
      }
      async _matchCachedWrites() {
        if (!this.cache) return [];
        const matched = [];
        const serializeKey = ([ns, key]) => {
          return `ns:${ns.join(",")}|key:${key}`;
        };
        const keys = [];
        const keyMap = {};
        for (const task2 of Object.values(this.tasks)) if (task2.cache_key != null && !task2.writes.length) {
          keys.push([task2.cache_key.ns, task2.cache_key.key]);
          keyMap[serializeKey([task2.cache_key.ns, task2.cache_key.key])] = task2;
        }
        if (keys.length === 0) return [];
        const cache2 = await this.cache.get(keys);
        for (const { key, value } of cache2) {
          const task2 = keyMap[serializeKey(key)];
          if (task2 != null) {
            task2.writes.push(...value);
            matched.push({
              task: task2,
              result: value
            });
          }
        }
        return matched;
      }
      /**
      * Execute a single iteration of the Pregel loop.
      * Returns true if more iterations are needed.
      * @param params
      */
      async tick(params) {
        if (this.store && !this.store.isRunning) await this.store?.start();
        const { inputKeys = [] } = params;
        if (this.status !== "pending") throw new Error(`Cannot tick when status is no longer "pending". Current status: "${this.status}"`);
        if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) await this._first(inputKeys);
        else if (this.toInterrupt.length > 0) {
          this.status = "interrupt_before";
          throw new GraphInterrupt();
        } else if (Object.values(this.tasks).every((task2) => task2.writes.length > 0)) {
          const writes = Object.values(this.tasks).flatMap((t) => t.writes);
          this.updatedChannels = _applyWrites(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion, this.triggerToNodes);
          const valuesOutput = await gatherIterator(prefixGenerator(mapOutputValues(this.outputKeys, writes, this.channels), "values"));
          this._emit(valuesOutput);
          this.checkpointPendingWrites = [];
          await this._putCheckpoint({ source: "loop" });
          if (shouldInterrupt(this.checkpoint, this.interruptAfter, Object.values(this.tasks))) {
            this.status = "interrupt_after";
            throw new GraphInterrupt();
          }
          if (this.config.configurable?.[CONFIG_KEY_RESUMING] !== void 0) delete this.config.configurable?.[CONFIG_KEY_RESUMING];
        } else return false;
        if (this.step > this.stop) {
          this.status = "out_of_steps";
          return false;
        }
        this.tasks = _prepareNextTasks(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.config, true, {
          step: this.step,
          checkpointer: this.checkpointer,
          isResuming: this.isResuming,
          manager: this.manager,
          store: this.store,
          stream: this.stream,
          triggerToNodes: this.triggerToNodes,
          updatedChannels: this.updatedChannels
        });
        if (this.checkpointer) this._emit(await gatherIterator(prefixGenerator(mapDebugCheckpoint(this.checkpointConfig, this.channels, this.streamKeys, this.checkpointMetadata, Object.values(this.tasks), this.checkpointPendingWrites, this.prevCheckpointConfig, this.outputKeys), "checkpoints")));
        if (Object.values(this.tasks).length === 0) {
          this.status = "done";
          return false;
        }
        if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {
          for (const [tid, k, v] of this.checkpointPendingWrites) {
            if (k === ERROR3 || k === INTERRUPT2 || k === RESUME2) continue;
            const task2 = Object.values(this.tasks).find((t) => t.id === tid);
            if (task2) task2.writes.push([k, v]);
          }
          for (const task2 of Object.values(this.tasks)) if (task2.writes.length > 0) this._outputWrites(task2.id, task2.writes, true);
        }
        if (Object.values(this.tasks).every((task2) => task2.writes.length > 0)) return this.tick({ inputKeys });
        if (shouldInterrupt(this.checkpoint, this.interruptBefore, Object.values(this.tasks))) {
          this.status = "interrupt_before";
          throw new GraphInterrupt();
        }
        const debugOutput = await gatherIterator(prefixGenerator(mapDebugTasks(Object.values(this.tasks)), "tasks"));
        this._emit(debugOutput);
        return true;
      }
      async finishAndHandleError(error40) {
        if (this.durability === "exit" && (!this.isNested || typeof error40 !== "undefined" || this.checkpointNamespace.every((part) => !part.includes(CHECKPOINT_NAMESPACE_END)))) {
          this._putCheckpoint(this.checkpointMetadata);
          this._flushPendingWrites();
        }
        const suppress = this._suppressInterrupt(error40);
        if (suppress || error40 === void 0) this.output = readChannels(this.channels, this.outputKeys);
        if (suppress) {
          if (this.tasks !== void 0 && this.checkpointPendingWrites.length > 0 && Object.values(this.tasks).some((task2) => task2.writes.length > 0)) {
            this.updatedChannels = _applyWrites(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion, this.triggerToNodes);
            this._emit(gatherIteratorSync(prefixGenerator(mapOutputValues(this.outputKeys, Object.values(this.tasks).flatMap((t) => t.writes), this.channels), "values")));
          }
          if (isGraphInterrupt(error40) && !error40.interrupts.length) this._emit([["updates", { [INTERRUPT2]: [] }], ["values", { [INTERRUPT2]: [] }]]);
        }
        return suppress;
      }
      async acceptPush(task2, writeIdx, call3) {
        if (this.interruptAfter?.length > 0 && shouldInterrupt(this.checkpoint, this.interruptAfter, [task2])) {
          this.toInterrupt.push(task2);
          return;
        }
        const pushed = _prepareSingleTask([
          PUSH,
          task2.path ?? [],
          writeIdx,
          task2.id,
          call3
        ], this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, task2.config ?? {}, true, {
          step: this.step,
          checkpointer: this.checkpointer,
          manager: this.manager,
          store: this.store,
          stream: this.stream
        });
        if (!pushed) return;
        if (this.interruptBefore?.length > 0 && shouldInterrupt(this.checkpoint, this.interruptBefore, [pushed])) {
          this.toInterrupt.push(pushed);
          return;
        }
        this._emit(gatherIteratorSync(prefixGenerator(mapDebugTasks([pushed]), "tasks")));
        if (this.debug) printStepTasks(this.step, [pushed]);
        this.tasks[pushed.id] = pushed;
        if (this.skipDoneTasks) this._matchWrites({ [pushed.id]: pushed });
        const tasks = await this._matchCachedWrites();
        for (const { task: task3 } of tasks) this._outputWrites(task3.id, task3.writes, true);
        return pushed;
      }
      _suppressInterrupt(e) {
        return isGraphInterrupt(e) && !this.isNested;
      }
      async _first(inputKeys) {
        const { configurable } = this.config;
        const scratchpad = configurable?.[CONFIG_KEY_SCRATCHPAD];
        if (scratchpad && scratchpad.nullResume !== void 0) this.putWrites(NULL_TASK_ID, [[RESUME2, scratchpad.nullResume]]);
        if (isCommand(this.input)) {
          const hasResume = this.input.resume != null;
          if (this.input.resume != null && typeof this.input.resume === "object" && Object.keys(this.input.resume).every(isXXH3)) {
            this.config.configurable ??= {};
            this.config.configurable[CONFIG_KEY_RESUME_MAP] = this.input.resume;
          }
          if (hasResume && this.checkpointer == null) throw new Error("Cannot use Command(resume=...) without checkpointer");
          const writes = {};
          for (const [tid, key, value] of mapCommand(this.input, this.checkpointPendingWrites)) {
            writes[tid] ??= [];
            writes[tid].push([key, value]);
          }
          if (Object.keys(writes).length === 0) throw new EmptyInputError("Received empty Command input");
          for (const [tid, ws] of Object.entries(writes)) this.putWrites(tid, ws);
        }
        const nullWrites = (this.checkpointPendingWrites ?? []).filter((w) => w[0] === NULL_TASK_ID).map((w) => w.slice(1));
        if (nullWrites.length > 0) _applyWrites(this.checkpoint, this.channels, [{
          name: INPUT,
          writes: nullWrites,
          triggers: []
        }], this.checkpointerGetNextVersion, this.triggerToNodes);
        const isCommandUpdateOrGoto = isCommand(this.input) && nullWrites.length > 0;
        if (this.isResuming || isCommandUpdateOrGoto) {
          for (const channelName in this.channels) {
            if (!Object.prototype.hasOwnProperty.call(this.channels, channelName)) continue;
            if (this.checkpoint.channel_versions[channelName] !== void 0) {
              const version2 = this.checkpoint.channel_versions[channelName];
              this.checkpoint.versions_seen[INTERRUPT2] = {
                ...this.checkpoint.versions_seen[INTERRUPT2],
                [channelName]: version2
              };
            }
          }
          const valuesOutput = await gatherIterator(prefixGenerator(mapOutputValues(this.outputKeys, true, this.channels), "values"));
          this._emit(valuesOutput);
        }
        if (this.isResuming) this.input = INPUT_RESUMING;
        else if (isCommandUpdateOrGoto) {
          await this._putCheckpoint({ source: "input" });
          this.input = INPUT_DONE;
        } else {
          const inputWrites = await gatherIterator(mapInput(inputKeys, this.input));
          if (inputWrites.length > 0) {
            const discardTasks = _prepareNextTasks(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.config, true, { step: this.step });
            this.updatedChannels = _applyWrites(this.checkpoint, this.channels, Object.values(discardTasks).concat([{
              name: INPUT,
              writes: inputWrites,
              triggers: []
            }]), this.checkpointerGetNextVersion, this.triggerToNodes);
            await this._putCheckpoint({ source: "input" });
            this.input = INPUT_DONE;
          } else if (!(CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) throw new EmptyInputError(`Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`);
          else this.input = INPUT_DONE;
        }
        if (!this.isNested) this.config = patchConfigurable2(this.config, { [CONFIG_KEY_RESUMING]: this.isResuming });
      }
      _emit(values) {
        for (const [mode, payload] of values) {
          if (this.stream.modes.has(mode)) this.stream.push([
            this.checkpointNamespace,
            mode,
            payload
          ]);
          if ((mode === "checkpoints" || mode === "tasks") && this.stream.modes.has("debug")) {
            const step = mode === "checkpoints" ? this.step - 1 : this.step;
            const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
            const type = (() => {
              if (mode === "checkpoints") return "checkpoint";
              else if (typeof payload === "object" && payload != null && "result" in payload) return "task_result";
              else return "task";
            })();
            this.stream.push([
              this.checkpointNamespace,
              "debug",
              {
                step,
                type,
                timestamp: timestamp2,
                payload
              }
            ]);
          }
        }
      }
      _putCheckpoint(inputMetadata) {
        const exiting = this.checkpointMetadata === inputMetadata;
        const doCheckpoint = this.checkpointer != null && (this.durability !== "exit" || exiting);
        const storeCheckpoint = (checkpoint) => {
          this.prevCheckpointConfig = this.checkpointConfig?.configurable?.checkpoint_id ? this.checkpointConfig : void 0;
          this.checkpointConfig = patchConfigurable2(this.checkpointConfig, { [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? "" });
          const channelVersions = { ...this.checkpoint.channel_versions };
          const newVersions = getNewChannelVersions(this.checkpointPreviousVersions, channelVersions);
          this.checkpointPreviousVersions = channelVersions;
          this._checkpointerPutAfterPrevious({
            config: { ...this.checkpointConfig },
            checkpoint: copyCheckpoint(checkpoint),
            metadata: { ...this.checkpointMetadata },
            newVersions
          });
          this.checkpointConfig = {
            ...this.checkpointConfig,
            configurable: {
              ...this.checkpointConfig.configurable,
              checkpoint_id: this.checkpoint.id
            }
          };
        };
        if (!exiting) this.checkpointMetadata = {
          ...inputMetadata,
          step: this.step,
          parents: this.config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] ?? {}
        };
        this.checkpoint = createCheckpoint(this.checkpoint, doCheckpoint ? this.channels : void 0, this.step, exiting ? { id: this.checkpoint.id } : void 0);
        if (doCheckpoint) storeCheckpoint(this.checkpoint);
        if (!exiting) this.step += 1;
      }
      _flushPendingWrites() {
        if (this.checkpointer == null) return;
        if (this.checkpointPendingWrites.length === 0) return;
        const config2 = patchConfigurable2(this.checkpointConfig, {
          [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? "",
          [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id
        });
        const byTask = {};
        for (const [tid, key, value] of this.checkpointPendingWrites) {
          byTask[tid] ??= [];
          byTask[tid].push([key, value]);
        }
        for (const [tid, ws] of Object.entries(byTask)) this.checkpointerPromises.push(this.checkpointer.putWrites(config2, ws, tid));
      }
      _matchWrites(tasks) {
        for (const [tid, k, v] of this.checkpointPendingWrites) {
          if (k === ERROR3 || k === INTERRUPT2 || k === RESUME2) continue;
          const task2 = Object.values(tasks).find((t) => t.id === tid);
          if (task2) task2.writes.push([k, v]);
        }
        for (const task2 of Object.values(tasks)) if (task2.writes.length > 0) this._outputWrites(task2.id, task2.writes, true);
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/messages.js
function isChatGenerationChunk2(x) {
  return isBaseMessage(x?.message);
}
var StreamMessagesHandler;
var init_messages3 = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/messages.js"() {
    init_constants3();
    init_base2();
    init_messages2();
    StreamMessagesHandler = class extends BaseCallbackHandler {
      name = "StreamMessagesHandler";
      streamFn;
      metadatas = {};
      seen = {};
      emittedChatModelRunIds = {};
      stableMessageIdMap = {};
      lc_prefer_streaming = true;
      constructor(streamFn) {
        super();
        this.streamFn = streamFn;
      }
      _emit(meta, message, runId, dedupe = false) {
        if (dedupe && message.id !== void 0 && this.seen[message.id] !== void 0) return;
        let messageId = message.id;
        if (runId != null) if (isToolMessage(message)) messageId ??= `run-${runId}-tool-${message.tool_call_id}`;
        else {
          if (messageId == null || messageId === `run-${runId}`) messageId = this.stableMessageIdMap[runId] ?? messageId ?? `run-${runId}`;
          this.stableMessageIdMap[runId] ??= messageId;
        }
        if (messageId !== message.id) {
          message.id = messageId;
          message.lc_kwargs.id = messageId;
        }
        if (message.id != null) this.seen[message.id] = message;
        this.streamFn([
          meta[0],
          "messages",
          [message, meta[1]]
        ]);
      }
      handleChatModelStart(_llm, _messages, runId, _parentRunId, _extraParams, tags, metadata, name) {
        if (metadata && (!tags || !tags.includes(TAG_NOSTREAM) && !tags.includes("nostream"))) this.metadatas[runId] = [metadata.langgraph_checkpoint_ns.split("|"), {
          tags,
          name,
          ...metadata
        }];
      }
      handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, fields) {
        const chunk = fields?.chunk;
        this.emittedChatModelRunIds[runId] = true;
        if (this.metadatas[runId] !== void 0) if (isChatGenerationChunk2(chunk)) this._emit(this.metadatas[runId], chunk.message, runId);
        else this._emit(this.metadatas[runId], new AIMessageChunk({ content: token }), runId);
      }
      handleLLMEnd(output, runId) {
        if (this.metadatas[runId] === void 0) return;
        if (!this.emittedChatModelRunIds[runId]) {
          const chatGeneration = output.generations?.[0]?.[0];
          if (isBaseMessage(chatGeneration?.message)) this._emit(this.metadatas[runId], chatGeneration?.message, runId, true);
          delete this.emittedChatModelRunIds[runId];
        }
        delete this.metadatas[runId];
        delete this.stableMessageIdMap[runId];
      }
      handleLLMError(_err, runId) {
        delete this.metadatas[runId];
      }
      handleChainStart(_chain, inputs, runId, _parentRunId, tags, metadata, _runType, name) {
        if (metadata !== void 0 && name === metadata.langgraph_node && (tags === void 0 || !tags.includes(TAG_HIDDEN))) {
          this.metadatas[runId] = [metadata.langgraph_checkpoint_ns.split("|"), {
            tags,
            name,
            ...metadata
          }];
          if (typeof inputs === "object") {
            for (const value of Object.values(inputs)) if ((isBaseMessage(value) || isBaseMessageChunk(value)) && value.id !== void 0) this.seen[value.id] = value;
            else if (Array.isArray(value)) {
              for (const item of value) if ((isBaseMessage(item) || isBaseMessageChunk(item)) && item.id !== void 0) this.seen[item.id] = item;
            }
          }
        }
      }
      handleChainEnd(outputs, runId) {
        const metadata = this.metadatas[runId];
        delete this.metadatas[runId];
        if (metadata !== void 0) {
          if (isBaseMessage(outputs)) this._emit(metadata, outputs, runId, true);
          else if (Array.isArray(outputs)) {
            for (const value of outputs) if (isBaseMessage(value)) this._emit(metadata, value, runId, true);
          } else if (outputs != null && typeof outputs === "object") {
            for (const value of Object.values(outputs)) if (isBaseMessage(value)) this._emit(metadata, value, runId, true);
            else if (Array.isArray(value)) {
              for (const item of value) if (isBaseMessage(item)) this._emit(metadata, item, runId, true);
            }
          }
        }
      }
      handleChainError(_err, runId) {
        delete this.metadatas[runId];
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/retry.js
async function _runWithRetry(pregelTask, retryPolicy, configurable, signal) {
  const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;
  let interval = resolvedRetryPolicy !== void 0 ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL : 0;
  let attempts = 0;
  let error40;
  let result;
  let { config: config2 } = pregelTask;
  if (configurable) config2 = patchConfigurable2(config2, configurable);
  config2 = {
    ...config2,
    signal
  };
  while (true) {
    if (signal?.aborted) break;
    pregelTask.writes.splice(0, pregelTask.writes.length);
    error40 = void 0;
    try {
      result = await pregelTask.proc.invoke(pregelTask.input, config2);
      break;
    } catch (e) {
      error40 = e;
      error40.pregelTaskId = pregelTask.id;
      if (isParentCommand(error40)) {
        const ns = config2?.configurable?.checkpoint_ns;
        const cmd = error40.command;
        if (cmd.graph === ns) {
          for (const writer2 of pregelTask.writers) await writer2.invoke(cmd, config2);
          error40 = void 0;
          break;
        } else if (cmd.graph === Command.PARENT) {
          const parentNs = getParentCheckpointNamespace(ns);
          error40.command = new Command({
            ...error40.command,
            graph: parentNs
          });
        }
      }
      if (isGraphBubbleUp(error40)) break;
      if (resolvedRetryPolicy === void 0) break;
      attempts += 1;
      if (attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)) break;
      if (!(resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER)(error40)) break;
      interval = Math.min(resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL, interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR));
      const intervalWithJitter = resolvedRetryPolicy.jitter ? Math.floor(interval + Math.random() * 1e3) : interval;
      await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));
      const errorName = error40.name ?? error40.constructor.unminifiable_name ?? error40.constructor.name;
      if (resolvedRetryPolicy?.logWarning ?? true) console.log(`Retrying task "${String(pregelTask.name)}" after ${interval.toFixed(2)}ms (attempt ${attempts}) after ${errorName}: ${error40}`);
      config2 = patchConfigurable2(config2, { [CONFIG_KEY_RESUMING]: true });
    }
  }
  return {
    task: pregelTask,
    result,
    error: error40,
    signalAborted: signal?.aborted
  };
}
var DEFAULT_INITIAL_INTERVAL, DEFAULT_BACKOFF_FACTOR, DEFAULT_MAX_INTERVAL, DEFAULT_MAX_RETRIES, DEFAULT_STATUS_NO_RETRY, DEFAULT_RETRY_ON_HANDLER;
var init_retry = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/retry.js"() {
    init_errors3();
    init_constants3();
    init_config2();
    init_utils9();
    DEFAULT_INITIAL_INTERVAL = 500;
    DEFAULT_BACKOFF_FACTOR = 2;
    DEFAULT_MAX_INTERVAL = 128e3;
    DEFAULT_MAX_RETRIES = 3;
    DEFAULT_STATUS_NO_RETRY = [
      400,
      401,
      402,
      403,
      404,
      405,
      406,
      407,
      409
    ];
    DEFAULT_RETRY_ON_HANDLER = (error40) => {
      if (error40.message.startsWith("Cancel") || error40.message.startsWith("AbortError") || error40.name === "AbortError") return false;
      if (error40.name === "GraphValueError") return false;
      if (error40?.code === "ECONNABORTED") return false;
      const status = error40?.response?.status ?? error40?.status;
      if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) return false;
      if (error40?.error?.code === "insufficient_quota") return false;
      return true;
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/runner.js
function createPromiseBarrier() {
  const barrier = {
    next: () => void 0,
    wait: Promise.resolve(PROMISE_ADDED_SYMBOL)
  };
  function waitHandler(resolve) {
    barrier.next = () => {
      barrier.wait = new Promise(waitHandler);
      resolve(PROMISE_ADDED_SYMBOL);
    };
  }
  barrier.wait = new Promise(waitHandler);
  return barrier;
}
async function call(runner, task2, func, name, input, options = {}) {
  const scratchpad = task2.config?.configurable?.[CONFIG_KEY_SCRATCHPAD];
  if (!scratchpad) throw new Error(`BUG: No scratchpad found on task ${task2.name}__${task2.id}`);
  const cnt = scratchpad.callCounter;
  scratchpad.callCounter += 1;
  const wcall = new Call({
    func,
    name,
    input,
    cache: options.cache,
    retry: options.retry,
    callbacks: options.callbacks
  });
  const nextTask = await this.scheduleTask(task2, cnt, wcall);
  if (!nextTask) return void 0;
  const existingPromise = this.executingTasksMap[nextTask.id];
  if (existingPromise !== void 0) return existingPromise;
  if (nextTask.writes.length > 0) {
    const returns = nextTask.writes.filter(([c]) => c === RETURN);
    const errors = nextTask.writes.filter(([c]) => c === ERROR3);
    if (returns.length > 0) {
      if (returns.length === 1) return Promise.resolve(returns[0][1]);
      throw new Error(`BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`);
    }
    if (errors.length > 0) {
      if (errors.length === 1) {
        const errorValue = errors[0][1];
        const error40 = errorValue instanceof Error ? errorValue : new Error(String(errorValue));
        return Promise.reject(error40);
      }
      throw new Error(`BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`);
    }
    return;
  } else {
    const prom = _runWithRetry(nextTask, options.retry, { [CONFIG_KEY_CALL]: call.bind(this, runner, nextTask) });
    this.executingTasksMap[nextTask.id] = prom;
    this.barrier.next();
    return prom.then(({ result, error: error40 }) => {
      if (error40) return Promise.reject(error40);
      return result;
    });
  }
}
var PROMISE_ADDED_SYMBOL, PregelRunner;
var init_runner = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/runner.js"() {
    init_errors3();
    init_constants3();
    init_types6();
    init_utils9();
    init_retry();
    PROMISE_ADDED_SYMBOL = Symbol.for("promiseAdded");
    PregelRunner = class {
      nodeFinished;
      loop;
      /**
      * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.
      * @param loop - The PregelLoop that produces tasks for this runner to execute.
      */
      constructor({ loop, nodeFinished }) {
        this.loop = loop;
        this.nodeFinished = nodeFinished;
      }
      /**
      * Execute tasks from the current step of the PregelLoop.
      *
      * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.
      * @param options - Options for the execution.
      */
      async tick(options = {}) {
        const { timeout, retryPolicy, onStepWrite, maxConcurrency } = options;
        const nodeErrors = /* @__PURE__ */ new Set();
        let graphBubbleUp;
        const exceptionSignalController = new AbortController();
        const exceptionSignal = exceptionSignalController.signal;
        const stepTimeoutSignal = timeout ? AbortSignal.timeout(timeout) : void 0;
        const pendingTasks = Object.values(this.loop.tasks).filter((t) => t.writes.length === 0);
        const { signals, disposeCombinedSignal } = this._initializeAbortSignals({
          exceptionSignal,
          stepTimeoutSignal,
          signal: options.signal
        });
        const taskStream = this._executeTasksWithRetry(pendingTasks, {
          signals,
          retryPolicy,
          maxConcurrency
        });
        for await (const { task: task2, error: error40, signalAborted } of taskStream) {
          this._commit(task2, error40);
          if (isGraphInterrupt(error40)) graphBubbleUp = error40;
          else if (isGraphBubbleUp(error40) && !isGraphInterrupt(graphBubbleUp)) graphBubbleUp = error40;
          else if (error40 && (nodeErrors.size === 0 || !signalAborted)) {
            exceptionSignalController.abort();
            nodeErrors.add(error40);
          }
        }
        disposeCombinedSignal?.();
        onStepWrite?.(this.loop.step, Object.values(this.loop.tasks).map((task2) => task2.writes).flat());
        if (nodeErrors.size === 1) throw Array.from(nodeErrors)[0];
        else if (nodeErrors.size > 1) throw new AggregateError(Array.from(nodeErrors), `Multiple errors occurred during superstep ${this.loop.step}. See the "errors" field of this exception for more details.`);
        if (isGraphInterrupt(graphBubbleUp)) throw graphBubbleUp;
        if (isGraphBubbleUp(graphBubbleUp) && this.loop.isNested) throw graphBubbleUp;
      }
      /**
      * Initializes the current AbortSignals for the PregelRunner, handling the various ways that
      * AbortSignals must be chained together so that the PregelLoop can be interrupted if necessary
      * while still allowing nodes to gracefully exit.
      *
      * This method must only be called once per PregelRunner#tick. It has the side effect of updating
      * the PregelLoop#config with the new AbortSignals so they may be propagated correctly to future
      * ticks and subgraph calls.
      *
      * @param options - Options for the initialization.
      * @returns The current abort signals.
      * @internal
      */
      _initializeAbortSignals({ exceptionSignal, stepTimeoutSignal, signal }) {
        const previousSignals = this.loop.config.configurable?.[CONFIG_KEY_ABORT_SIGNALS] ?? {};
        const externalAbortSignal = previousSignals.externalAbortSignal ?? signal;
        const timeoutAbortSignal = stepTimeoutSignal ?? previousSignals.timeoutAbortSignal;
        const { signal: composedAbortSignal, dispose: disposeCombinedSignal } = combineAbortSignals(externalAbortSignal, timeoutAbortSignal, exceptionSignal);
        const signals = {
          externalAbortSignal,
          timeoutAbortSignal,
          composedAbortSignal
        };
        this.loop.config = patchConfigurable2(this.loop.config, { [CONFIG_KEY_ABORT_SIGNALS]: signals });
        return {
          signals,
          disposeCombinedSignal
        };
      }
      /**
      * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.
      * @param tasks - The tasks to execute.
      * @param options - Options for the execution.
      */
      async *_executeTasksWithRetry(tasks, options) {
        const { retryPolicy, maxConcurrency, signals } = options ?? {};
        const barrier = createPromiseBarrier();
        const executingTasksMap = {};
        const thisCall = {
          executingTasksMap,
          barrier,
          retryPolicy,
          scheduleTask: async (task2, writeIdx, call3) => this.loop.acceptPush(task2, writeIdx, call3)
        };
        if (signals?.composedAbortSignal?.aborted) throw new Error("Abort");
        let startedTasksCount = 0;
        let listener;
        const timeoutOrCancelSignal = combineAbortSignals(signals?.externalAbortSignal, signals?.timeoutAbortSignal);
        const abortPromise = timeoutOrCancelSignal.signal ? new Promise((_resolve, reject) => {
          listener = () => reject(/* @__PURE__ */ new Error("Abort"));
          timeoutOrCancelSignal.signal?.addEventListener("abort", listener, { once: true });
        }) : void 0;
        while ((startedTasksCount === 0 || Object.keys(executingTasksMap).length > 0) && tasks.length) {
          for (; Object.values(executingTasksMap).length < (maxConcurrency ?? tasks.length) && startedTasksCount < tasks.length; startedTasksCount += 1) {
            const task2 = tasks[startedTasksCount];
            executingTasksMap[task2.id] = _runWithRetry(task2, retryPolicy, { [CONFIG_KEY_CALL]: call?.bind(thisCall, this, task2) }, signals?.composedAbortSignal).catch((error40) => {
              return {
                task: task2,
                error: error40,
                signalAborted: signals?.composedAbortSignal?.aborted
              };
            });
          }
          const settledTask = await Promise.race([
            ...Object.values(executingTasksMap),
            ...abortPromise ? [abortPromise] : [],
            barrier.wait
          ]);
          if (settledTask === PROMISE_ADDED_SYMBOL) continue;
          yield settledTask;
          if (listener != null) {
            timeoutOrCancelSignal.signal?.removeEventListener("abort", listener);
            timeoutOrCancelSignal.dispose?.();
          }
          delete executingTasksMap[settledTask.task.id];
        }
      }
      /**
      * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.
      *
      * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.
      *
      * @param task - The task to commit.
      * @param error - The error that occurred, if any.
      */
      _commit(task2, error40) {
        if (error40 !== void 0) if (isGraphInterrupt(error40)) {
          if (error40.interrupts.length) {
            const interrupts = error40.interrupts.map((interrupt2) => [INTERRUPT2, interrupt2]);
            const resumes = task2.writes.filter((w) => w[0] === RESUME2);
            if (resumes.length) interrupts.push(...resumes);
            this.loop.putWrites(task2.id, interrupts);
          }
        } else if (isGraphBubbleUp(error40) && task2.writes.length) this.loop.putWrites(task2.id, task2.writes);
        else this.loop.putWrites(task2.id, [[ERROR3, {
          message: error40.message,
          name: error40.name
        }]]);
        else {
          if (this.nodeFinished && (task2.config?.tags == null || !task2.config.tags.includes(TAG_HIDDEN))) this.nodeFinished(String(task2.name));
          if (task2.writes.length === 0) task2.writes.push([NO_WRITES, null]);
          this.loop.putWrites(task2.id, task2.writes);
        }
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/validate.js
function validateGraph({ nodes, channels, inputChannels, outputChannels, streamChannels, interruptAfterNodes, interruptBeforeNodes }) {
  if (!channels) throw new GraphValidationError("Channels not provided");
  const subscribedChannels = /* @__PURE__ */ new Set();
  const allOutputChannels = /* @__PURE__ */ new Set();
  for (const [name, node] of Object.entries(nodes)) {
    if (name === INTERRUPT2) throw new GraphValidationError(`"Node name ${INTERRUPT2} is reserved"`);
    if (node.constructor === PregelNode) node.triggers.forEach((trigger) => subscribedChannels.add(trigger));
    else throw new GraphValidationError(`Invalid node type ${typeof node}, expected PregelNode`);
  }
  for (const chan of subscribedChannels) if (!(chan in channels)) throw new GraphValidationError(`Subscribed channel '${String(chan)}' not in channels`);
  if (!Array.isArray(inputChannels)) {
    if (!subscribedChannels.has(inputChannels)) throw new GraphValidationError(`Input channel ${String(inputChannels)} is not subscribed to by any node`);
  } else if (inputChannels.every((channel) => !subscribedChannels.has(channel))) throw new GraphValidationError(`None of the input channels ${inputChannels} are subscribed to by any node`);
  if (!Array.isArray(outputChannels)) allOutputChannels.add(outputChannels);
  else outputChannels.forEach((chan) => allOutputChannels.add(chan));
  if (streamChannels && !Array.isArray(streamChannels)) allOutputChannels.add(streamChannels);
  else if (Array.isArray(streamChannels)) streamChannels.forEach((chan) => allOutputChannels.add(chan));
  for (const chan of allOutputChannels) if (!(chan in channels)) throw new GraphValidationError(`Output channel '${String(chan)}' not in channels`);
  if (interruptAfterNodes && interruptAfterNodes !== "*") {
    for (const node of interruptAfterNodes) if (!(node in nodes)) throw new GraphValidationError(`Node ${String(node)} not in nodes`);
  }
  if (interruptBeforeNodes && interruptBeforeNodes !== "*") {
    for (const node of interruptBeforeNodes) if (!(node in nodes)) throw new GraphValidationError(`Node ${String(node)} not in nodes`);
  }
}
function validateKeys(keys, channels) {
  if (Array.isArray(keys)) {
    for (const key of keys) if (!(key in channels)) throw new Error(`Key ${String(key)} not found in channels`);
  } else if (!(keys in channels)) throw new Error(`Key ${String(keys)} not found in channels`);
}
var GraphValidationError;
var init_validate5 = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/validate.js"() {
    init_constants3();
    init_read();
    GraphValidationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "GraphValidationError";
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/channels/topic.js
var Topic;
var init_topic = __esm({
  "node_modules/@langchain/langgraph/dist/channels/topic.js"() {
    init_errors3();
    init_base15();
    Topic = class Topic2 extends BaseChannel {
      lc_graph_name = "Topic";
      unique = false;
      accumulate = false;
      seen;
      values;
      constructor(fields) {
        super();
        this.unique = fields?.unique ?? this.unique;
        this.accumulate = fields?.accumulate ?? this.accumulate;
        this.seen = /* @__PURE__ */ new Set();
        this.values = [];
      }
      fromCheckpoint(checkpoint) {
        const empty = new Topic2({
          unique: this.unique,
          accumulate: this.accumulate
        });
        if (typeof checkpoint !== "undefined") {
          empty.seen = new Set(checkpoint[0]);
          empty.values = checkpoint[1];
        }
        return empty;
      }
      update(values) {
        let updated = false;
        if (!this.accumulate) {
          updated = this.values.length > 0;
          this.values = [];
        }
        const flatValues = values.flat();
        if (flatValues.length > 0) if (this.unique) {
          for (const value of flatValues) if (!this.seen.has(value)) {
            updated = true;
            this.seen.add(value);
            this.values.push(value);
          }
        } else {
          updated = true;
          this.values.push(...flatValues);
        }
        return updated;
      }
      get() {
        if (this.values.length === 0) throw new EmptyChannelError();
        return this.values;
      }
      checkpoint() {
        return [[...this.seen], this.values];
      }
      isAvailable() {
        return this.values.length !== 0;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/pregel/index.js
var Channel, PartialRunnable, Pregel;
var init_pregel = __esm({
  "node_modules/@langchain/langgraph/dist/pregel/index.js"() {
    init_errors3();
    init_base15();
    init_constants3();
    init_config2();
    init_utils8();
    init_write();
    init_read();
    init_io();
    init_utils9();
    init_algo();
    init_subgraph();
    init_debug();
    init_stream3();
    init_loop();
    init_messages3();
    init_runner();
    init_validate5();
    init_topic();
    init_interrupt();
    init_dist3();
    init_runnables();
    Channel = class {
      static subscribeTo(channels, options) {
        const { key, tags } = {
          key: void 0,
          tags: void 0,
          ...options ?? {}
        };
        if (Array.isArray(channels) && key !== void 0) throw new Error("Can't specify a key when subscribing to multiple channels");
        let channelMappingOrArray;
        if (typeof channels === "string") if (key) channelMappingOrArray = { [key]: channels };
        else channelMappingOrArray = [channels];
        else channelMappingOrArray = Object.fromEntries(channels.map((chan) => [chan, chan]));
        return new PregelNode({
          channels: channelMappingOrArray,
          triggers: Array.isArray(channels) ? channels : [channels],
          tags
        });
      }
      /**
      * Creates a ChannelWrite that specifies how to write values to channels.
      * This is used to define how nodes send output to channels.
      *
      * @example
      * ```typescript
      * // Write to multiple channels
      * const write = Channel.writeTo(["output", "state"]);
      *
      * // Write with specific values
      * const write = Channel.writeTo(["output"], {
      *   state: "completed",
      *   result: calculateResult()
      * });
      *
      * // Write with a transformation function
      * const write = Channel.writeTo(["output"], {
      *   result: (x) => processResult(x)
      * });
      * ```
      *
      * @param channels - Array of channel names to write to
      * @param writes - Optional map of channel names to values or transformations
      * @returns A ChannelWrite object that can be used to write to the specified channels
      */
      static writeTo(channels, writes) {
        const channelWriteEntries = [];
        for (const channel of channels) channelWriteEntries.push({
          channel,
          value: PASSTHROUGH,
          skipNone: false
        });
        for (const [key, value] of Object.entries(writes ?? {})) if (Runnable.isRunnable(value) || typeof value === "function") channelWriteEntries.push({
          channel: key,
          value: PASSTHROUGH,
          skipNone: true,
          mapper: _coerceToRunnable(value)
        });
        else channelWriteEntries.push({
          channel: key,
          value,
          skipNone: false
        });
        return new ChannelWrite(channelWriteEntries);
      }
    };
    PartialRunnable = class extends Runnable {
      lc_namespace = ["langgraph", "pregel"];
      invoke(_input, _options) {
        throw new Error("Not implemented");
      }
      withConfig(_config) {
        return super.withConfig(_config);
      }
      stream(input, options) {
        return super.stream(input, options);
      }
    };
    Pregel = class extends PartialRunnable {
      /**
      * Name of the class when serialized
      * @internal
      */
      static lc_name() {
        return "LangGraph";
      }
      /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */
      lc_namespace = ["langgraph", "pregel"];
      /** @internal Flag indicating this is a Pregel instance - necessary for serialization */
      lg_is_pregel = true;
      /** The nodes in the graph, mapping node names to their PregelNode instances */
      nodes;
      /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */
      channels;
      /**
      * The input channels for the graph. These channels receive the initial input when the graph is invoked.
      * Can be a single channel key or an array of channel keys.
      */
      inputChannels;
      /**
      * The output channels for the graph. These channels contain the final output when the graph completes.
      * Can be a single channel key or an array of channel keys.
      */
      outputChannels;
      /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */
      autoValidate = true;
      /**
      * The streaming modes enabled for this graph. Defaults to ["values"].
      * Supported modes:
      * - "values": Streams the full state after each step
      * - "updates": Streams state updates after each step
      * - "messages": Streams messages from within nodes
      * - "custom": Streams custom events from within nodes
      * - "debug": Streams events related to the execution of the graph - useful for tracing & debugging graph execution
      */
      streamMode = ["values"];
      /**
      * Optional channels to stream. If not specified, all channels will be streamed.
      * Can be a single channel key or an array of channel keys.
      */
      streamChannels;
      /**
      * Optional array of node names or "all" to interrupt after executing these nodes.
      * Used for implementing human-in-the-loop workflows.
      */
      interruptAfter;
      /**
      * Optional array of node names or "all" to interrupt before executing these nodes.
      * Used for implementing human-in-the-loop workflows.
      */
      interruptBefore;
      /** Optional timeout in milliseconds for the execution of each superstep */
      stepTimeout;
      /** Whether to enable debug logging. Defaults to false. */
      debug = false;
      /**
      * Optional checkpointer for persisting graph state.
      * When provided, saves a checkpoint of the graph state at every superstep.
      * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.
      */
      checkpointer;
      /** Optional retry policy for handling failures in node execution */
      retryPolicy;
      /** The default configuration for graph execution, can be overridden on a per-invocation basis */
      config;
      /**
      * Optional long-term memory store for the graph, allows for persistence & retrieval of data across threads
      */
      store;
      /**
      * Optional cache for the graph, useful for caching tasks.
      */
      cache;
      /**
      * Optional interrupt helper function.
      * @internal
      */
      userInterrupt;
      /**
      * The trigger to node mapping for the graph run.
      * @internal
      */
      triggerToNodes = {};
      /**
      * Constructor for Pregel - meant for internal use only.
      *
      * @internal
      */
      constructor(fields) {
        super(fields);
        let { streamMode } = fields;
        if (streamMode != null && !Array.isArray(streamMode)) streamMode = [streamMode];
        this.nodes = fields.nodes;
        this.channels = fields.channels;
        if (TASKS2 in this.channels && "lc_graph_name" in this.channels[TASKS2] && this.channels[TASKS2].lc_graph_name !== "Topic") throw new Error(`Channel '${TASKS2}' is reserved and cannot be used in the graph.`);
        else this.channels[TASKS2] = new Topic({ accumulate: false });
        this.autoValidate = fields.autoValidate ?? this.autoValidate;
        this.streamMode = streamMode ?? this.streamMode;
        this.inputChannels = fields.inputChannels;
        this.outputChannels = fields.outputChannels;
        this.streamChannels = fields.streamChannels ?? this.streamChannels;
        this.interruptAfter = fields.interruptAfter;
        this.interruptBefore = fields.interruptBefore;
        this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;
        this.debug = fields.debug ?? this.debug;
        this.checkpointer = fields.checkpointer;
        this.retryPolicy = fields.retryPolicy;
        this.config = fields.config;
        this.store = fields.store;
        this.cache = fields.cache;
        this.name = fields.name;
        this.triggerToNodes = fields.triggerToNodes ?? this.triggerToNodes;
        this.userInterrupt = fields.userInterrupt;
        if (this.autoValidate) this.validate();
      }
      /**
      * Creates a new instance of the Pregel graph with updated configuration.
      * This method follows the immutable pattern - instead of modifying the current instance,
      * it returns a new instance with the merged configuration.
      *
      * @example
      * ```typescript
      * // Create a new instance with debug enabled
      * const debugGraph = graph.withConfig({ debug: true });
      *
      * // Create a new instance with a specific thread ID
      * const threadGraph = graph.withConfig({
      *   configurable: { thread_id: "123" }
      * });
      * ```
      *
      * @param config - The configuration to merge with the current configuration
      * @returns A new Pregel instance with the merged configuration
      */
      withConfig(config2) {
        const mergedConfig = mergeConfigs(this.config, config2);
        return new this.constructor({
          ...this,
          config: mergedConfig
        });
      }
      /**
      * Validates the graph structure to ensure it is well-formed.
      * Checks for:
      * - No orphaned nodes
      * - Valid input/output channel configurations
      * - Valid interrupt configurations
      *
      * @returns this - The Pregel instance for method chaining
      * @throws {GraphValidationError} If the graph structure is invalid
      */
      validate() {
        validateGraph({
          nodes: this.nodes,
          channels: this.channels,
          outputChannels: this.outputChannels,
          inputChannels: this.inputChannels,
          streamChannels: this.streamChannels,
          interruptAfterNodes: this.interruptAfter,
          interruptBeforeNodes: this.interruptBefore
        });
        for (const [name, node] of Object.entries(this.nodes)) for (const trigger of node.triggers) {
          this.triggerToNodes[trigger] ??= [];
          this.triggerToNodes[trigger].push(name);
        }
        return this;
      }
      /**
      * Gets a list of all channels that should be streamed.
      * If streamChannels is specified, returns those channels.
      * Otherwise, returns all channels in the graph.
      *
      * @returns Array of channel keys to stream
      */
      get streamChannelsList() {
        if (Array.isArray(this.streamChannels)) return this.streamChannels;
        else if (this.streamChannels) return [this.streamChannels];
        else return Object.keys(this.channels);
      }
      /**
      * Gets the channels to stream in their original format.
      * If streamChannels is specified, returns it as-is (either single key or array).
      * Otherwise, returns all channels in the graph as an array.
      *
      * @returns Channel keys to stream, either as a single key or array
      */
      get streamChannelsAsIs() {
        if (this.streamChannels) return this.streamChannels;
        else return Object.keys(this.channels);
      }
      /**
      * Gets a drawable representation of the graph structure.
      * This is an async version of getGraph() and is the preferred method to use.
      *
      * @param config - Configuration for generating the graph visualization
      * @returns A representation of the graph that can be visualized
      */
      async getGraphAsync(config2) {
        return this.getGraph(config2);
      }
      /**
      * Gets all subgraphs within this graph.
      * A subgraph is a Pregel instance that is nested within a node of this graph.
      *
      * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.
      * @param namespace - Optional namespace to filter subgraphs
      * @param recurse - Whether to recursively get subgraphs of subgraphs
      * @returns Generator yielding tuples of [name, subgraph]
      */
      *getSubgraphs(namespace, recurse) {
        for (const [name, node] of Object.entries(this.nodes)) {
          if (namespace !== void 0) {
            if (!namespace.startsWith(name)) continue;
          }
          const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];
          for (const candidate of candidates) {
            const graph = findSubgraphPregel(candidate);
            if (graph !== void 0) {
              if (name === namespace) {
                yield [name, graph];
                return;
              }
              if (namespace === void 0) yield [name, graph];
              if (recurse) {
                let newNamespace = namespace;
                if (namespace !== void 0) newNamespace = namespace.slice(name.length + 1);
                for (const [subgraphName, subgraph] of graph.getSubgraphs(newNamespace, recurse)) yield [`${name}${CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`, subgraph];
              }
            }
          }
        }
      }
      /**
      * Gets all subgraphs within this graph asynchronously.
      * A subgraph is a Pregel instance that is nested within a node of this graph.
      *
      * @param namespace - Optional namespace to filter subgraphs
      * @param recurse - Whether to recursively get subgraphs of subgraphs
      * @returns AsyncGenerator yielding tuples of [name, subgraph]
      */
      async *getSubgraphsAsync(namespace, recurse) {
        yield* this.getSubgraphs(namespace, recurse);
      }
      /**
      * Prepares a state snapshot from saved checkpoint data.
      * This is an internal method used by getState and getStateHistory.
      *
      * @param config - Configuration for preparing the snapshot
      * @param saved - Optional saved checkpoint data
      * @param subgraphCheckpointer - Optional checkpointer for subgraphs
      * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels
      * @returns A snapshot of the graph state
      * @internal
      */
      async _prepareStateSnapshot({ config: config2, saved, subgraphCheckpointer, applyPendingWrites = false }) {
        if (saved === void 0) return {
          values: {},
          next: [],
          config: config2,
          tasks: []
        };
        const channels = emptyChannels(this.channels, saved.checkpoint);
        if (saved.pendingWrites?.length) {
          const nullWrites = saved.pendingWrites.filter(([taskId, _]) => taskId === NULL_TASK_ID).map(([_, channel, value]) => [String(channel), value]);
          if (nullWrites.length > 0) _applyWrites(saved.checkpoint, channels, [{
            name: INPUT,
            writes: nullWrites,
            triggers: []
          }], void 0, this.triggerToNodes);
        }
        const nextTasks = Object.values(_prepareNextTasks(saved.checkpoint, saved.pendingWrites, this.nodes, channels, saved.config, true, {
          step: (saved.metadata?.step ?? -1) + 1,
          store: this.store
        }));
        const subgraphs = await gatherIterator(this.getSubgraphsAsync());
        const parentNamespace = saved.config.configurable?.checkpoint_ns ?? "";
        const taskStates = {};
        for (const task2 of nextTasks) {
          const matchingSubgraph = subgraphs.find(([name]) => name === task2.name);
          if (!matchingSubgraph) continue;
          let taskNs = `${String(task2.name)}${CHECKPOINT_NAMESPACE_END}${task2.id}`;
          if (parentNamespace) taskNs = `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;
          if (subgraphCheckpointer === void 0) {
            const config3 = { configurable: {
              thread_id: saved.config.configurable?.thread_id,
              checkpoint_ns: taskNs
            } };
            taskStates[task2.id] = config3;
          } else {
            const subgraphConfig = { configurable: {
              [CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,
              thread_id: saved.config.configurable?.thread_id,
              checkpoint_ns: taskNs
            } };
            const pregel = matchingSubgraph[1];
            taskStates[task2.id] = await pregel.getState(subgraphConfig, { subgraphs: true });
          }
        }
        if (applyPendingWrites && saved.pendingWrites?.length) {
          const nextTaskById = Object.fromEntries(nextTasks.map((task2) => [task2.id, task2]));
          for (const [taskId, channel, value] of saved.pendingWrites) {
            if ([
              ERROR3,
              INTERRUPT2,
              SCHEDULED
            ].includes(channel)) continue;
            if (!(taskId in nextTaskById)) continue;
            nextTaskById[taskId].writes.push([String(channel), value]);
          }
          const tasksWithWrites2 = nextTasks.filter((task2) => task2.writes.length > 0);
          if (tasksWithWrites2.length > 0) _applyWrites(saved.checkpoint, channels, tasksWithWrites2, void 0, this.triggerToNodes);
        }
        let metadata = saved?.metadata;
        if (metadata && saved?.config?.configurable?.thread_id) metadata = {
          ...metadata,
          thread_id: saved.config.configurable.thread_id
        };
        const nextList = nextTasks.filter((task2) => task2.writes.length === 0).map((task2) => task2.name);
        return {
          values: readChannels(channels, this.streamChannelsAsIs),
          next: nextList,
          tasks: tasksWithWrites(nextTasks, saved?.pendingWrites ?? [], taskStates, this.streamChannelsAsIs),
          metadata,
          config: patchCheckpointMap(saved.config, saved.metadata),
          createdAt: saved.checkpoint.ts,
          parentConfig: saved.parentConfig
        };
      }
      /**
      * Gets the current state of the graph.
      * Requires a checkpointer to be configured.
      *
      * @param config - Configuration for retrieving the state
      * @param options - Additional options
      * @returns A snapshot of the current graph state
      * @throws {GraphValueError} If no checkpointer is configured
      */
      async getState(config2, options) {
        const checkpointer = config2.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;
        if (!checkpointer) throw new GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
        const checkpointNamespace = config2.configurable?.checkpoint_ns ?? "";
        if (checkpointNamespace !== "" && config2.configurable?.[CONFIG_KEY_CHECKPOINTER] === void 0) {
          const recastNamespace = recastCheckpointNamespace(checkpointNamespace);
          for await (const [name, subgraph] of this.getSubgraphsAsync(recastNamespace, true)) if (name === recastNamespace) return await subgraph.getState(patchConfigurable(config2, { [CONFIG_KEY_CHECKPOINTER]: checkpointer }), { subgraphs: options?.subgraphs });
          throw new Error(`Subgraph with namespace "${recastNamespace}" not found.`);
        }
        const mergedConfig = mergeConfigs(this.config, config2);
        const saved = await checkpointer.getTuple(config2);
        return await this._prepareStateSnapshot({
          config: mergedConfig,
          saved,
          subgraphCheckpointer: options?.subgraphs ? checkpointer : void 0,
          applyPendingWrites: !config2.configurable?.checkpoint_id
        });
      }
      /**
      * Gets the history of graph states.
      * Requires a checkpointer to be configured.
      * Useful for:
      * - Debugging execution history
      * - Implementing time travel
      * - Analyzing graph behavior
      *
      * @param config - Configuration for retrieving the history
      * @param options - Options for filtering the history
      * @returns An async iterator of state snapshots
      * @throws {Error} If no checkpointer is configured
      */
      async *getStateHistory(config2, options) {
        const checkpointer = config2.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;
        if (!checkpointer) throw new GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
        const checkpointNamespace = config2.configurable?.checkpoint_ns ?? "";
        if (checkpointNamespace !== "" && config2.configurable?.[CONFIG_KEY_CHECKPOINTER] === void 0) {
          const recastNamespace = recastCheckpointNamespace(checkpointNamespace);
          for await (const [name, pregel] of this.getSubgraphsAsync(recastNamespace, true)) if (name === recastNamespace) {
            yield* pregel.getStateHistory(patchConfigurable(config2, { [CONFIG_KEY_CHECKPOINTER]: checkpointer }), options);
            return;
          }
          throw new Error(`Subgraph with namespace "${recastNamespace}" not found.`);
        }
        const mergedConfig = mergeConfigs(this.config, config2, { configurable: { checkpoint_ns: checkpointNamespace } });
        for await (const checkpointTuple of checkpointer.list(mergedConfig, options)) yield this._prepareStateSnapshot({
          config: checkpointTuple.config,
          saved: checkpointTuple
        });
      }
      /**
      * Apply updates to the graph state in bulk.
      * Requires a checkpointer to be configured.
      *
      * This method is useful for recreating a thread
      * from a list of updates, especially if a checkpoint
      * is created as a result of multiple tasks.
      *
      * @internal The API might change in the future.
      *
      * @param startConfig - Configuration for the update
      * @param updates - The list of updates to apply to graph state
      * @returns Updated configuration
      * @throws {GraphValueError} If no checkpointer is configured
      * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.
      */
      async bulkUpdateState(startConfig, supersteps) {
        const checkpointer = startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;
        if (!checkpointer) throw new GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
        if (supersteps.length === 0) throw new Error("No supersteps provided");
        if (supersteps.some((s) => s.updates.length === 0)) throw new Error("No updates provided");
        const checkpointNamespace = startConfig.configurable?.checkpoint_ns ?? "";
        if (checkpointNamespace !== "" && startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] === void 0) {
          const recastNamespace = recastCheckpointNamespace(checkpointNamespace);
          for await (const [, pregel] of this.getSubgraphsAsync(recastNamespace, true)) return await pregel.bulkUpdateState(patchConfigurable(startConfig, { [CONFIG_KEY_CHECKPOINTER]: checkpointer }), supersteps);
          throw new Error(`Subgraph "${recastNamespace}" not found`);
        }
        const updateSuperStep = async (inputConfig, updates) => {
          const config2 = this.config ? mergeConfigs(this.config, inputConfig) : inputConfig;
          const saved = await checkpointer.getTuple(config2);
          const checkpoint = saved !== void 0 ? copyCheckpoint(saved.checkpoint) : emptyCheckpoint();
          const checkpointPreviousVersions = { ...saved?.checkpoint.channel_versions };
          const step = saved?.metadata?.step ?? -1;
          let checkpointConfig = patchConfigurable(config2, { checkpoint_ns: config2.configurable?.checkpoint_ns ?? "" });
          let checkpointMetadata = config2.metadata ?? {};
          if (saved?.config.configurable) {
            checkpointConfig = patchConfigurable(config2, saved.config.configurable);
            checkpointMetadata = {
              ...saved.metadata,
              ...checkpointMetadata
            };
          }
          const { values, asNode } = updates[0];
          if (values == null && asNode === void 0) {
            if (updates.length > 1) throw new InvalidUpdateError(`Cannot create empty checkpoint with multiple updates`);
            return patchCheckpointMap(await checkpointer.put(checkpointConfig, createCheckpoint(checkpoint, void 0, step), {
              source: "update",
              step: step + 1,
              parents: saved?.metadata?.parents ?? {}
            }, {}), saved ? saved.metadata : void 0);
          }
          const channels = emptyChannels(this.channels, checkpoint);
          if (values === null && asNode === END) {
            if (updates.length > 1) throw new InvalidUpdateError(`Cannot apply multiple updates when clearing state`);
            if (saved) {
              const nextTasks = _prepareNextTasks(checkpoint, saved.pendingWrites || [], this.nodes, channels, saved.config, true, {
                step: (saved.metadata?.step ?? -1) + 1,
                checkpointer,
                store: this.store
              });
              const nullWrites = (saved.pendingWrites || []).filter((w) => w[0] === NULL_TASK_ID).map((w) => w.slice(1));
              if (nullWrites.length > 0) _applyWrites(checkpoint, channels, [{
                name: INPUT,
                writes: nullWrites,
                triggers: []
              }], checkpointer.getNextVersion.bind(checkpointer), this.triggerToNodes);
              for (const [taskId, k, v] of saved.pendingWrites || []) {
                if ([
                  ERROR3,
                  INTERRUPT2,
                  SCHEDULED
                ].includes(k)) continue;
                if (!(taskId in nextTasks)) continue;
                nextTasks[taskId].writes.push([k, v]);
              }
              _applyWrites(checkpoint, channels, Object.values(nextTasks), checkpointer.getNextVersion.bind(checkpointer), this.triggerToNodes);
            }
            return patchCheckpointMap(await checkpointer.put(checkpointConfig, createCheckpoint(checkpoint, channels, step), {
              ...checkpointMetadata,
              source: "update",
              step: step + 1,
              parents: saved?.metadata?.parents ?? {}
            }, getNewChannelVersions(checkpointPreviousVersions, checkpoint.channel_versions)), saved ? saved.metadata : void 0);
          }
          if (asNode === COPY) {
            if (updates.length > 1) throw new InvalidUpdateError(`Cannot copy checkpoint with multiple updates`);
            if (saved == null) throw new InvalidUpdateError(`Cannot copy a non-existent checkpoint`);
            const isCopyWithUpdates = (values2) => {
              if (!Array.isArray(values2)) return false;
              if (values2.length === 0) return false;
              return values2.every((v) => Array.isArray(v) && v.length === 2);
            };
            const nextCheckpoint = createCheckpoint(checkpoint, void 0, step);
            const nextConfig2 = await checkpointer.put(saved.parentConfig ?? patchConfigurable(saved.config, { checkpoint_id: void 0 }), nextCheckpoint, {
              source: "fork",
              step: step + 1,
              parents: saved.metadata?.parents ?? {}
            }, {});
            if (isCopyWithUpdates(values)) {
              const nextTasks = _prepareNextTasks(nextCheckpoint, saved.pendingWrites, this.nodes, channels, nextConfig2, false, { step: step + 2 });
              const tasksGroupBy = Object.values(nextTasks).reduce((acc, { name, id }) => {
                acc[name] ??= [];
                acc[name].push({ id });
                return acc;
              }, {});
              const userGroupBy = values.reduce((acc, item) => {
                const [values2, asNode2] = item;
                acc[asNode2] ??= [];
                const targetIdx = acc[asNode2].length;
                const taskId = tasksGroupBy[asNode2]?.[targetIdx]?.id;
                acc[asNode2].push({
                  values: values2,
                  asNode: asNode2,
                  taskId
                });
                return acc;
              }, {});
              return updateSuperStep(patchCheckpointMap(nextConfig2, saved.metadata), Object.values(userGroupBy).flat());
            }
            return patchCheckpointMap(nextConfig2, saved.metadata);
          }
          if (asNode === INPUT) {
            if (updates.length > 1) throw new InvalidUpdateError(`Cannot apply multiple updates when updating as input`);
            const inputWrites = await gatherIterator(mapInput(this.inputChannels, values));
            if (inputWrites.length === 0) throw new InvalidUpdateError(`Received no input writes for ${JSON.stringify(this.inputChannels, null, 2)}`);
            _applyWrites(checkpoint, channels, [{
              name: INPUT,
              writes: inputWrites,
              triggers: []
            }], checkpointer.getNextVersion.bind(this.checkpointer), this.triggerToNodes);
            const nextStep = saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;
            const nextConfig2 = await checkpointer.put(checkpointConfig, createCheckpoint(checkpoint, channels, nextStep), {
              source: "input",
              step: nextStep,
              parents: saved?.metadata?.parents ?? {}
            }, getNewChannelVersions(checkpointPreviousVersions, checkpoint.channel_versions));
            await checkpointer.putWrites(nextConfig2, inputWrites, uuid5(INPUT, checkpoint.id));
            return patchCheckpointMap(nextConfig2, saved ? saved.metadata : void 0);
          }
          if (config2.configurable?.checkpoint_id === void 0 && saved?.pendingWrites !== void 0 && saved.pendingWrites.length > 0) {
            const nextTasks = _prepareNextTasks(checkpoint, saved.pendingWrites, this.nodes, channels, saved.config, true, {
              store: this.store,
              checkpointer: this.checkpointer,
              step: (saved.metadata?.step ?? -1) + 1
            });
            const nullWrites = (saved.pendingWrites ?? []).filter((w) => w[0] === NULL_TASK_ID).map((w) => w.slice(1));
            if (nullWrites.length > 0) _applyWrites(saved.checkpoint, channels, [{
              name: INPUT,
              writes: nullWrites,
              triggers: []
            }], void 0, this.triggerToNodes);
            for (const [tid, k, v] of saved.pendingWrites) {
              if ([
                ERROR3,
                INTERRUPT2,
                SCHEDULED
              ].includes(k) || nextTasks[tid] === void 0) continue;
              nextTasks[tid].writes.push([k, v]);
            }
            const tasks2 = Object.values(nextTasks).filter((task2) => {
              return task2.writes.length > 0;
            });
            if (tasks2.length > 0) _applyWrites(checkpoint, channels, tasks2, void 0, this.triggerToNodes);
          }
          const nonNullVersion = Object.values(checkpoint.versions_seen).map((seenVersions) => {
            return Object.values(seenVersions);
          }).flat().find((v) => !!v);
          const validUpdates = [];
          if (updates.length === 1) {
            let { values: values2, asNode: asNode2, taskId } = updates[0];
            if (asNode2 === void 0 && Object.keys(this.nodes).length === 1) [asNode2] = Object.keys(this.nodes);
            else if (asNode2 === void 0 && nonNullVersion === void 0) {
              if (typeof this.inputChannels === "string" && this.nodes[this.inputChannels] !== void 0) asNode2 = this.inputChannels;
            } else if (asNode2 === void 0) {
              const lastSeenByNode = Object.entries(checkpoint.versions_seen).map(([n2, seen]) => {
                return Object.values(seen).map((v) => {
                  return [v, n2];
                });
              }).flat().filter(([_, v]) => v !== INTERRUPT2).sort(([aNumber], [bNumber]) => compareChannelVersions(aNumber, bNumber));
              if (lastSeenByNode) {
                if (lastSeenByNode.length === 1) asNode2 = lastSeenByNode[0][1];
                else if (lastSeenByNode[lastSeenByNode.length - 1][0] !== lastSeenByNode[lastSeenByNode.length - 2][0]) asNode2 = lastSeenByNode[lastSeenByNode.length - 1][1];
              }
            }
            if (asNode2 === void 0) throw new InvalidUpdateError(`Ambiguous update, specify "asNode"`);
            validUpdates.push({
              values: values2,
              asNode: asNode2,
              taskId
            });
          } else for (const { asNode: asNode2, values: values2, taskId } of updates) {
            if (asNode2 == null) throw new InvalidUpdateError(`"asNode" is required when applying multiple updates`);
            validUpdates.push({
              values: values2,
              asNode: asNode2,
              taskId
            });
          }
          const tasks = [];
          for (const { asNode: asNode2, values: values2, taskId } of validUpdates) {
            if (this.nodes[asNode2] === void 0) throw new InvalidUpdateError(`Node "${asNode2.toString()}" does not exist`);
            const writers = this.nodes[asNode2].getWriters();
            if (!writers.length) throw new InvalidUpdateError(`No writers found for node "${asNode2.toString()}"`);
            tasks.push({
              name: asNode2,
              input: values2,
              proc: writers.length > 1 ? RunnableSequence.from(writers, { omitSequenceTags: true }) : writers[0],
              writes: [],
              triggers: [INTERRUPT2],
              id: taskId ?? uuid5(INTERRUPT2, checkpoint.id),
              writers: []
            });
          }
          for (const task2 of tasks) await task2.proc.invoke(task2.input, patchConfig({
            ...config2,
            store: config2?.store ?? this.store
          }, {
            runName: config2.runName ?? `${this.getName()}UpdateState`,
            configurable: {
              [CONFIG_KEY_SEND]: (items) => task2.writes.push(...items),
              [CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, task2, select_, fresh_)
            }
          }));
          for (const task2 of tasks) {
            const channelWrites = task2.writes.filter((w) => w[0] !== PUSH);
            if (saved !== void 0 && channelWrites.length > 0) await checkpointer.putWrites(checkpointConfig, channelWrites, task2.id);
          }
          _applyWrites(checkpoint, channels, tasks, checkpointer.getNextVersion.bind(this.checkpointer), this.triggerToNodes);
          const newVersions = getNewChannelVersions(checkpointPreviousVersions, checkpoint.channel_versions);
          const nextConfig = await checkpointer.put(checkpointConfig, createCheckpoint(checkpoint, channels, step + 1), {
            source: "update",
            step: step + 1,
            parents: saved?.metadata?.parents ?? {}
          }, newVersions);
          for (const task2 of tasks) {
            const pushWrites = task2.writes.filter((w) => w[0] === PUSH);
            if (pushWrites.length > 0) await checkpointer.putWrites(nextConfig, pushWrites, task2.id);
          }
          return patchCheckpointMap(nextConfig, saved ? saved.metadata : void 0);
        };
        let currentConfig = startConfig;
        for (const { updates } of supersteps) currentConfig = await updateSuperStep(currentConfig, updates);
        return currentConfig;
      }
      /**
      * Updates the state of the graph with new values.
      * Requires a checkpointer to be configured.
      *
      * This method can be used for:
      * - Implementing human-in-the-loop workflows
      * - Modifying graph state during breakpoints
      * - Integrating external inputs into the graph
      *
      * @param inputConfig - Configuration for the update
      * @param values - The values to update the state with
      * @param asNode - Optional node name to attribute the update to
      * @returns Updated configuration
      * @throws {GraphValueError} If no checkpointer is configured
      * @throws {InvalidUpdateError} If the update cannot be attributed to a node
      */
      async updateState(inputConfig, values, asNode) {
        return this.bulkUpdateState(inputConfig, [{ updates: [{
          values,
          asNode
        }] }]);
      }
      /**
      * Gets the default values for various graph configuration options.
      * This is an internal method used to process and normalize configuration options.
      *
      * @param config - The input configuration options
      * @returns A tuple containing normalized values for:
      * - debug mode
      * - stream modes
      * - input keys
      * - output keys
      * - remaining config
      * - interrupt before nodes
      * - interrupt after nodes
      * - checkpointer
      * - store
      * - whether stream mode is single
      * - node cache
      * - whether checkpoint during is enabled
      * @internal
      */
      _defaults(config2) {
        const { debug, streamMode, inputKeys, outputKeys, interruptAfter, interruptBefore, ...rest } = config2;
        let streamModeSingle = true;
        const defaultDebug = debug !== void 0 ? debug : this.debug;
        let defaultOutputKeys = outputKeys;
        if (defaultOutputKeys === void 0) defaultOutputKeys = this.streamChannelsAsIs;
        else validateKeys(defaultOutputKeys, this.channels);
        let defaultInputKeys = inputKeys;
        if (defaultInputKeys === void 0) defaultInputKeys = this.inputChannels;
        else validateKeys(defaultInputKeys, this.channels);
        const defaultInterruptBefore = interruptBefore ?? this.interruptBefore ?? [];
        const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];
        let defaultStreamMode;
        if (streamMode !== void 0) {
          defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];
          streamModeSingle = typeof streamMode === "string";
        } else {
          if (config2.configurable?.[CONFIG_KEY_TASK_ID] !== void 0) defaultStreamMode = ["values"];
          else defaultStreamMode = this.streamMode;
          streamModeSingle = true;
        }
        let defaultCheckpointer;
        if (this.checkpointer === false) defaultCheckpointer = void 0;
        else if (config2 !== void 0 && config2.configurable?.[CONFIG_KEY_CHECKPOINTER] !== void 0) defaultCheckpointer = config2.configurable[CONFIG_KEY_CHECKPOINTER];
        else if (this.checkpointer === true) throw new Error("checkpointer: true cannot be used for root graphs.");
        else defaultCheckpointer = this.checkpointer;
        const defaultStore = config2.store ?? this.store;
        const defaultCache = config2.cache ?? this.cache;
        if (config2.durability != null && config2.checkpointDuring != null) throw new Error("Cannot use both `durability` and `checkpointDuring` at the same time.");
        const checkpointDuringDurability = (() => {
          if (config2.checkpointDuring == null) return void 0;
          if (config2.checkpointDuring === false) return "exit";
          return "async";
        })();
        const defaultDurability = config2.durability ?? checkpointDuringDurability ?? config2?.configurable?.[CONFIG_KEY_DURABILITY] ?? "async";
        return [
          defaultDebug,
          defaultStreamMode,
          defaultInputKeys,
          defaultOutputKeys,
          rest,
          defaultInterruptBefore,
          defaultInterruptAfter,
          defaultCheckpointer,
          defaultStore,
          streamModeSingle,
          defaultCache,
          defaultDurability
        ];
      }
      /**
      * Streams the execution of the graph, emitting state updates as they occur.
      * This is the primary method for observing graph execution in real-time.
      *
      * Stream modes:
      * - "values": Emits complete state after each step
      * - "updates": Emits only state changes after each step
      * - "debug": Emits detailed debug information
      * - "messages": Emits messages from within nodes
      * - "custom": Emits custom events from within nodes
      * - "checkpoints": Emits checkpoints from within nodes
      * - "tasks": Emits tasks from within nodes
      *
      * @param input - The input to start graph execution with
      * @param options - Configuration options for streaming
      * @returns An async iterable stream of graph state updates
      */
      async stream(input, options) {
        const abortController = new AbortController();
        const config2 = {
          recursionLimit: this.config?.recursionLimit,
          ...options,
          signal: combineAbortSignals(options?.signal, abortController.signal).signal
        };
        const stream = await super.stream(input, config2);
        return new IterableReadableStreamWithAbortSignal(options?.encoding === "text/event-stream" ? toEventStream(stream) : stream, abortController);
      }
      streamEvents(input, options, streamOptions) {
        const abortController = new AbortController();
        const config2 = {
          recursionLimit: this.config?.recursionLimit,
          ...options,
          callbacks: combineCallbacks(this.config?.callbacks, options?.callbacks),
          signal: combineAbortSignals(options?.signal, abortController.signal).signal
        };
        return new IterableReadableStreamWithAbortSignal(super.streamEvents(input, config2, streamOptions), abortController);
      }
      /**
      * Validates the input for the graph.
      * @param input - The input to validate
      * @returns The validated input
      * @internal
      */
      async _validateInput(input) {
        return input;
      }
      /**
      * Validates the context options for the graph.
      * @param context - The context options to validate
      * @returns The validated context options
      * @internal
      */
      async _validateContext(context2) {
        return context2;
      }
      /**
      * Internal iterator used by stream() to generate state updates.
      * This method handles the core logic of graph execution and streaming.
      *
      * @param input - The input to start graph execution with
      * @param options - Configuration options for streaming
      * @returns AsyncGenerator yielding state updates
      * @internal
      */
      async *_streamIterator(input, options) {
        const streamEncoding = "version" in (options ?? {}) ? void 0 : options?.encoding ?? void 0;
        const streamSubgraphs = options?.subgraphs;
        const inputConfig = ensureLangGraphConfig(this.config, options);
        if (inputConfig.recursionLimit === void 0 || inputConfig.recursionLimit < 1) throw new Error(`Passed "recursionLimit" must be at least 1.`);
        if (this.checkpointer !== void 0 && this.checkpointer !== false && inputConfig.configurable === void 0) throw new Error(`Checkpointer requires one or more of the following "configurable" keys: "thread_id", "checkpoint_ns", "checkpoint_id"`);
        const validInput = await this._validateInput(input);
        const { runId, ...restConfig } = inputConfig;
        const [debug, streamMode, , outputKeys, config2, interruptBefore, interruptAfter, checkpointer, store, streamModeSingle, cache2, durability] = this._defaults(restConfig);
        if (typeof config2.context !== "undefined") config2.context = await this._validateContext(config2.context);
        else config2.configurable = await this._validateContext(config2.configurable);
        const stream = new IterableReadableWritableStream({ modes: new Set(streamMode) });
        if (this.checkpointer === true) {
          config2.configurable ??= {};
          const ns = config2.configurable[CONFIG_KEY_CHECKPOINT_NS] ?? "";
          config2.configurable[CONFIG_KEY_CHECKPOINT_NS] = ns.split(CHECKPOINT_NAMESPACE_SEPARATOR).map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0]).join(CHECKPOINT_NAMESPACE_SEPARATOR);
        }
        if (streamMode.includes("messages")) {
          const messageStreamer = new StreamMessagesHandler((chunk) => stream.push(chunk));
          const { callbacks } = config2;
          if (callbacks === void 0) config2.callbacks = [messageStreamer];
          else if (Array.isArray(callbacks)) config2.callbacks = callbacks.concat(messageStreamer);
          else {
            const copiedCallbacks = callbacks.copy();
            copiedCallbacks.addHandler(messageStreamer, true);
            config2.callbacks = copiedCallbacks;
          }
        }
        config2.writer ??= (chunk) => {
          if (!streamMode.includes("custom")) return;
          const ns = getConfig()?.configurable?.[CONFIG_KEY_CHECKPOINT_NS]?.split(CHECKPOINT_NAMESPACE_SEPARATOR).slice(0, -1);
          stream.push([
            ns ?? [],
            "custom",
            chunk
          ]);
        };
        config2.interrupt ??= this.userInterrupt ?? interrupt;
        const runManager = await (await getCallbackManagerForConfig(config2))?.handleChainStart(this.toJSON(), _coerceToDict3(input, "input"), runId, void 0, void 0, void 0, config2?.runName ?? this.getName());
        const channelSpecs = getOnlyChannels(this.channels);
        let loop;
        let loopError;
        const createAndRunLoop = async () => {
          try {
            loop = await PregelLoop.initialize({
              input: validInput,
              config: config2,
              checkpointer,
              nodes: this.nodes,
              channelSpecs,
              outputKeys,
              streamKeys: this.streamChannelsAsIs,
              store,
              cache: cache2,
              stream,
              interruptAfter,
              interruptBefore,
              manager: runManager,
              debug: this.debug,
              triggerToNodes: this.triggerToNodes,
              durability
            });
            const runner = new PregelRunner({
              loop,
              nodeFinished: config2.configurable?.[CONFIG_KEY_NODE_FINISHED]
            });
            if (options?.subgraphs) loop.config.configurable = {
              ...loop.config.configurable,
              [CONFIG_KEY_STREAM]: loop.stream
            };
            await this._runLoop({
              loop,
              runner,
              debug,
              config: config2
            });
            if (durability === "sync") await Promise.all(loop?.checkpointerPromises ?? []);
          } catch (e) {
            loopError = e;
          } finally {
            try {
              if (loop) {
                await loop.store?.stop();
                await loop.cache?.stop();
              }
              await Promise.all(loop?.checkpointerPromises ?? []);
            } catch (e) {
              loopError = loopError ?? e;
            }
            if (loopError) stream.error(loopError);
            else stream.close();
          }
        };
        const runLoopPromise = createAndRunLoop();
        try {
          for await (const chunk of stream) {
            if (chunk === void 0) throw new Error("Data structure error.");
            const [namespace, mode, payload] = chunk;
            if (streamMode.includes(mode)) {
              if (streamEncoding === "text/event-stream") {
                if (streamSubgraphs) yield [
                  namespace,
                  mode,
                  payload
                ];
                else yield [
                  null,
                  mode,
                  payload
                ];
                continue;
              }
              if (streamSubgraphs && !streamModeSingle) yield [
                namespace,
                mode,
                payload
              ];
              else if (!streamModeSingle) yield [mode, payload];
              else if (streamSubgraphs) yield [namespace, payload];
              else yield payload;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(loopError);
          throw e;
        } finally {
          await runLoopPromise;
        }
        await runManager?.handleChainEnd(loop?.output ?? {}, runId, void 0, void 0, void 0);
      }
      /**
      * Run the graph with a single input and config.
      * @param input The input to the graph.
      * @param options The configuration to use for the run.
      */
      async invoke(input, options) {
        const streamMode = options?.streamMode ?? "values";
        const config2 = {
          ...options,
          outputKeys: options?.outputKeys ?? this.outputChannels,
          streamMode,
          encoding: void 0
        };
        const chunks = [];
        const stream = await this.stream(input, config2);
        const interruptChunks = [];
        let latest;
        for await (const chunk of stream) if (streamMode === "values") if (isInterrupted(chunk)) interruptChunks.push(chunk[INTERRUPT2]);
        else latest = chunk;
        else chunks.push(chunk);
        if (streamMode === "values") {
          if (interruptChunks.length > 0) {
            const interrupts = interruptChunks.flat(1);
            if (latest == null) return { [INTERRUPT2]: interrupts };
            if (typeof latest === "object") return {
              ...latest,
              [INTERRUPT2]: interrupts
            };
          }
          return latest;
        }
        return chunks;
      }
      async _runLoop(params) {
        const { loop, runner, debug, config: config2 } = params;
        let tickError;
        try {
          while (await loop.tick({ inputKeys: this.inputChannels })) {
            for (const { task: task2 } of await loop._matchCachedWrites()) loop._outputWrites(task2.id, task2.writes, true);
            if (debug) printStepCheckpoint(loop.checkpointMetadata.step, loop.channels, this.streamChannelsList);
            if (debug) printStepTasks(loop.step, Object.values(loop.tasks));
            await runner.tick({
              timeout: this.stepTimeout,
              retryPolicy: this.retryPolicy,
              onStepWrite: (step, writes) => {
                if (debug) printStepWrites(step, writes, this.streamChannelsList);
              },
              maxConcurrency: config2.maxConcurrency,
              signal: config2.signal
            });
          }
          if (loop.status === "out_of_steps") throw new GraphRecursionError([
            `Recursion limit of ${config2.recursionLimit} reached`,
            "without hitting a stop condition. You can increase the",
            `limit by setting the "recursionLimit" config key.`
          ].join(" "), { lc_error_code: "GRAPH_RECURSION_LIMIT" });
        } catch (e) {
          tickError = e;
          if (!await loop.finishAndHandleError(tickError)) throw e;
        } finally {
          if (tickError === void 0) await loop.finishAndHandleError();
        }
      }
      async clearCache() {
        await this.cache?.clear([]);
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js
var EphemeralValue;
var init_ephemeral_value = __esm({
  "node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js"() {
    init_errors3();
    init_base15();
    EphemeralValue = class EphemeralValue2 extends BaseChannel {
      lc_graph_name = "EphemeralValue";
      guard;
      value = [];
      constructor(guard = true) {
        super();
        this.guard = guard;
      }
      fromCheckpoint(checkpoint) {
        const empty = new EphemeralValue2(this.guard);
        if (typeof checkpoint !== "undefined") empty.value = [checkpoint];
        return empty;
      }
      update(values) {
        if (values.length === 0) {
          const updated = this.value.length > 0;
          this.value = [];
          return updated;
        }
        if (values.length !== 1 && this.guard) throw new InvalidUpdateError("EphemeralValue can only receive one value per step.");
        this.value = [values[values.length - 1]];
        return true;
      }
      get() {
        if (this.value.length === 0) throw new EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) throw new EmptyChannelError();
        return this.value[0];
      }
      isAvailable() {
        return this.value.length !== 0;
      }
    };
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/regex.js
var regex_default4;
var init_regex4 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default4 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js
function validate6(uuid8) {
  return typeof uuid8 === "string" && regex_default4.test(uuid8);
}
var validate_default4;
var init_validate6 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex4();
    validate_default4 = validate6;
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify4(arr3, offset = 0) {
  return (byteToHex4[arr3[offset + 0]] + byteToHex4[arr3[offset + 1]] + byteToHex4[arr3[offset + 2]] + byteToHex4[arr3[offset + 3]] + "-" + byteToHex4[arr3[offset + 4]] + byteToHex4[arr3[offset + 5]] + "-" + byteToHex4[arr3[offset + 6]] + byteToHex4[arr3[offset + 7]] + "-" + byteToHex4[arr3[offset + 8]] + byteToHex4[arr3[offset + 9]] + "-" + byteToHex4[arr3[offset + 10]] + byteToHex4[arr3[offset + 11]] + byteToHex4[arr3[offset + 12]] + byteToHex4[arr3[offset + 13]] + byteToHex4[arr3[offset + 14]] + byteToHex4[arr3[offset + 15]]).toLowerCase();
}
var byteToHex4;
var init_stringify4 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/stringify.js"() {
    byteToHex4 = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex4.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/rng.js
import crypto10 from "node:crypto";
function rng4() {
  if (poolPtr4 > rnds8Pool4.length - 16) {
    crypto10.randomFillSync(rnds8Pool4);
    poolPtr4 = 0;
  }
  return rnds8Pool4.slice(poolPtr4, poolPtr4 += 16);
}
var rnds8Pool4, poolPtr4;
var init_rng4 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool4 = new Uint8Array(256);
    poolPtr4 = rnds8Pool4.length;
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/native.js
import crypto11 from "node:crypto";
var native_default3;
var init_native3 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/native.js"() {
    native_default3 = {
      randomUUID: crypto11.randomUUID
    };
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/v4.js
function v43(options, buf, offset) {
  if (native_default3.randomUUID && !buf && !options) {
    return native_default3.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng4)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify4(rnds);
}
var v4_default3;
var init_v44 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/v4.js"() {
    init_native3();
    init_rng4();
    init_stringify4();
    v4_default3 = v43;
  }
});

// node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/index.js
var init_esm_node4 = __esm({
  "node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/index.js"() {
    init_v44();
    init_validate6();
  }
});

// node_modules/@langchain/langgraph/dist/graph/graph.js
function isCompiledGraph(x) {
  return typeof x.attachNode === "function" && typeof x.attachEdge === "function";
}
function _escapeMermaidKeywords(key) {
  if (key === "subgraph") return `"${key}"`;
  return key;
}
var Branch, Graph$1, CompiledGraph;
var init_graph2 = __esm({
  "node_modules/@langchain/langgraph/dist/graph/graph.js"() {
    init_errors3();
    init_constants3();
    init_utils8();
    init_write();
    init_read();
    init_subgraph();
    init_pregel();
    init_ephemeral_value();
    init_runnables();
    init_graph();
    init_v43();
    init_esm_node4();
    Branch = class {
      path;
      ends;
      constructor(options) {
        if (Runnable.isRunnable(options.path)) this.path = options.path;
        else this.path = _coerceToRunnable(options.path).withConfig({ runName: `Branch` });
        this.ends = Array.isArray(options.pathMap) ? options.pathMap.reduce((acc, n2) => {
          acc[n2] = n2;
          return acc;
        }, {}) : options.pathMap;
      }
      run(writer2, reader) {
        return ChannelWrite.registerWriter(new RunnableCallable({
          name: "<branch_run>",
          trace: false,
          func: async (input, config2) => {
            try {
              return await this._route(input, config2, writer2, reader);
            } catch (e) {
              if (e.name === NodeInterrupt.unminifiable_name) console.warn("[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\nNodeInterrupt should only be thrown inside a node, not in edge conditions.");
              throw e;
            }
          }
        }));
      }
      async _route(input, config2, writer2, reader) {
        let result = await this.path.invoke(reader ? reader(config2) : input, config2);
        if (!Array.isArray(result)) result = [result];
        let destinations;
        if (this.ends) destinations = result.map((r) => _isSend(r) ? r : this.ends[r]);
        else destinations = result;
        if (destinations.some((dest) => !dest)) throw new Error("Branch condition returned unknown or null destination");
        if (destinations.filter(_isSend).some((packet) => packet.node === END)) throw new InvalidUpdateError("Cannot send a packet to the END node");
        return await writer2(destinations, config2) ?? input;
      }
    };
    Graph$1 = class {
      nodes;
      edges;
      branches;
      entryPoint;
      compiled = false;
      constructor() {
        this.nodes = {};
        this.edges = /* @__PURE__ */ new Set();
        this.branches = {};
      }
      warnIfCompiled(message) {
        if (this.compiled) console.warn(message);
      }
      get allEdges() {
        return this.edges;
      }
      addNode(...args) {
        function isMutlipleNodes(args2) {
          return args2.length >= 1 && typeof args2[0] !== "string";
        }
        const nodes = isMutlipleNodes(args) ? Array.isArray(args[0]) ? args[0] : Object.entries(args[0]) : [[
          args[0],
          args[1],
          args[2]
        ]];
        if (nodes.length === 0) throw new Error("No nodes provided in `addNode`");
        for (const [key, action, options] of nodes) {
          for (const reservedChar of [CHECKPOINT_NAMESPACE_SEPARATOR, CHECKPOINT_NAMESPACE_END]) if (key.includes(reservedChar)) throw new Error(`"${reservedChar}" is a reserved character and is not allowed in node names.`);
          this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
          if (key in this.nodes) throw new Error(`Node \`${key}\` already present.`);
          if (key === END) throw new Error(`Node \`${key}\` is reserved.`);
          const runnable = _coerceToRunnable(action);
          this.nodes[key] = {
            runnable,
            metadata: options?.metadata,
            subgraphs: isPregelLike(runnable) ? [runnable] : options?.subgraphs,
            ends: options?.ends
          };
        }
        return this;
      }
      addEdge(startKey, endKey) {
        this.warnIfCompiled(`Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
        if (startKey === END) throw new Error("END cannot be a start node");
        if (endKey === START) throw new Error("START cannot be an end node");
        if (Array.from(this.edges).some(([start]) => start === startKey) && !("channels" in this)) throw new Error(`Already found path for ${startKey}. For multiple edges, use StateGraph.`);
        this.edges.add([startKey, endKey]);
        return this;
      }
      addConditionalEdges(source, path3, pathMap) {
        const options = typeof source === "object" ? source : {
          source,
          path: path3,
          pathMap
        };
        this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
        if (!Runnable.isRunnable(options.path)) {
          const pathDisplayValues = Array.isArray(options.pathMap) ? options.pathMap.join(",") : Object.keys(options.pathMap ?? {}).join(",");
          options.path = _coerceToRunnable(options.path).withConfig({ runName: `Branch<${options.source}${pathDisplayValues !== "" ? `,${pathDisplayValues}` : ""}>`.slice(0, 63) });
        }
        const name = options.path.getName() === "RunnableLambda" ? "condition" : options.path.getName();
        if (this.branches[options.source] && this.branches[options.source][name]) throw new Error(`Condition \`${name}\` already present for node \`${source}\``);
        this.branches[options.source] ??= {};
        this.branches[options.source][name] = new Branch(options);
        return this;
      }
      /**
      * @deprecated use `addEdge(START, key)` instead
      */
      setEntryPoint(key) {
        this.warnIfCompiled("Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.");
        return this.addEdge(START, key);
      }
      /**
      * @deprecated use `addEdge(key, END)` instead
      */
      setFinishPoint(key) {
        this.warnIfCompiled("Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.");
        return this.addEdge(key, END);
      }
      compile({ checkpointer, interruptBefore, interruptAfter, name } = {}) {
        this.validate([...Array.isArray(interruptBefore) ? interruptBefore : [], ...Array.isArray(interruptAfter) ? interruptAfter : []]);
        const compiled = new CompiledGraph({
          builder: this,
          checkpointer,
          interruptAfter,
          interruptBefore,
          autoValidate: false,
          nodes: {},
          channels: {
            [START]: new EphemeralValue(),
            [END]: new EphemeralValue()
          },
          inputChannels: START,
          outputChannels: END,
          streamChannels: [],
          streamMode: "values",
          name
        });
        for (const [key, node] of Object.entries(this.nodes)) compiled.attachNode(key, node);
        for (const [start, end] of this.edges) compiled.attachEdge(start, end);
        for (const [start, branches] of Object.entries(this.branches)) for (const [name2, branch] of Object.entries(branches)) compiled.attachBranch(start, name2, branch);
        return compiled.validate();
      }
      validate(interrupt2) {
        const allSources = new Set([...this.allEdges].map(([src, _]) => src));
        for (const [start] of Object.entries(this.branches)) allSources.add(start);
        for (const source of allSources) if (source !== START && !(source in this.nodes)) throw new Error(`Found edge starting at unknown node \`${source}\``);
        const allTargets = new Set([...this.allEdges].map(([_, target]) => target));
        for (const [start, branches] of Object.entries(this.branches)) for (const branch of Object.values(branches)) if (branch.ends != null) for (const end of Object.values(branch.ends)) allTargets.add(end);
        else {
          allTargets.add(END);
          for (const node of Object.keys(this.nodes)) if (node !== start) allTargets.add(node);
        }
        for (const node of Object.values(this.nodes)) for (const target of node.ends ?? []) allTargets.add(target);
        for (const node of Object.keys(this.nodes)) if (!allTargets.has(node)) throw new UnreachableNodeError([
          `Node \`${node}\` is not reachable.`,
          "",
          "If you are returning Command objects from your node,",
          'make sure you are passing names of potential destination nodes as an "ends" array',
          'into ".addNode(..., { ends: ["node1", "node2"] })".'
        ].join("\n"), { lc_error_code: "UNREACHABLE_NODE" });
        for (const target of allTargets) if (target !== END && !(target in this.nodes)) throw new Error(`Found edge ending at unknown node \`${target}\``);
        if (interrupt2) {
          for (const node of interrupt2) if (!(node in this.nodes)) throw new Error(`Interrupt node \`${node}\` is not present`);
        }
        this.compiled = true;
      }
    };
    CompiledGraph = class extends Pregel {
      builder;
      constructor({ builder, ...rest }) {
        super(rest);
        this.builder = builder;
      }
      attachNode(key, node) {
        this.channels[key] = new EphemeralValue();
        this.nodes[key] = new PregelNode({
          channels: [],
          triggers: [],
          metadata: node.metadata,
          subgraphs: node.subgraphs,
          ends: node.ends
        }).pipe(node.runnable).pipe(new ChannelWrite([{
          channel: key,
          value: PASSTHROUGH
        }], [TAG_HIDDEN]));
        this.streamChannels.push(key);
      }
      attachEdge(start, end) {
        if (end === END) {
          if (start === START) throw new Error("Cannot have an edge from START to END");
          this.nodes[start].writers.push(new ChannelWrite([{
            channel: END,
            value: PASSTHROUGH
          }], [TAG_HIDDEN]));
        } else {
          this.nodes[end].triggers.push(start);
          this.nodes[end].channels.push(start);
        }
      }
      attachBranch(start, name, branch) {
        if (start === START && !this.nodes[START]) this.nodes[START] = Channel.subscribeTo(START, { tags: [TAG_HIDDEN] });
        this.nodes[start].pipe(branch.run((dests) => {
          return new ChannelWrite(dests.map((dest) => {
            if (_isSend(dest)) return dest;
            return {
              channel: dest === END ? END : `branch:${start}:${name}:${dest}`,
              value: PASSTHROUGH
            };
          }), [TAG_HIDDEN]);
        }));
        const ends = branch.ends ? Object.values(branch.ends) : Object.keys(this.nodes);
        for (const end of ends) if (end !== END) {
          const channelName = `branch:${start}:${name}:${end}`;
          this.channels[channelName] = new EphemeralValue();
          this.nodes[end].triggers.push(channelName);
          this.nodes[end].channels.push(channelName);
        }
      }
      /**
      * Returns a drawable representation of the computation graph.
      */
      async getGraphAsync(config2) {
        const xray = config2?.xray;
        const graph = new Graph();
        const startNodes = { [START]: graph.addNode({ schema: external_exports2.any() }, START) };
        const endNodes = {};
        let subgraphs = {};
        if (xray) subgraphs = Object.fromEntries((await gatherIterator(this.getSubgraphsAsync())).filter((x) => isCompiledGraph(x[1])));
        function addEdge(start, end, label, conditional = false) {
          if (end === END && endNodes[END] === void 0) endNodes[END] = graph.addNode({ schema: external_exports2.any() }, END);
          if (startNodes[start] === void 0) return;
          if (endNodes[end] === void 0) throw new Error(`End node ${end} not found!`);
          return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : void 0, conditional);
        }
        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {
          const displayKey = _escapeMermaidKeywords(key);
          const node = nodeSpec.runnable;
          const metadata = nodeSpec.metadata ?? {};
          if (this.interruptBefore?.includes(key) && this.interruptAfter?.includes(key)) metadata.__interrupt = "before,after";
          else if (this.interruptBefore?.includes(key)) metadata.__interrupt = "before";
          else if (this.interruptAfter?.includes(key)) metadata.__interrupt = "after";
          if (xray) {
            const newXrayValue = typeof xray === "number" ? xray - 1 : xray;
            const drawableSubgraph = subgraphs[key] !== void 0 ? await subgraphs[key].getGraphAsync({
              ...config2,
              xray: newXrayValue
            }) : node.getGraph(config2);
            drawableSubgraph.trimFirstNode();
            drawableSubgraph.trimLastNode();
            if (Object.keys(drawableSubgraph.nodes).length > 1) {
              let _isRunnableInterface = function(thing) {
                return thing ? thing.lc_runnable : false;
              }, _nodeDataStr = function(id, data) {
                if (id !== void 0 && !validate_default4(id)) return id;
                else if (_isRunnableInterface(data)) try {
                  let dataStr = data.getName();
                  dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
                  return dataStr;
                } catch (error40) {
                  return data.getName();
                }
                else return data.name ?? "UnknownSchema";
              };
              const [e, s] = graph.extend(drawableSubgraph, displayKey);
              if (e === void 0) throw new Error(`Could not extend subgraph "${key}" due to missing entrypoint.`);
              if (s !== void 0) startNodes[displayKey] = {
                name: _nodeDataStr(s.id, s.data),
                ...s
              };
              endNodes[displayKey] = {
                name: _nodeDataStr(e.id, e.data),
                ...e
              };
            } else {
              const newNode = graph.addNode(node, displayKey, metadata);
              startNodes[displayKey] = newNode;
              endNodes[displayKey] = newNode;
            }
          } else {
            const newNode = graph.addNode(node, displayKey, metadata);
            startNodes[displayKey] = newNode;
            endNodes[displayKey] = newNode;
          }
        }
        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {
          if (a < b) return -1;
          else if (b > a) return 1;
          else return 0;
        });
        for (const [start, end] of sortedEdges) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));
        for (const [start, branches] of Object.entries(this.builder.branches)) {
          const defaultEnds = {
            ...Object.fromEntries(Object.keys(this.builder.nodes).filter((k) => k !== start).map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),
            [END]: END
          };
          for (const branch of Object.values(branches)) {
            let ends;
            if (branch.ends !== void 0) ends = branch.ends;
            else ends = defaultEnds;
            for (const [label, end] of Object.entries(ends)) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);
          }
        }
        for (const [key, node] of Object.entries(this.builder.nodes)) if (node.ends !== void 0) for (const end of node.ends) addEdge(_escapeMermaidKeywords(key), _escapeMermaidKeywords(end), void 0, true);
        return graph;
      }
      /**
      * Returns a drawable representation of the computation graph.
      *
      * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.
      */
      getGraph(config2) {
        const xray = config2?.xray;
        const graph = new Graph();
        const startNodes = { [START]: graph.addNode({ schema: external_exports2.any() }, START) };
        const endNodes = {};
        let subgraphs = {};
        if (xray) subgraphs = Object.fromEntries(gatherIteratorSync(this.getSubgraphs()).filter((x) => isCompiledGraph(x[1])));
        function addEdge(start, end, label, conditional = false) {
          if (end === END && endNodes[END] === void 0) endNodes[END] = graph.addNode({ schema: external_exports2.any() }, END);
          return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : void 0, conditional);
        }
        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {
          const displayKey = _escapeMermaidKeywords(key);
          const node = nodeSpec.runnable;
          const metadata = nodeSpec.metadata ?? {};
          if (this.interruptBefore?.includes(key) && this.interruptAfter?.includes(key)) metadata.__interrupt = "before,after";
          else if (this.interruptBefore?.includes(key)) metadata.__interrupt = "before";
          else if (this.interruptAfter?.includes(key)) metadata.__interrupt = "after";
          if (xray) {
            const newXrayValue = typeof xray === "number" ? xray - 1 : xray;
            const drawableSubgraph = subgraphs[key] !== void 0 ? subgraphs[key].getGraph({
              ...config2,
              xray: newXrayValue
            }) : node.getGraph(config2);
            drawableSubgraph.trimFirstNode();
            drawableSubgraph.trimLastNode();
            if (Object.keys(drawableSubgraph.nodes).length > 1) {
              let _isRunnableInterface = function(thing) {
                return thing ? thing.lc_runnable : false;
              }, _nodeDataStr = function(id, data) {
                if (id !== void 0 && !validate_default4(id)) return id;
                else if (_isRunnableInterface(data)) try {
                  let dataStr = data.getName();
                  dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
                  return dataStr;
                } catch (error40) {
                  return data.getName();
                }
                else return data.name ?? "UnknownSchema";
              };
              const [e, s] = graph.extend(drawableSubgraph, displayKey);
              if (e === void 0) throw new Error(`Could not extend subgraph "${key}" due to missing entrypoint.`);
              if (s !== void 0) startNodes[displayKey] = {
                name: _nodeDataStr(s.id, s.data),
                ...s
              };
              endNodes[displayKey] = {
                name: _nodeDataStr(e.id, e.data),
                ...e
              };
            } else {
              const newNode = graph.addNode(node, displayKey, metadata);
              startNodes[displayKey] = newNode;
              endNodes[displayKey] = newNode;
            }
          } else {
            const newNode = graph.addNode(node, displayKey, metadata);
            startNodes[displayKey] = newNode;
            endNodes[displayKey] = newNode;
          }
        }
        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {
          if (a < b) return -1;
          else if (b > a) return 1;
          else return 0;
        });
        for (const [start, end] of sortedEdges) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));
        for (const [start, branches] of Object.entries(this.builder.branches)) {
          const defaultEnds = {
            ...Object.fromEntries(Object.keys(this.builder.nodes).filter((k) => k !== start).map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),
            [END]: END
          };
          for (const branch of Object.values(branches)) {
            let ends;
            if (branch.ends !== void 0) ends = branch.ends;
            else ends = defaultEnds;
            for (const [label, end] of Object.entries(ends)) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);
          }
        }
        return graph;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/state/types.js
function isStandardSchema(schema) {
  return typeof schema === "object" && schema !== null && "~standard" in schema && typeof schema["~standard"] === "object" && schema["~standard"] !== null && "validate" in schema["~standard"];
}
function isStandardJSONSchema(schema) {
  return typeof schema === "object" && schema !== null && "~standard" in schema && typeof schema["~standard"] === "object" && schema["~standard"] !== null && "jsonSchema" in schema["~standard"];
}
var init_types7 = __esm({
  "node_modules/@langchain/langgraph/dist/state/types.js"() {
  }
});

// node_modules/@langchain/langgraph/dist/state/adapter.js
function getJsonSchemaFromSchema(schema) {
  if (isStandardJSONSchema(schema)) try {
    return schema["~standard"].jsonSchema.input({ target: "draft-07" });
  } catch {
    return;
  }
}
function getSchemaDefaultGetter(schema) {
  if (schema == null) return;
  if (!isStandardSchema(schema)) return;
  try {
    const result = schema["~standard"].validate(void 0);
    if (result && typeof result === "object" && !("then" in result && typeof result.then === "function")) {
      const syncResult = result;
      if (!syncResult.issues) {
        const defaultValue = syncResult.value;
        return () => defaultValue;
      }
    }
  } catch {
  }
}
var init_adapter = __esm({
  "node_modules/@langchain/langgraph/dist/state/adapter.js"() {
    init_types7();
  }
});

// node_modules/@langchain/langgraph/dist/channels/untracked_value.js
var MISSING, UntrackedValueChannel;
var init_untracked_value = __esm({
  "node_modules/@langchain/langgraph/dist/channels/untracked_value.js"() {
    init_errors3();
    init_base15();
    MISSING = Symbol.for("langgraph.channel.missing");
    UntrackedValueChannel = class UntrackedValueChannel2 extends BaseChannel {
      lc_graph_name = "UntrackedValue";
      /**
      * If true, throws an error when multiple values are received in a single step.
      * If false, stores the last value received.
      */
      guard;
      /**
      * The current value. MISSING sentinel indicates no value has been set.
      */
      _value = MISSING;
      /**
      * Optional factory function for the initial value.
      */
      initialValueFactory;
      constructor(options) {
        super();
        this.guard = options?.guard ?? true;
        this.initialValueFactory = options?.initialValueFactory;
        if (this.initialValueFactory) this._value = this.initialValueFactory();
      }
      /**
      * Return a new channel, ignoring the checkpoint since we don't persist.
      * The initial value (if any) is restored.
      */
      fromCheckpoint(_checkpoint) {
        return new UntrackedValueChannel2({
          guard: this.guard,
          initialValueFactory: this.initialValueFactory
        });
      }
      /**
      * Update the channel with the given values.
      * If guard is true, throws if more than one value is received.
      */
      update(values) {
        if (values.length === 0) return false;
        if (values.length !== 1 && this.guard) throw new InvalidUpdateError("UntrackedValue(guard=true) can receive only one value per step. Use guard=false if you want to store any one of multiple values.", { lc_error_code: "INVALID_CONCURRENT_GRAPH_UPDATE" });
        this._value = values[values.length - 1];
        return true;
      }
      /**
      * Get the current value.
      * @throws EmptyChannelError if no value has been set.
      */
      get() {
        if (this._value === MISSING) throw new EmptyChannelError();
        return this._value;
      }
      /**
      * Always returns undefined - untracked values are never checkpointed.
      */
      checkpoint() {
      }
      /**
      * Return true if a value has been set.
      */
      isAvailable() {
        return this._value !== MISSING;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/state/values/reduced.js
var REDUCED_VALUE_SYMBOL, ReducedValue;
var init_reduced = __esm({
  "node_modules/@langchain/langgraph/dist/state/values/reduced.js"() {
    REDUCED_VALUE_SYMBOL = Symbol.for("langgraph.state.reduced_value");
    ReducedValue = class {
      /**
      * Instance marker for runtime identification.
      * @internal
      */
      [REDUCED_VALUE_SYMBOL] = true;
      /**
      * The schema that describes the type of value stored in state (i.e., after reduction).
      * Note: We use `unknown` for the input type to allow schemas with `.default()` wrappers,
      * where the input type includes `undefined`.
      */
      valueSchema;
      /**
      * The schema used to validate reducer inputs.
      * If not specified explicitly, this defaults to `valueSchema`.
      */
      inputSchema;
      /**
      * The reducer function that combines a current output value and an incoming input.
      */
      reducer;
      /**
      * Optional extra fields to merge into the generated JSON Schema (e.g., for documentation or constraints).
      */
      jsonSchemaExtra;
      constructor(valueSchema, init) {
        this.reducer = init.reducer;
        this.jsonSchemaExtra = init.jsonSchemaExtra;
        this.valueSchema = valueSchema;
        this.inputSchema = "inputSchema" in init ? init.inputSchema : valueSchema;
        this.jsonSchemaExtra = init.jsonSchemaExtra;
      }
      static isInstance(value) {
        return typeof value === "object" && value !== null && REDUCED_VALUE_SYMBOL in value && value[REDUCED_VALUE_SYMBOL] === true;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/state/values/untracked.js
var UNTRACKED_VALUE_SYMBOL, UntrackedValue;
var init_untracked = __esm({
  "node_modules/@langchain/langgraph/dist/state/values/untracked.js"() {
    UNTRACKED_VALUE_SYMBOL = Symbol.for("langgraph.state.untracked_value");
    UntrackedValue = class {
      /**
      * Instance marker for runtime identification.
      * @internal
      */
      [UNTRACKED_VALUE_SYMBOL] = true;
      /**
      * Optional schema describing the type and shape of the value stored in this field.
      *
      * If provided, this can be used for runtime validation or code generation.
      */
      schema;
      /**
      * Whether to guard against multiple updates to this untracked value in a single step.
      *
      * - If `true` (default), throws an error if multiple updates are received in one step.
      * - If `false`, only the last value from that step is kept, others are ignored.
      *
      * This helps prevent accidental state replacement within a step.
      */
      guard;
      /**
      * Create a new untracked value state field.
      *
      * @param schema - Optional type schema describing the value (e.g. a Zod schema).
      * @param init - Optional options for tracking updates or enabling multiple-writes-per-step.
      */
      constructor(schema, init) {
        this.schema = schema;
        this.guard = init?.guard ?? true;
      }
      static isInstance(value) {
        return typeof value === "object" && value !== null && UNTRACKED_VALUE_SYMBOL in value;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js
var areSetsEqual, NamedBarrierValue, NamedBarrierValueAfterFinish;
var init_named_barrier_value = __esm({
  "node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js"() {
    init_errors3();
    init_base15();
    areSetsEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));
    NamedBarrierValue = class NamedBarrierValue2 extends BaseChannel {
      lc_graph_name = "NamedBarrierValue";
      names;
      seen;
      constructor(names) {
        super();
        this.names = names;
        this.seen = /* @__PURE__ */ new Set();
      }
      fromCheckpoint(checkpoint) {
        const empty = new NamedBarrierValue2(this.names);
        if (typeof checkpoint !== "undefined") empty.seen = new Set(checkpoint);
        return empty;
      }
      update(values) {
        let updated = false;
        for (const nodeName of values) if (this.names.has(nodeName)) {
          if (!this.seen.has(nodeName)) {
            this.seen.add(nodeName);
            updated = true;
          }
        } else throw new InvalidUpdateError(`Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(this.names)}`);
        return updated;
      }
      get() {
        if (!areSetsEqual(this.names, this.seen)) throw new EmptyChannelError();
      }
      checkpoint() {
        return [...this.seen];
      }
      consume() {
        if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {
          this.seen = /* @__PURE__ */ new Set();
          return true;
        }
        return false;
      }
      isAvailable() {
        return !!this.names && areSetsEqual(this.names, this.seen);
      }
    };
    NamedBarrierValueAfterFinish = class NamedBarrierValueAfterFinish2 extends BaseChannel {
      lc_graph_name = "NamedBarrierValueAfterFinish";
      names;
      seen;
      finished;
      constructor(names) {
        super();
        this.names = names;
        this.seen = /* @__PURE__ */ new Set();
        this.finished = false;
      }
      fromCheckpoint(checkpoint) {
        const empty = new NamedBarrierValueAfterFinish2(this.names);
        if (typeof checkpoint !== "undefined") {
          const [seen, finished] = checkpoint;
          empty.seen = new Set(seen);
          empty.finished = finished;
        }
        return empty;
      }
      update(values) {
        let updated = false;
        for (const nodeName of values) if (this.names.has(nodeName) && !this.seen.has(nodeName)) {
          this.seen.add(nodeName);
          updated = true;
        } else if (!this.names.has(nodeName)) throw new InvalidUpdateError(`Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(this.names)}`);
        return updated;
      }
      get() {
        if (!this.finished || !areSetsEqual(this.names, this.seen)) throw new EmptyChannelError();
      }
      checkpoint() {
        return [[...this.seen], this.finished];
      }
      consume() {
        if (this.finished && this.seen && this.names && areSetsEqual(this.seen, this.names)) {
          this.seen = /* @__PURE__ */ new Set();
          this.finished = false;
          return true;
        }
        return false;
      }
      finish() {
        if (!this.finished && !!this.names && areSetsEqual(this.names, this.seen)) {
          this.finished = true;
          return true;
        }
        return false;
      }
      isAvailable() {
        return this.finished && !!this.names && areSetsEqual(this.names, this.seen);
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/channels/any_value.js
var init_any_value = __esm({
  "node_modules/@langchain/langgraph/dist/channels/any_value.js"() {
    init_errors3();
    init_base15();
  }
});

// node_modules/@langchain/langgraph/dist/channels/dynamic_barrier_value.js
var init_dynamic_barrier_value = __esm({
  "node_modules/@langchain/langgraph/dist/channels/dynamic_barrier_value.js"() {
    init_errors3();
    init_base15();
    init_named_barrier_value();
  }
});

// node_modules/@langchain/langgraph/dist/channels/index.js
var init_channels = __esm({
  "node_modules/@langchain/langgraph/dist/channels/index.js"() {
    init_base15();
    init_binop();
    init_last_value();
    init_topic();
    init_ephemeral_value();
    init_named_barrier_value();
    init_any_value();
    init_dynamic_barrier_value();
    init_untracked_value();
  }
});

// node_modules/@langchain/langgraph/dist/state/schema.js
var STATE_SCHEMA_SYMBOL, StateSchema;
var init_schema = __esm({
  "node_modules/@langchain/langgraph/dist/state/schema.js"() {
    init_binop();
    init_last_value();
    init_types7();
    init_adapter();
    init_untracked_value();
    init_channels();
    init_reduced();
    init_untracked();
    STATE_SCHEMA_SYMBOL = Symbol.for("langgraph.state.state_schema");
    StateSchema = class {
      /**
      * Symbol for runtime identification.
      * @internal Used by isInstance for runtime type checking
      */
      [STATE_SCHEMA_SYMBOL] = true;
      constructor(fields) {
        this.fields = fields;
      }
      /**
      * Get the channel definitions for use with StateGraph.
      * This converts the StateSchema fields into BaseChannel instances.
      */
      getChannels() {
        const channels = {};
        for (const [key, value] of Object.entries(this.fields)) if (ReducedValue.isInstance(value)) {
          const defaultGetter = getSchemaDefaultGetter(value.valueSchema);
          channels[key] = new BinaryOperatorAggregate(value.reducer, defaultGetter);
        } else if (UntrackedValue.isInstance(value)) {
          const defaultGetter = value.schema ? getSchemaDefaultGetter(value.schema) : void 0;
          channels[key] = new UntrackedValueChannel({
            guard: value.guard,
            initialValueFactory: defaultGetter
          });
        } else if (isStandardSchema(value)) channels[key] = new LastValue(getSchemaDefaultGetter(value));
        else throw new Error(`Invalid state field "${key}": must be a schema, ReducedValue, UntrackedValue, or ManagedValue`);
        return channels;
      }
      /**
      * Get the JSON schema for the full state type.
      * Used by Studio and API for schema introspection.
      */
      getJsonSchema() {
        const properties = {};
        const required2 = [];
        for (const [key, value] of Object.entries(this.fields)) {
          let fieldSchema;
          if (ReducedValue.isInstance(value)) {
            fieldSchema = getJsonSchemaFromSchema(value.valueSchema);
            if (fieldSchema && value.jsonSchemaExtra) fieldSchema = {
              ...fieldSchema,
              ...value.jsonSchemaExtra
            };
          } else if (UntrackedValue.isInstance(value)) fieldSchema = value.schema ? getJsonSchemaFromSchema(value.schema) : void 0;
          else if (isStandardSchema(value)) fieldSchema = getJsonSchemaFromSchema(value);
          if (fieldSchema) {
            properties[key] = fieldSchema;
            let hasDefault = false;
            if (ReducedValue.isInstance(value)) hasDefault = getSchemaDefaultGetter(value.valueSchema) !== void 0;
            else if (UntrackedValue.isInstance(value)) hasDefault = value.schema ? getSchemaDefaultGetter(value.schema) !== void 0 : false;
            else hasDefault = getSchemaDefaultGetter(value) !== void 0;
            if (!hasDefault) required2.push(key);
          }
        }
        return {
          type: "object",
          properties,
          required: required2.length > 0 ? required2 : void 0
        };
      }
      /**
      * Get the JSON schema for the update/input type.
      * All fields are optional in updates.
      */
      getInputJsonSchema() {
        const properties = {};
        for (const [key, value] of Object.entries(this.fields)) {
          let fieldSchema;
          if (ReducedValue.isInstance(value)) fieldSchema = getJsonSchemaFromSchema(value.inputSchema);
          else if (UntrackedValue.isInstance(value)) fieldSchema = value.schema ? getJsonSchemaFromSchema(value.schema) : void 0;
          else if (isStandardSchema(value)) fieldSchema = getJsonSchemaFromSchema(value);
          if (fieldSchema) properties[key] = fieldSchema;
        }
        return {
          type: "object",
          properties
        };
      }
      /**
      * Get the list of channel keys (excluding managed values).
      */
      getChannelKeys() {
        return Object.entries(this.fields).map(([key]) => key);
      }
      /**
      * Get all keys (channels + managed values).
      */
      getAllKeys() {
        return Object.keys(this.fields);
      }
      /**
      * Validate input data against the schema.
      * This validates each field using its corresponding schema.
      *
      * @param data - The input data to validate
      * @returns The validated data with coerced types
      */
      async validateInput(data) {
        if (data == null || typeof data !== "object") return data;
        const result = {};
        for (const [key, value] of Object.entries(data)) {
          const fieldDef = this.fields[key];
          if (fieldDef === void 0) {
            result[key] = value;
            continue;
          }
          let schema;
          if (ReducedValue.isInstance(fieldDef)) schema = fieldDef.inputSchema;
          else if (UntrackedValue.isInstance(fieldDef)) schema = fieldDef.schema;
          else if (isStandardSchema(fieldDef)) schema = fieldDef;
          if (schema) {
            const validationResult = await schema["~standard"].validate(value);
            if (validationResult.issues) throw new Error(`Validation failed for field "${key}": ${JSON.stringify(validationResult.issues)}`);
            result[key] = validationResult.value;
          } else result[key] = value;
        }
        return result;
      }
      static isInstance(value) {
        return typeof value === "object" && value !== null && STATE_SCHEMA_SYMBOL in value && value[STATE_SCHEMA_SYMBOL] === true;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/graph/messages_reducer.js
function messagesStateReducer(left, right) {
  const leftArray = Array.isArray(left) ? left : [left];
  const rightArray = Array.isArray(right) ? right : [right];
  const leftMessages = leftArray.map(coerceMessageLikeToMessage);
  const rightMessages = rightArray.map(coerceMessageLikeToMessage);
  for (const m of leftMessages) if (m.id === null || m.id === void 0) {
    m.id = v4_default3();
    m.lc_kwargs.id = m.id;
  }
  let removeAllIdx;
  for (let i = 0; i < rightMessages.length; i += 1) {
    const m = rightMessages[i];
    if (m.id === null || m.id === void 0) {
      m.id = v4_default3();
      m.lc_kwargs.id = m.id;
    }
    if (RemoveMessage.isInstance(m) && m.id === REMOVE_ALL_MESSAGES) removeAllIdx = i;
  }
  if (removeAllIdx != null) return rightMessages.slice(removeAllIdx + 1);
  const merged = [...leftMessages];
  const mergedById = new Map(merged.map((m, i) => [m.id, i]));
  const idsToRemove = /* @__PURE__ */ new Set();
  for (const m of rightMessages) {
    const existingIdx = mergedById.get(m.id);
    if (existingIdx !== void 0) if (RemoveMessage.isInstance(m)) idsToRemove.add(m.id);
    else {
      idsToRemove.delete(m.id);
      merged[existingIdx] = m;
    }
    else {
      if (RemoveMessage.isInstance(m)) throw new Error(`Attempting to delete a message with an ID that doesn't exist ('${m.id}')`);
      mergedById.set(m.id, merged.length);
      merged.push(m);
    }
  }
  return merged.filter((m) => !idsToRemove.has(m.id));
}
var REMOVE_ALL_MESSAGES;
var init_messages_reducer = __esm({
  "node_modules/@langchain/langgraph/dist/graph/messages_reducer.js"() {
    init_esm_node4();
    init_messages2();
    REMOVE_ALL_MESSAGES = "__remove_all__";
  }
});

// node_modules/@langchain/langgraph/dist/state/prebuilt/messages.js
var messagesValueSchema, messagesInputSchema, MessagesValue;
var init_messages4 = __esm({
  "node_modules/@langchain/langgraph/dist/state/prebuilt/messages.js"() {
    init_reduced();
    init_messages_reducer();
    init_v43();
    messagesValueSchema = external_exports2.custom().default(() => []);
    messagesInputSchema = external_exports2.custom();
    MessagesValue = new ReducedValue(messagesValueSchema, {
      inputSchema: messagesInputSchema,
      reducer: messagesStateReducer,
      jsonSchemaExtra: {
        langgraph_type: "messages",
        description: "A list of chat messages"
      }
    });
  }
});

// node_modules/@langchain/langgraph/dist/state/prebuilt/index.js
var init_prebuilt = __esm({
  "node_modules/@langchain/langgraph/dist/state/prebuilt/index.js"() {
    init_messages4();
  }
});

// node_modules/@langchain/langgraph/dist/state/values/index.js
var init_values = __esm({
  "node_modules/@langchain/langgraph/dist/state/values/index.js"() {
    init_reduced();
    init_untracked();
  }
});

// node_modules/@langchain/langgraph/dist/state/index.js
var init_state = __esm({
  "node_modules/@langchain/langgraph/dist/state/index.js"() {
    init_types7();
    init_adapter();
    init_reduced();
    init_untracked();
    init_schema();
    init_messages4();
    init_prebuilt();
    init_values();
  }
});

// node_modules/@langchain/langgraph/dist/graph/zod/meta.js
function withLangGraph(schema, meta) {
  if (meta.reducer && !meta.default) {
    const defaultValueGetter = getInteropZodDefaultGetter(schema);
    if (defaultValueGetter != null) meta.default = defaultValueGetter;
  }
  if (meta.reducer) {
    const schemaWithReducer = Object.assign(schema, { lg_reducer_schema: meta.reducer?.schema ?? schema });
    schemaMetaRegistry.extend(schemaWithReducer, () => meta);
    return schemaWithReducer;
  } else {
    schemaMetaRegistry.extend(schema, () => meta);
    return schema;
  }
}
var META_EXTRAS_DESCRIPTION_PREFIX, SchemaMetaRegistry, schemaMetaRegistry;
var init_meta = __esm({
  "node_modules/@langchain/langgraph/dist/graph/zod/meta.js"() {
    init_binop();
    init_last_value();
    init_types5();
    META_EXTRAS_DESCRIPTION_PREFIX = "lg:";
    SchemaMetaRegistry = class {
      /**
      * Internal map storing schema metadata.
      * @internal
      */
      _map = /* @__PURE__ */ new WeakMap();
      /**
      * Cache for extended schfemas.
      * @internal
      */
      _extensionCache = /* @__PURE__ */ new Map();
      /**
      * Retrieves the metadata associated with a given schema.
      * @template TValue The value type of the schema.
      * @template TUpdate The update type of the schema (defaults to TValue).
      * @param schema The schema to retrieve metadata for.
      * @returns The associated SchemaMeta, or undefined if not present.
      */
      get(schema) {
        return this._map.get(schema);
      }
      /**
      * Extends or sets the metadata for a given schema.
      * @template TValue The value type of the schema.
      * @template TUpdate The update type of the schema (defaults to TValue).
      * @param schema The schema to extend metadata for.
      * @param predicate A function that receives the existing metadata (or undefined) and returns the new metadata.
      */
      extend(schema, predicate) {
        const existingMeta = this.get(schema);
        this._map.set(schema, predicate(existingMeta));
      }
      /**
      * Removes the metadata associated with a given schema.
      * @param schema The schema to remove metadata for.
      * @returns The SchemaMetaRegistry instance (for chaining).
      */
      remove(schema) {
        this._map.delete(schema);
        return this;
      }
      /**
      * Checks if metadata exists for a given schema.
      * @param schema The schema to check.
      * @returns True if metadata exists, false otherwise.
      */
      has(schema) {
        return this._map.has(schema);
      }
      /**
      * Returns a mapping of channel instances for each property in the schema
      * using the associated metadata in the registry.
      *
      * This is used to create the `channels` object that's passed to the `Graph` constructor.
      *
      * @template T The shape of the schema.
      * @param schema The schema to extract channels from.
      * @returns A mapping from property names to channel instances.
      */
      getChannelsForSchema(schema) {
        const channels = {};
        const shape = getInteropZodObjectShape(schema);
        for (const [key, channelSchema] of Object.entries(shape)) {
          const meta = this.get(channelSchema);
          if (meta?.reducer) channels[key] = new BinaryOperatorAggregate(meta.reducer.fn, meta.default);
          else channels[key] = new LastValue(meta?.default);
        }
        return channels;
      }
      /**
      * Returns a modified schema that introspectively looks at all keys of the provided
      * object schema, and applies the augmentations based on meta provided with those keys
      * in the registry and the selectors provided in the `effects` parameter.
      *
      * This assumes that the passed in schema is the "root" schema object for a graph where
      * the keys of the schema are the channels of the graph. Because we need to represent
      * the input of a graph in a couple of different ways, the `effects` parameter allows
      * us to apply those augmentations based on pre determined conditions.
      *
      * @param schema The root schema object to extend.
      * @param effects The effects that are being applied.
      * @returns The extended schema.
      */
      getExtendedChannelSchemas(schema, effects) {
        if (Object.keys(effects).length === 0) return schema;
        const cacheKey = Object.entries(effects).filter(([, v]) => v === true).sort(([a], [b]) => a.localeCompare(b)).map(([k, v]) => `${k}:${v}`).join("|");
        const cache2 = this._extensionCache.get(cacheKey) ?? /* @__PURE__ */ new WeakMap();
        if (cache2.has(schema)) return cache2.get(schema);
        let modifiedSchema = schema;
        if (effects.withReducerSchema || effects.withJsonSchemaExtrasAsDescription) {
          const newShapeEntries = Object.entries(getInteropZodObjectShape(schema)).map(([key, schema2]) => {
            const meta = this.get(schema2);
            let outputSchema = effects.withReducerSchema ? meta?.reducer?.schema ?? schema2 : schema2;
            if (effects.withJsonSchemaExtrasAsDescription && meta?.jsonSchemaExtra) {
              const description = getSchemaDescription(outputSchema) ?? getSchemaDescription(schema2);
              const strExtras = JSON.stringify({
                ...meta.jsonSchemaExtra,
                description
              });
              outputSchema = outputSchema.describe(`${META_EXTRAS_DESCRIPTION_PREFIX}${strExtras}`);
            }
            return [key, outputSchema];
          });
          modifiedSchema = extendInteropZodObject(schema, Object.fromEntries(newShapeEntries));
          if (isZodSchemaV3(modifiedSchema)) modifiedSchema._def.unknownKeys = "strip";
        }
        if (effects.asPartial) modifiedSchema = interopZodObjectPartial(modifiedSchema);
        cache2.set(schema, modifiedSchema);
        this._extensionCache.set(cacheKey, cache2);
        return modifiedSchema;
      }
    };
    schemaMetaRegistry = new SchemaMetaRegistry();
  }
});

// node_modules/@langchain/langgraph/dist/graph/types.js
function isStateDefinitionInit(value) {
  if (value == null) return false;
  if (StateSchema.isInstance(value)) return true;
  if (isInteropZodObject(value)) return true;
  if (typeof value === "object" && "lc_graph_name" in value && value.lc_graph_name === "AnnotationRoot") return true;
  if (typeof value === "object" && !Array.isArray(value) && Object.keys(value).length > 0 && Object.values(value).every((v) => typeof v === "function" || isBaseChannel(v))) return true;
  return false;
}
function isStateGraphInit(value) {
  if (typeof value !== "object" || value == null) return false;
  const obj = value;
  const hasState = "state" in obj && isStateDefinitionInit(obj.state);
  const hasStateSchema = "stateSchema" in obj && isStateDefinitionInit(obj.stateSchema);
  const hasInput = "input" in obj && isStateDefinitionInit(obj.input);
  if (!hasState && !hasStateSchema && !hasInput) return false;
  if ("input" in obj && obj.input != null && !isStateDefinitionInit(obj.input)) return false;
  if ("output" in obj && obj.output != null && !isStateDefinitionInit(obj.output)) return false;
  return true;
}
var init_types8 = __esm({
  "node_modules/@langchain/langgraph/dist/graph/types.js"() {
    init_base15();
    init_constants3();
    init_schema();
    init_types5();
  }
});

// node_modules/@langchain/langgraph/dist/graph/state.js
function _getChannels(schema) {
  const channels = {};
  for (const [name, val] of Object.entries(schema)) if (name === ROOT2) channels[name] = getChannel(val);
  else channels[name] = getChannel(val);
  return channels;
}
function isStateGraphArgs(obj) {
  return typeof obj === "object" && obj !== null && obj.channels !== void 0;
}
function _controlBranch(value) {
  if (_isSend(value)) return [value];
  const commands = [];
  if (isCommand(value)) commands.push(value);
  else if (Array.isArray(value)) commands.push(...value.filter(isCommand));
  const destinations = [];
  for (const command of commands) {
    if (command.graph === Command.PARENT) throw new ParentCommand(command);
    if (_isSend(command.goto)) destinations.push(command.goto);
    else if (typeof command.goto === "string") destinations.push(command.goto);
    else if (Array.isArray(command.goto)) destinations.push(...command.goto);
  }
  return destinations;
}
function _getControlBranch() {
  return new Branch({ path: new RunnableCallable({
    func: _controlBranch,
    tags: [TAG_HIDDEN],
    trace: false,
    recurse: false,
    name: "<control_branch>"
  }) });
}
var ROOT2, PartialStateSchema, StateGraph, CompiledStateGraph;
var init_state2 = __esm({
  "node_modules/@langchain/langgraph/dist/graph/state.js"() {
    init_errors3();
    init_last_value();
    init_annotation();
    init_constants3();
    init_utils8();
    init_write();
    init_read();
    init_subgraph();
    init_ephemeral_value();
    init_graph2();
    init_named_barrier_value();
    init_schema();
    init_state();
    init_meta();
    init_types8();
    init_runnables();
    init_types5();
    ROOT2 = "__root__";
    PartialStateSchema = Symbol.for("langgraph.state.partial");
    StateGraph = class extends Graph$1 {
      channels = {};
      waitingEdges = /* @__PURE__ */ new Set();
      /** @internal */
      _schemaDefinition;
      /** @internal */
      _schemaRuntimeDefinition;
      /** @internal */
      _inputDefinition;
      /** @internal */
      _inputRuntimeDefinition;
      /** @internal */
      _outputDefinition;
      /** @internal */
      _outputRuntimeDefinition;
      /**
      * Map schemas to managed values
      * @internal
      */
      _schemaDefinitions = /* @__PURE__ */ new Map();
      /** @internal */
      _metaRegistry = schemaMetaRegistry;
      /** @internal Used only for typing. */
      _configSchema;
      /** @internal */
      _configRuntimeSchema;
      /** @internal */
      _interrupt;
      /** @internal */
      _writer;
      constructor(stateOrInit, options) {
        super();
        const init = this._normalizeToStateGraphInit(stateOrInit, options);
        const stateSchema = init.state ?? init.stateSchema ?? init.input;
        if (!stateSchema) throw new StateGraphInputError();
        const stateChannelDef = this._getChannelsFromSchema(stateSchema);
        this._schemaDefinition = stateChannelDef;
        if (StateSchema.isInstance(stateSchema)) this._schemaRuntimeDefinition = stateSchema;
        else if (isInteropZodObject(stateSchema)) this._schemaRuntimeDefinition = stateSchema;
        if (init.input) if (StateSchema.isInstance(init.input)) this._inputRuntimeDefinition = init.input;
        else if (isInteropZodObject(init.input)) this._inputRuntimeDefinition = init.input;
        else this._inputRuntimeDefinition = PartialStateSchema;
        else this._inputRuntimeDefinition = PartialStateSchema;
        if (init.output) if (StateSchema.isInstance(init.output)) this._outputRuntimeDefinition = init.output;
        else if (isInteropZodObject(init.output)) this._outputRuntimeDefinition = init.output;
        else this._outputRuntimeDefinition = this._schemaRuntimeDefinition;
        else this._outputRuntimeDefinition = this._schemaRuntimeDefinition;
        const inputChannelDef = init.input ? this._getChannelsFromSchema(init.input) : stateChannelDef;
        const outputChannelDef = init.output ? this._getChannelsFromSchema(init.output) : stateChannelDef;
        this._inputDefinition = inputChannelDef;
        this._outputDefinition = outputChannelDef;
        this._addSchema(this._schemaDefinition);
        this._addSchema(this._inputDefinition);
        this._addSchema(this._outputDefinition);
        if (init.context) {
          if (isInteropZodObject(init.context)) this._configRuntimeSchema = init.context;
        }
        this._interrupt = init.interrupt;
        this._writer = init.writer;
      }
      /**
      * Normalize all constructor input patterns to a unified StateGraphInit object.
      * @internal
      */
      _normalizeToStateGraphInit(stateOrInit, options) {
        if (isStateGraphInit(stateOrInit)) {
          if (isInteropZodObject(options) || AnnotationRoot.isInstance(options)) return {
            ...stateOrInit,
            context: options
          };
          const opts = options;
          return {
            ...stateOrInit,
            input: stateOrInit.input ?? opts?.input,
            output: stateOrInit.output ?? opts?.output,
            context: stateOrInit.context ?? opts?.context,
            interrupt: stateOrInit.interrupt ?? opts?.interrupt,
            writer: stateOrInit.writer ?? opts?.writer,
            nodes: stateOrInit.nodes ?? opts?.nodes
          };
        }
        if (isStateDefinitionInit(stateOrInit)) {
          if (isInteropZodObject(options) || AnnotationRoot.isInstance(options)) return {
            state: stateOrInit,
            context: options
          };
          const opts = options;
          return {
            state: stateOrInit,
            input: opts?.input,
            output: opts?.output,
            context: opts?.context,
            interrupt: opts?.interrupt,
            writer: opts?.writer,
            nodes: opts?.nodes
          };
        }
        if (isStateGraphArgs(stateOrInit)) return { state: _getChannels(stateOrInit.channels) };
        throw new StateGraphInputError();
      }
      /**
      * Convert any supported schema type to a StateDefinition (channel map).
      * @internal
      */
      _getChannelsFromSchema(schema) {
        if (StateSchema.isInstance(schema)) return schema.getChannels();
        if (isInteropZodObject(schema)) return this._metaRegistry.getChannelsForSchema(schema);
        if (typeof schema === "object" && "lc_graph_name" in schema && schema.lc_graph_name === "AnnotationRoot") return schema.spec;
        if (typeof schema === "object" && !Array.isArray(schema) && Object.keys(schema).length > 0) return schema;
        throw new StateGraphInputError("Invalid schema type. Expected StateSchema, Zod object, AnnotationRoot, or StateDefinition.");
      }
      get allEdges() {
        return /* @__PURE__ */ new Set([...this.edges, ...Array.from(this.waitingEdges).flatMap(([starts, end]) => starts.map((start) => [start, end]))]);
      }
      _addSchema(stateDefinition) {
        if (this._schemaDefinitions.has(stateDefinition)) return;
        this._schemaDefinitions.set(stateDefinition, stateDefinition);
        for (const [key, val] of Object.entries(stateDefinition)) {
          let channel;
          if (typeof val === "function") channel = val();
          else channel = val;
          if (this.channels[key] !== void 0) {
            if (!this.channels[key].equals(channel)) {
              if (channel.lc_graph_name !== "LastValue") throw new Error(`Channel "${key}" already exists with a different type.`);
            }
          } else this.channels[key] = channel;
        }
      }
      addNode(...args) {
        function isMultipleNodes(args2) {
          return args2.length >= 1 && typeof args2[0] !== "string";
        }
        const nodes = isMultipleNodes(args) ? Array.isArray(args[0]) ? args[0] : Object.entries(args[0]).map(([key, action]) => [key, action]) : [[
          args[0],
          args[1],
          args[2]
        ]];
        if (nodes.length === 0) throw new Error("No nodes provided in `addNode`");
        for (const [key, action, options] of nodes) {
          if (key in this.channels) throw new Error(`${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);
          for (const reservedChar of [CHECKPOINT_NAMESPACE_SEPARATOR, CHECKPOINT_NAMESPACE_END]) if (key.includes(reservedChar)) throw new Error(`"${reservedChar}" is a reserved character and is not allowed in node names.`);
          this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
          if (key in this.nodes) throw new Error(`Node \`${key}\` already present.`);
          if (key === END || key === START) throw new Error(`Node \`${key}\` is reserved.`);
          let inputSpec = this._schemaDefinition;
          if (options?.input !== void 0) inputSpec = this._getChannelsFromSchema(options.input);
          this._addSchema(inputSpec);
          let runnable;
          if (Runnable.isRunnable(action)) runnable = action;
          else if (typeof action === "function") runnable = new RunnableCallable({
            func: action,
            name: key,
            trace: false
          });
          else runnable = _coerceToRunnable(action);
          let cachePolicy = options?.cachePolicy;
          if (typeof cachePolicy === "boolean") cachePolicy = cachePolicy ? {} : void 0;
          const nodeSpec = {
            runnable,
            retryPolicy: options?.retryPolicy,
            cachePolicy,
            metadata: options?.metadata,
            input: inputSpec ?? this._schemaDefinition,
            subgraphs: isPregelLike(runnable) ? [runnable] : options?.subgraphs,
            ends: options?.ends,
            defer: options?.defer
          };
          this.nodes[key] = nodeSpec;
        }
        return this;
      }
      addEdge(startKey, endKey) {
        if (typeof startKey === "string") return super.addEdge(startKey, endKey);
        if (this.compiled) console.warn("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
        for (const start of startKey) {
          if (start === END) throw new Error("END cannot be a start node");
          if (!Object.keys(this.nodes).some((node) => node === start)) throw new Error(`Need to add a node named "${start}" first`);
        }
        if (endKey === END) throw new Error("END cannot be an end node");
        if (!Object.keys(this.nodes).some((node) => node === endKey)) throw new Error(`Need to add a node named "${endKey}" first`);
        this.waitingEdges.add([startKey, endKey]);
        return this;
      }
      addSequence(nodes) {
        const parsedNodes = Array.isArray(nodes) ? nodes : Object.entries(nodes);
        if (parsedNodes.length === 0) throw new Error("Sequence requires at least one node.");
        let previousNode;
        for (const [key, action, options] of parsedNodes) {
          if (key in this.nodes) throw new Error(`Node names must be unique: node with the name "${key}" already exists.`);
          const validKey = key;
          this.addNode(validKey, action, options);
          if (previousNode != null) this.addEdge(previousNode, validKey);
          previousNode = validKey;
        }
        return this;
      }
      compile({ checkpointer, store, cache: cache2, interruptBefore, interruptAfter, name, description } = {}) {
        this.validate([...Array.isArray(interruptBefore) ? interruptBefore : [], ...Array.isArray(interruptAfter) ? interruptAfter : []]);
        const outputKeys = Object.keys(this._schemaDefinitions.get(this._outputDefinition));
        const outputChannels = outputKeys.length === 1 && outputKeys[0] === ROOT2 ? ROOT2 : outputKeys;
        const streamKeys = Object.keys(this.channels);
        const streamChannels = streamKeys.length === 1 && streamKeys[0] === ROOT2 ? ROOT2 : streamKeys;
        const userInterrupt = this._interrupt;
        const compiled = new CompiledStateGraph({
          builder: this,
          checkpointer,
          interruptAfter,
          interruptBefore,
          autoValidate: false,
          nodes: {},
          channels: {
            ...this.channels,
            [START]: new EphemeralValue()
          },
          inputChannels: START,
          outputChannels,
          streamChannels,
          streamMode: "updates",
          store,
          cache: cache2,
          name,
          description,
          userInterrupt
        });
        compiled.attachNode(START);
        for (const [key, node] of Object.entries(this.nodes)) compiled.attachNode(key, node);
        compiled.attachBranch(START, SELF, _getControlBranch(), { withReader: false });
        for (const [key] of Object.entries(this.nodes)) compiled.attachBranch(key, SELF, _getControlBranch(), { withReader: false });
        for (const [start, end] of this.edges) compiled.attachEdge(start, end);
        for (const [starts, end] of this.waitingEdges) compiled.attachEdge(starts, end);
        for (const [start, branches] of Object.entries(this.branches)) for (const [name2, branch] of Object.entries(branches)) compiled.attachBranch(start, name2, branch);
        return compiled.validate();
      }
    };
    CompiledStateGraph = class extends CompiledGraph {
      /**
      * The description of the compiled graph.
      * This is used by the supervisor agent to describe the handoff to the agent.
      */
      description;
      /** @internal */
      _metaRegistry = schemaMetaRegistry;
      constructor({ description, ...rest }) {
        super(rest);
        this.description = description;
      }
      attachNode(key, node) {
        let outputKeys;
        if (key === START) outputKeys = Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition)).map(([k]) => k);
        else outputKeys = Object.keys(this.builder.channels);
        function _getRoot(input) {
          if (isCommand(input)) {
            if (input.graph === Command.PARENT) return null;
            return input._updateAsTuples();
          } else if (Array.isArray(input) && input.length > 0 && input.some((i) => isCommand(i))) {
            const updates = [];
            for (const i of input) if (isCommand(i)) {
              if (i.graph === Command.PARENT) continue;
              updates.push(...i._updateAsTuples());
            } else updates.push([ROOT2, i]);
            return updates;
          } else if (input != null) return [[ROOT2, input]];
          return null;
        }
        const nodeKey = key;
        function _getUpdates(input) {
          if (!input) return null;
          else if (isCommand(input)) {
            if (input.graph === Command.PARENT) return null;
            return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));
          } else if (Array.isArray(input) && input.length > 0 && input.some(isCommand)) {
            const updates = [];
            for (const item of input) if (isCommand(item)) {
              if (item.graph === Command.PARENT) continue;
              updates.push(...item._updateAsTuples().filter(([k]) => outputKeys.includes(k)));
            } else {
              const itemUpdates = _getUpdates(item);
              if (itemUpdates) updates.push(...itemUpdates ?? []);
            }
            return updates;
          } else if (typeof input === "object" && !Array.isArray(input)) return Object.entries(input).filter(([k]) => outputKeys.includes(k));
          else {
            const typeofInput = Array.isArray(input) ? "array" : typeof input;
            throw new InvalidUpdateError(`Expected node "${nodeKey.toString()}" to return an object or an array containing at least one Command object, received ${typeofInput}`, { lc_error_code: "INVALID_GRAPH_NODE_RETURN_VALUE" });
          }
        }
        const stateWriteEntries = [{
          value: PASSTHROUGH,
          mapper: new RunnableCallable({
            func: outputKeys.length && outputKeys[0] === ROOT2 ? _getRoot : _getUpdates,
            trace: false,
            recurse: false
          })
        }];
        if (key === START) this.nodes[key] = new PregelNode({
          tags: [TAG_HIDDEN],
          triggers: [START],
          channels: [START],
          writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])]
        });
        else {
          const inputDefinition = node?.input ?? this.builder._schemaDefinition;
          const inputValues = Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map((k) => [k, k]));
          const isSingleInput = Object.keys(inputValues).length === 1 && ROOT2 in inputValues;
          const branchChannel = `branch:to:${key}`;
          this.channels[branchChannel] = node?.defer ? new LastValueAfterFinish() : new EphemeralValue(false);
          this.nodes[key] = new PregelNode({
            triggers: [branchChannel],
            channels: isSingleInput ? Object.keys(inputValues) : inputValues,
            writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],
            mapper: isSingleInput ? void 0 : (input) => {
              return Object.fromEntries(Object.entries(input).filter(([k]) => k in inputValues));
            },
            bound: node?.runnable,
            metadata: node?.metadata,
            retryPolicy: node?.retryPolicy,
            cachePolicy: node?.cachePolicy,
            subgraphs: node?.subgraphs,
            ends: node?.ends
          });
        }
      }
      attachEdge(starts, end) {
        if (end === END) return;
        if (typeof starts === "string") this.nodes[starts].writers.push(new ChannelWrite([{
          channel: `branch:to:${end}`,
          value: null
        }], [TAG_HIDDEN]));
        else if (Array.isArray(starts)) {
          const channelName = `join:${starts.join("+")}:${end}`;
          this.channels[channelName] = this.builder.nodes[end].defer ? new NamedBarrierValueAfterFinish(new Set(starts)) : new NamedBarrierValue(new Set(starts));
          this.nodes[end].triggers.push(channelName);
          for (const start of starts) this.nodes[start].writers.push(new ChannelWrite([{
            channel: channelName,
            value: start
          }], [TAG_HIDDEN]));
        }
      }
      attachBranch(start, _, branch, options = { withReader: true }) {
        const branchWriter = async (packets, config2) => {
          const filteredPackets = packets.filter((p) => p !== END);
          if (!filteredPackets.length) return;
          const writes = filteredPackets.map((p) => {
            if (_isSend(p)) return p;
            return {
              channel: p === END ? p : `branch:to:${p}`,
              value: start
            };
          });
          await ChannelWrite.doWrite({
            ...config2,
            tags: (config2.tags ?? []).concat([TAG_HIDDEN])
          }, writes);
        };
        this.nodes[start].writers.push(branch.run(branchWriter, options.withReader ? (config2) => ChannelRead.doRead(config2, this.streamChannels ?? this.outputChannels, true) : void 0));
      }
      async _validateInput(input) {
        if (input == null) return input;
        const inputDef = this.builder._inputRuntimeDefinition;
        const schemaDef = this.builder._schemaRuntimeDefinition;
        if (StateSchema.isInstance(inputDef)) {
          if (isCommand(input)) {
            const parsedInput = input;
            if (input.update) parsedInput.update = await inputDef.validateInput(Array.isArray(input.update) ? Object.fromEntries(input.update) : input.update);
            return parsedInput;
          }
          return await inputDef.validateInput(input);
        }
        if (inputDef === PartialStateSchema && StateSchema.isInstance(schemaDef)) {
          if (isCommand(input)) {
            const parsedInput = input;
            if (input.update) parsedInput.update = await schemaDef.validateInput(Array.isArray(input.update) ? Object.fromEntries(input.update) : input.update);
            return parsedInput;
          }
          return await schemaDef.validateInput(input);
        }
        const schema = (() => {
          const apply = (schema2) => {
            if (schema2 == null) return void 0;
            return this._metaRegistry.getExtendedChannelSchemas(schema2, { withReducerSchema: true });
          };
          if (isInteropZodObject(inputDef)) return apply(inputDef);
          if (inputDef === PartialStateSchema) {
            if (isInteropZodObject(schemaDef)) return interopZodObjectPartial(apply(schemaDef));
            return;
          }
        })();
        if (isCommand(input)) {
          const parsedInput = input;
          if (input.update && schema != null) parsedInput.update = interopParse(schema, input.update);
          return parsedInput;
        }
        if (schema != null) return interopParse(schema, input);
        return input;
      }
      isInterrupted(input) {
        return isInterrupted(input);
      }
      async _validateContext(config2) {
        const configSchema = this.builder._configRuntimeSchema;
        if (isInteropZodObject(configSchema)) interopParse(configSchema, config2);
        return config2;
      }
    };
  }
});

// node_modules/@langchain/langgraph/dist/graph/message.js
var init_message2 = __esm({
  "node_modules/@langchain/langgraph/dist/graph/message.js"() {
    init_config2();
    init_messages_reducer();
    init_state2();
    init_messages2();
  }
});

// node_modules/@langchain/langgraph/dist/func/index.js
var entrypoint;
var init_func = __esm({
  "node_modules/@langchain/langgraph/dist/func/index.js"() {
    init_last_value();
    init_constants3();
    init_utils8();
    init_write();
    init_read();
    init_call();
    init_pregel();
    init_ephemeral_value();
    init_singletons();
    entrypoint = function entrypoint2(optionsOrName, func) {
      const { name, checkpointer, store, cache: cache2 } = typeof optionsOrName === "string" ? {
        name: optionsOrName,
        checkpointer: void 0,
        store: void 0
      } : optionsOrName;
      if (isAsyncGeneratorFunction(func) || isGeneratorFunction(func)) throw new Error("Generators are disallowed as entrypoints. For streaming responses, use config.write.");
      const streamMode = "updates";
      const bound = getRunnableForEntrypoint(name, func);
      function isEntrypointFinal(value) {
        return typeof value === "object" && value !== null && "__lg_type" in value && value.__lg_type === "__pregel_final";
      }
      const pluckReturnValue = new RunnableCallable({
        name: "pluckReturnValue",
        func: (value) => {
          return isEntrypointFinal(value) ? value.value : value;
        }
      });
      const pluckSaveValue = new RunnableCallable({
        name: "pluckSaveValue",
        func: (value) => {
          return isEntrypointFinal(value) ? value.save : value;
        }
      });
      const entrypointNode = new PregelNode({
        bound,
        triggers: [START],
        channels: [START],
        writers: [new ChannelWrite([{
          channel: END,
          value: PASSTHROUGH,
          mapper: pluckReturnValue
        }, {
          channel: PREVIOUS,
          value: PASSTHROUGH,
          mapper: pluckSaveValue
        }], [TAG_HIDDEN])]
      });
      return new Pregel({
        name,
        checkpointer,
        nodes: { [name]: entrypointNode },
        channels: {
          [START]: new EphemeralValue(),
          [END]: new LastValue(),
          [PREVIOUS]: new LastValue()
        },
        inputChannels: START,
        outputChannels: END,
        streamChannels: END,
        streamMode,
        store,
        cache: cache2
      });
    };
    entrypoint.final = function final({ value, save }) {
      return {
        value,
        save,
        __lg_type: "__pregel_final"
      };
    };
  }
});

// node_modules/@langchain/langgraph/dist/graph/messages_annotation.js
var MessagesAnnotation, MessagesZodMeta, MessagesZodState;
var init_messages_annotation = __esm({
  "node_modules/@langchain/langgraph/dist/graph/messages_annotation.js"() {
    init_annotation();
    init_messages_reducer();
    init_meta();
    init_v3();
    MessagesAnnotation = Annotation.Root({ messages: Annotation({
      reducer: messagesStateReducer,
      default: () => []
    }) });
    MessagesZodMeta = {
      reducer: { fn: messagesStateReducer },
      jsonSchemaExtra: { langgraph_type: "messages" },
      default: () => []
    };
    MessagesZodState = external_exports.object({ messages: withLangGraph(external_exports.custom(), MessagesZodMeta) });
  }
});

// node_modules/@langchain/langgraph/dist/graph/index.js
var init_graph3 = __esm({
  "node_modules/@langchain/langgraph/dist/graph/index.js"() {
    init_annotation();
    init_constants3();
    init_graph2();
    init_messages_reducer();
    init_state2();
    init_message2();
  }
});

// node_modules/@langchain/langgraph/dist/web.js
var init_web = __esm({
  "node_modules/@langchain/langgraph/dist/web.js"() {
    init_errors3();
    init_base15();
    init_binop();
    init_annotation();
    init_constants3();
    init_graph2();
    init_types7();
    init_adapter();
    init_untracked_value();
    init_channels();
    init_reduced();
    init_untracked();
    init_schema();
    init_messages_reducer();
    init_messages4();
    init_state();
    init_state2();
    init_message2();
    init_graph3();
    init_func();
    init_messages_annotation();
    init_dist3();
  }
});

// node_modules/@langchain/langgraph/dist/writer.js
var init_writer = __esm({
  "node_modules/@langchain/langgraph/dist/writer.js"() {
    init_singletons();
  }
});

// node_modules/@langchain/langgraph/dist/index.js
var init_dist4 = __esm({
  "node_modules/@langchain/langgraph/dist/index.js"() {
    init_async_local_storage2();
    init_errors3();
    init_base15();
    init_binop();
    init_annotation();
    init_constants3();
    init_config2();
    init_interrupt();
    init_graph2();
    init_types7();
    init_adapter();
    init_untracked_value();
    init_reduced();
    init_untracked();
    init_schema();
    init_messages_reducer();
    init_messages4();
    init_state2();
    init_message2();
    init_func();
    init_messages_annotation();
    init_web();
    init_writer();
    initializeAsyncLocalStorageSingleton();
  }
});

// node_modules/@langchain/openai/dist/utils/errors.js
function addLangChainErrorFields2(error40, lc_error_code) {
  error40.lc_error_code = lc_error_code;
  error40.message = `${error40.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/
`;
  return error40;
}
var init_errors6 = __esm({
  "node_modules/@langchain/openai/dist/utils/errors.js"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
var init_tslib = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/tslib.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/uuid.mjs
var uuid42;
var init_uuid3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/uuid.mjs"() {
    uuid42 = function() {
      const { crypto: crypto12 } = globalThis;
      if (crypto12?.randomUUID) {
        uuid42 = crypto12.randomUUID.bind(crypto12);
        return crypto12.randomUUID();
      }
      const u8 = new Uint8Array(1);
      const randomByte = crypto12 ? () => crypto12.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
      return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError;
var init_errors7 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/errors.mjs"() {
    castToError = (err) => {
      if (err instanceof Error)
        return err;
      if (typeof err === "object" && err !== null) {
        try {
          if (Object.prototype.toString.call(err) === "[object Error]") {
            const error40 = new Error(err.message, err.cause ? { cause: err.cause } : {});
            if (err.stack)
              error40.stack = err.stack;
            if (err.cause && !error40.cause)
              error40.cause = err.cause;
            if (err.name)
              error40.name = err.name;
            return error40;
          }
        } catch {
        }
        try {
          return new Error(JSON.stringify(err));
        } catch {
        }
      }
      return new Error(err);
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/core/error.mjs
var OpenAIError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError, LengthFinishReasonError, ContentFilterFinishReasonError, InvalidWebhookSignatureError;
var init_error2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/core/error.mjs"() {
    init_errors7();
    OpenAIError = class extends Error {
    };
    APIError = class _APIError extends OpenAIError {
      constructor(status, error40, message, headers) {
        super(`${_APIError.makeMessage(status, error40, message)}`);
        this.status = status;
        this.headers = headers;
        this.requestID = headers?.get("x-request-id");
        this.error = error40;
        const data = error40;
        this.code = data?.["code"];
        this.param = data?.["param"];
        this.type = data?.["type"];
      }
      static makeMessage(status, error40, message) {
        const msg = error40?.message ? typeof error40.message === "string" ? error40.message : JSON.stringify(error40.message) : error40 ? JSON.stringify(error40) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: castToError(errorResponse) });
        }
        const error40 = errorResponse?.["error"];
        if (status === 400) {
          return new BadRequestError(status, error40, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error40, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error40, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error40, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error40, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error40, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error40, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error40, message, headers);
        }
        return new _APIError(status, error40, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message ?? "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
    };
    AuthenticationError = class extends APIError {
    };
    PermissionDeniedError = class extends APIError {
    };
    NotFoundError = class extends APIError {
    };
    ConflictError = class extends APIError {
    };
    UnprocessableEntityError = class extends APIError {
    };
    RateLimitError = class extends APIError {
    };
    InternalServerError = class extends APIError {
    };
    LengthFinishReasonError = class extends OpenAIError {
      constructor() {
        super(`Could not parse response content as the length limit was reached`);
      }
    };
    ContentFilterFinishReasonError = class extends OpenAIError {
      constructor() {
        super(`Could not parse response content as the request was rejected by the content filter`);
      }
    };
    InvalidWebhookSignatureError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/values.mjs
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
var startsWithSchemeRegexp, isAbsoluteURL, isArray2, isReadonlyArray, validatePositiveInteger, safeJSON;
var init_values2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/values.mjs"() {
    init_error2();
    startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    isAbsoluteURL = (url2) => {
      return startsWithSchemeRegexp.test(url2);
    };
    isArray2 = (val) => (isArray2 = Array.isArray, isArray2(val));
    isReadonlyArray = isArray2;
    validatePositiveInteger = (name, n2) => {
      if (typeof n2 !== "number" || !Number.isInteger(n2)) {
        throw new OpenAIError(`${name} must be an integer`);
      }
      if (n2 < 0) {
        throw new OpenAIError(`${name} must be a positive integer`);
      }
      return n2;
    };
    safeJSON = (text2) => {
      try {
        return JSON.parse(text2);
      } catch (err) {
        return void 0;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/sleep.mjs
var sleep;
var init_sleep = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/sleep.mjs"() {
    sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  }
});

// node_modules/@langchain/openai/node_modules/openai/version.mjs
var VERSION;
var init_version = __esm({
  "node_modules/@langchain/openai/node_modules/openai/version.mjs"() {
    VERSION = "6.17.0";
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/detect-platform.mjs
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var isRunningInBrowser, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders;
var init_detect_platform = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/detect-platform.mjs"() {
    init_version();
    isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== "undefined" && // @ts-ignore
        typeof window.document !== "undefined" && // @ts-ignore
        typeof navigator !== "undefined"
      );
    };
    getPlatformProperties = () => {
      const detectedPlatform = getDetectedPlatform();
      if (detectedPlatform === "deno") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": globalThis.process.version
        };
      }
      if (detectedPlatform === "node") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
          "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    };
    normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    getPlatformHeaders = () => {
      return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}
var init_shims = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/shims.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/request-options.mjs
var FallbackEncoder;
var init_request_options = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/request-options.mjs"() {
    FallbackEncoder = ({ headers, body }) => {
      return {
        bodyHeaders: {
          "content-type": "application/json"
        },
        body: JSON.stringify(body)
      };
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/qs/formats.mjs
var default_format, default_formatter, formatters, RFC1738;
var init_formats = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/qs/formats.mjs"() {
    default_format = "RFC3986";
    default_formatter = (v) => String(v);
    formatters = {
      RFC1738: (v) => String(v).replace(/%20/g, "+"),
      RFC3986: default_formatter
    };
    RFC1738 = "RFC1738";
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/qs/utils.mjs
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray2(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}
var has, hex_table, limit, encode;
var init_utils10 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/qs/utils.mjs"() {
    init_formats();
    init_values2();
    has = (obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key));
    hex_table = /* @__PURE__ */ (() => {
      const array2 = [];
      for (let i = 0; i < 256; ++i) {
        array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array2;
    })();
    limit = 1024;
    encode = (str2, _defaultEncoder, charset, _kind, format2) => {
      if (str2.length === 0) {
        return str2;
      }
      let string4 = str2;
      if (typeof str2 === "symbol") {
        string4 = Symbol.prototype.toString.call(str2);
      } else if (typeof str2 !== "string") {
        string4 = String(str2);
      }
      if (charset === "iso-8859-1") {
        return escape(string4).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      let out = "";
      for (let j = 0; j < string4.length; j += limit) {
        const segment = string4.length >= limit ? string4.slice(j, j + limit) : string4;
        const arr3 = [];
        for (let i = 0; i < segment.length; ++i) {
          let c = segment.charCodeAt(i);
          if (c === 45 || // -
          c === 46 || // .
          c === 95 || // _
          c === 126 || // ~
          c >= 48 && c <= 57 || // 0-9
          c >= 65 && c <= 90 || // a-z
          c >= 97 && c <= 122 || // A-Z
          format2 === RFC1738 && (c === 40 || c === 41)) {
            arr3[arr3.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr3[arr3.length] = hex_table[c];
            continue;
          }
          if (c < 2048) {
            arr3[arr3.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr3[arr3.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr3[arr3.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        }
        out += arr3.join("");
      }
      return out;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/qs/stringify.mjs
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
function inner_stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder2, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object2;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder2 && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder2(prefix, defaults.encoder, charset, "key", format2)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder2) {
      const key_value = encodeValuesOnly ? prefix : encoder2(prefix, defaults.encoder, charset, "key", format2);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder2(obj, defaults.encoder, charset, "value", format2))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray2(obj)) {
    if (encodeValuesOnly && encoder2) {
      obj = maybe_map(obj, encoder2);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object2, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder2,
      filter,
      sort,
      allowDots,
      serializeDate,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format2 = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  const formatter = formatters[format2];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify2(object2, opts = {}) {
  let obj = object2;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
var array_prefix_generators, push_to_array, toISOString, defaults, sentinel;
var init_stringify5 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/qs/stringify.mjs"() {
    init_utils10();
    init_formats();
    init_values2();
    array_prefix_generators = {
      brackets(prefix) {
        return String(prefix) + "[]";
      },
      comma: "comma",
      indices(prefix, key) {
        return String(prefix) + "[" + key + "]";
      },
      repeat(prefix) {
        return String(prefix);
      }
    };
    push_to_array = function(arr3, value_or_array) {
      Array.prototype.push.apply(arr3, isArray2(value_or_array) ? value_or_array : [value_or_array]);
    };
    defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: encode,
      encodeValuesOnly: false,
      format: default_format,
      formatter: default_formatter,
      /** @deprecated */
      indices: false,
      serializeDate(date6) {
        return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date6);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    sentinel = {};
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/qs/index.mjs
var init_qs = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/qs/index.mjs"() {
    init_formats();
    init_stringify5();
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index2 = 0;
  for (const buffer of buffers) {
    output.set(buffer, index2);
    index2 += buffer.length;
  }
  return output;
}
function encodeUTF8(str2) {
  let encoder2;
  return (encodeUTF8_ ?? (encoder2 = new globalThis.TextEncoder(), encodeUTF8_ = encoder2.encode.bind(encoder2)))(str2);
}
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}
var encodeUTF8_, decodeUTF8_;
var init_bytes2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/bytes.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/decoders/line.mjs
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex, LineDecoder;
var init_line = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/decoders/line.mjs"() {
    init_tslib();
    init_bytes2();
    LineDecoder = class {
      constructor() {
        _LineDecoder_buffer.set(this, void 0);
        _LineDecoder_carriageReturnIndex.set(this, void 0);
        __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
      }
      decode(chunk) {
        if (chunk == null) {
          return [];
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
        __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
        const lines = [];
        let patternIndex;
        while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
          if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
            continue;
          }
          if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
            lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
            __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
            continue;
          }
          const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
          const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
          lines.push(line);
          __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
          __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        }
        return lines;
      }
      flush() {
        if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
          return [];
        }
        return this.decode("\n");
      }
    };
    _LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/log.mjs
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
function loggerFor(client2) {
  const logger = client2.logger;
  const logLevel = client2.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var levelNumbers, parseLogLevel, noopLogger, cachedLoggers, formatRequestDetails;
var init_log = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/log.mjs"() {
    init_values2();
    levelNumbers = {
      off: 0,
      error: 200,
      warn: 300,
      info: 400,
      debug: 500
    };
    parseLogLevel = (maybeLevel, sourceName, client2) => {
      if (!maybeLevel) {
        return void 0;
      }
      if (hasOwn(levelNumbers, maybeLevel)) {
        return maybeLevel;
      }
      loggerFor(client2).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
      return void 0;
    };
    noopLogger = {
      error: noop,
      warn: noop,
      info: noop,
      debug: noop
    };
    cachedLoggers = /* @__PURE__ */ new WeakMap();
    formatRequestDetails = (details) => {
      if (details.options) {
        details.options = { ...details.options };
        delete details.options["headers"];
      }
      if (details.headers) {
        details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
          name,
          name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
        ]));
      }
      if ("retryOfRequestLogID" in details) {
        if (details.retryOfRequestLogID) {
          details.retryOf = details.retryOfRequestLogID;
        }
        delete details.retryOfRequestLogID;
      }
      return details;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/core/streaming.mjs
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
var _Stream_client, Stream, SSEDecoder;
var init_streaming = __esm({
  "node_modules/@langchain/openai/node_modules/openai/core/streaming.mjs"() {
    init_tslib();
    init_error2();
    init_shims();
    init_line();
    init_shims();
    init_errors7();
    init_bytes2();
    init_log();
    init_error2();
    Stream = class _Stream {
      constructor(iterator, controller, client2) {
        this.iterator = iterator;
        _Stream_client.set(this, void 0);
        this.controller = controller;
        __classPrivateFieldSet(this, _Stream_client, client2, "f");
      }
      static fromSSEResponse(response, controller, client2) {
        let consumed = false;
        const logger = client2 ? loggerFor(client2) : console;
        async function* iterator() {
          if (consumed) {
            throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of _iterSSEMessages(response, controller)) {
              if (done)
                continue;
              if (sse.data.startsWith("[DONE]")) {
                done = true;
                continue;
              }
              if (sse.event === null || !sse.event.startsWith("thread.")) {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e) {
                  logger.error(`Could not parse message into JSON:`, sse.data);
                  logger.error(`From chunk:`, sse.raw);
                  throw e;
                }
                if (data && data.error) {
                  throw new APIError(void 0, data.error, void 0, response.headers);
                }
                yield data;
              } else {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
                if (sse.event == "error") {
                  throw new APIError(void 0, data.error, data.message, void 0);
                }
                yield { event: sse.event, data };
              }
            }
            done = true;
          } catch (e) {
            if (isAbortError(e))
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller, client2);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller, client2) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new LineDecoder();
          const iter = ReadableStreamToAsyncIterable(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done)
                continue;
              if (line)
                yield JSON.parse(line);
            }
            done = true;
          } catch (e) {
            if (isAbortError(e))
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller, client2);
      }
      [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue2) => {
          return {
            next: () => {
              if (queue2.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue2.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
          new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self2 = this;
        let iter;
        return makeReadableStream({
          async start() {
            iter = self2[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = encodeUTF8(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            await iter.return?.();
          }
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/parse.mjs
async function defaultParseResponse(client2, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client2).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client2);
      }
      return Stream.fromSSEResponse(response, props.controller, client2);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json2 = await response.json();
      return addRequestID(json2, response);
    }
    const text2 = await response.text();
    return text2;
  })();
  loggerFor(client2).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var init_parse6 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/parse.mjs"() {
    init_streaming();
    init_log();
  }
});

// node_modules/@langchain/openai/node_modules/openai/core/api-promise.mjs
var _APIPromise_client, APIPromise;
var init_api_promise = __esm({
  "node_modules/@langchain/openai/node_modules/openai/core/api-promise.mjs"() {
    init_tslib();
    init_parse6();
    APIPromise = class _APIPromise extends Promise {
      constructor(client2, responsePromise, parseResponse2 = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse2;
        _APIPromise_client.set(this, void 0);
        __classPrivateFieldSet(this, _APIPromise_client, client2, "f");
      }
      _thenUnwrap(transform2) {
        return new _APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client2, props) => addRequestID(transform2(await this.parseResponse(client2, props), props), props.response));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data, the raw `Response` instance and the ID of the request,
       * returned via the X-Request-ID header which is useful for debugging requests and reporting
       * issues to OpenAI.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get("x-request-id") };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    _APIPromise_client = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@langchain/openai/node_modules/openai/core/pagination.mjs
var _AbstractPage_client, AbstractPage, PagePromise, Page, CursorPage, ConversationCursorPage;
var init_pagination = __esm({
  "node_modules/@langchain/openai/node_modules/openai/core/pagination.mjs"() {
    init_tslib();
    init_error2();
    init_parse6();
    init_api_promise();
    init_values2();
    AbstractPage = class {
      constructor(client2, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client2, "f");
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageRequestOptions() != null;
      }
      async getNextPage() {
        const nextOptions = this.nextPageRequestOptions();
        if (!nextOptions) {
          throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      constructor(client2, request, Page2) {
        super(client2, request, async (client3, props) => new Page2(client3, props.response, await defaultParseResponse(client3, props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    Page = class extends AbstractPage {
      constructor(client2, response, body, options) {
        super(client2, response, body, options);
        this.data = body.data || [];
        this.object = body.object;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      nextPageRequestOptions() {
        return null;
      }
    };
    CursorPage = class extends AbstractPage {
      constructor(client2, response, body, options) {
        super(client2, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      hasNextPage() {
        if (this.has_more === false) {
          return false;
        }
        return super.hasNextPage();
      }
      nextPageRequestOptions() {
        const data = this.getPaginatedItems();
        const id = data[data.length - 1]?.id;
        if (!id) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...maybeObj(this.options.query),
            after: id
          }
        };
      }
    };
    ConversationCursorPage = class extends AbstractPage {
      constructor(client2, response, body, options) {
        super(client2, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
        this.last_id = body.last_id || "";
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      hasNextPage() {
        if (this.has_more === false) {
          return false;
        }
        return super.hasNextPage();
      }
      nextPageRequestOptions() {
        const cursor = this.last_id;
        if (!cursor) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...maybeObj(this.options.query),
            after: cursor
          }
        };
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/uploads.mjs
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached2 = supportsFormDataMap.get(fetch2);
  if (cached2)
    return cached2;
  const promise2 = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise2);
  return promise2;
}
var checkFileSupport, isAsyncIterable2, maybeMultipartFormRequestOptions, multipartFormRequestOptions, supportsFormDataMap, createForm, isNamedBlob, isUploadable, hasUploadableValue, addFormValue;
var init_uploads = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/uploads.mjs"() {
    init_shims();
    checkFileSupport = () => {
      if (typeof File === "undefined") {
        const { process: process2 } = globalThis;
        const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
        throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
      }
    };
    isAsyncIterable2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    maybeMultipartFormRequestOptions = async (opts, fetch2) => {
      if (!hasUploadableValue(opts.body))
        return opts;
      return { ...opts, body: await createForm(opts.body, fetch2) };
    };
    multipartFormRequestOptions = async (opts, fetch2) => {
      return { ...opts, body: await createForm(opts.body, fetch2) };
    };
    supportsFormDataMap = /* @__PURE__ */ new WeakMap();
    createForm = async (body, fetch2) => {
      if (!await supportsFormData(fetch2)) {
        throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
      }
      const form = new FormData();
      await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
      return form;
    };
    isNamedBlob = (value) => value instanceof Blob && "name" in value;
    isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable2(value) || isNamedBlob(value));
    hasUploadableValue = (value) => {
      if (isUploadable(value))
        return true;
      if (Array.isArray(value))
        return value.some(hasUploadableValue);
      if (value && typeof value === "object") {
        for (const k in value) {
          if (hasUploadableValue(value[k]))
            return true;
        }
      }
      return false;
    };
    addFormValue = async (form, key, value) => {
      if (value === void 0)
        return;
      if (value == null) {
        throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
      }
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        form.append(key, String(value));
      } else if (value instanceof Response) {
        form.append(key, makeFile([await value.blob()], getName(value)));
      } else if (isAsyncIterable2(value)) {
        form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
      } else if (isNamedBlob(value)) {
        form.append(key, value, getName(value));
      } else if (Array.isArray(value)) {
        await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
      } else if (typeof value === "object") {
        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
      } else {
        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/to-file.mjs
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes2(blob), name, options);
  }
  const parts = await getBytes2(value);
  name || (name = getName(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes2(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable2(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes2(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
var isBlobLike, isFileLike, isResponseLike;
var init_to_file = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/to-file.mjs"() {
    init_uploads();
    init_uploads();
    isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  }
});

// node_modules/@langchain/openai/node_modules/openai/core/uploads.mjs
var init_uploads2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/core/uploads.mjs"() {
    init_to_file();
  }
});

// node_modules/@langchain/openai/node_modules/openai/core/resource.mjs
var APIResource;
var init_resource = __esm({
  "node_modules/@langchain/openai/node_modules/openai/core/resource.mjs"() {
    APIResource = class {
      constructor(client2) {
        this._client = client2;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/path.mjs
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY, createPathTagFunction, path2;
var init_path = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/path.mjs"() {
    init_error2();
    EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
    createPathTagFunction = (pathEncoder = encodeURIPath) => function path3(statics, ...params) {
      if (statics.length === 1)
        return statics[0];
      let postPath = false;
      const invalidSegments = [];
      const path4 = statics.reduce((previousValue, currentValue, index2) => {
        if (/[?#]/.test(currentValue)) {
          postPath = true;
        }
        const value = params[index2];
        let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
        if (index2 !== params.length && (value == null || typeof value === "object" && // handle values from other realms
        value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
          encoded = value + "";
          invalidSegments.push({
            start: previousValue.length + currentValue.length,
            length: encoded.length,
            error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
          });
        }
        return previousValue + currentValue + (index2 === params.length ? "" : encoded);
      }, "");
      const pathOnly = path4.split(/[?#]/, 1)[0];
      const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
      let match;
      while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
        invalidSegments.push({
          start: match.index,
          length: match[0].length,
          error: `Value "${match[0]}" can't be safely passed as a path parameter`
        });
      }
      invalidSegments.sort((a, b) => a.start - b.start);
      if (invalidSegments.length > 0) {
        let lastEnd = 0;
        const underline = invalidSegments.reduce((acc, segment) => {
          const spaces = " ".repeat(segment.start - lastEnd);
          const arrows = "^".repeat(segment.length);
          lastEnd = segment.start + segment.length;
          return acc + spaces + arrows;
        }, "");
        throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path4}
${underline}`);
      }
      return path4;
    };
    path2 = /* @__PURE__ */ createPathTagFunction(encodeURIPath);
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/chat/completions/messages.mjs
var Messages;
var init_messages5 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/chat/completions/messages.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    Messages = class extends APIResource {
      /**
       * Get the messages in a stored chat completion. Only Chat Completions that have
       * been created with the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
       *   'completion_id',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(completionID, query = {}, options) {
        return this._client.getAPIList(path2`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/error.mjs
var init_error3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/error.mjs"() {
    init_error2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool2) {
  return tool2 !== void 0 && "function" in tool2 && tool2.function !== void 0;
}
function makeParseableResponseFormat(response_format, parser) {
  const obj = { ...response_format };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    }
  });
  return obj;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool2) {
  return tool2?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall2(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall2(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools2) {
  for (const tool2 of tools2 ?? []) {
    if (tool2.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool2.type}\``);
    }
    if (tool2.function.strict !== true) {
      throw new OpenAIError(`The \`${tool2.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}
var init_parser = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/parser.mjs"() {
    init_error3();
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage, isToolMessage2;
var init_chatCompletionUtils = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/chatCompletionUtils.mjs"() {
    isAssistantMessage = (message) => {
      return message?.role === "assistant";
    };
    isToolMessage2 = (message) => {
      return message?.role === "tool";
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/EventStream.mjs
var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError, EventStream;
var init_EventStream = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/EventStream.mjs"() {
    init_tslib();
    init_error3();
    EventStream = class {
      constructor() {
        _EventStream_instances.add(this);
        this.controller = new AbortController();
        _EventStream_connectedPromise.set(this, void 0);
        _EventStream_resolveConnectedPromise.set(this, () => {
        });
        _EventStream_rejectConnectedPromise.set(this, () => {
        });
        _EventStream_endPromise.set(this, void 0);
        _EventStream_resolveEndPromise.set(this, () => {
        });
        _EventStream_rejectEndPromise.set(this, () => {
        });
        _EventStream_listeners.set(this, {});
        _EventStream_ended.set(this, false);
        _EventStream_errored.set(this, false);
        _EventStream_aborted.set(this, false);
        _EventStream_catchingPromiseCreated.set(this, false);
        __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
          __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {
          __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
          __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {
        });
      }
      _run(executor) {
        setTimeout(() => {
          executor().then(() => {
            this._emitFinal();
            this._emit("end");
          }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
        }, 0);
      }
      _connected() {
        if (this.ended)
          return;
        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet(this, _EventStream_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet(this, _EventStream_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet(this, _EventStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index2 = listeners.findIndex((l) => l.listener === listener);
        if (index2 >= 0)
          listeners.splice(index2, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
          return;
        }
        if (event === "end") {
          __classPrivateFieldSet(this, _EventStream_ended, true, "f");
          __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error40 = args[0];
          if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
            Promise.reject(error40);
          }
          __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error40);
          __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error40);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error40 = args[0];
          if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
            Promise.reject(error40);
          }
          __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error40);
          __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error40);
          this._emit("end");
        }
      }
      _emitFinal() {
      }
    };
    _EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error40) {
      __classPrivateFieldSet(this, _EventStream_errored, true, "f");
      if (error40 instanceof Error && error40.name === "AbortError") {
        error40 = new APIUserAbortError();
      }
      if (error40 instanceof APIUserAbortError) {
        __classPrivateFieldSet(this, _EventStream_aborted, true, "f");
        return this._emit("abort", error40);
      }
      if (error40 instanceof OpenAIError) {
        return this._emit("error", error40);
      }
      if (error40 instanceof Error) {
        const openAIError = new OpenAIError(error40.message);
        openAIError.cause = error40;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new OpenAIError(String(error40)));
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
var init_RunnableFunction = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/RunnableFunction.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionToolCall, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult, DEFAULT_MAX_CHAT_COMPLETIONS, AbstractChatCompletionRunner;
var init_AbstractChatCompletionRunner = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/AbstractChatCompletionRunner.mjs"() {
    init_tslib();
    init_error3();
    init_parser();
    init_chatCompletionUtils();
    init_EventStream();
    init_RunnableFunction();
    DEFAULT_MAX_CHAT_COMPLETIONS = 10;
    AbstractChatCompletionRunner = class extends EventStream {
      constructor() {
        super(...arguments);
        _AbstractChatCompletionRunner_instances.add(this);
        this._chatCompletions = [];
        this.messages = [];
      }
      _addChatCompletion(chatCompletion) {
        this._chatCompletions.push(chatCompletion);
        this._emit("chatCompletion", chatCompletion);
        const message = chatCompletion.choices[0]?.message;
        if (message)
          this._addMessage(message);
        return chatCompletion;
      }
      _addMessage(message, emit = true) {
        if (!("content" in message))
          message.content = null;
        this.messages.push(message);
        if (emit) {
          this._emit("message", message);
          if (isToolMessage2(message) && message.content) {
            this._emit("functionToolCallResult", message.content);
          } else if (isAssistantMessage(message) && message.tool_calls) {
            for (const tool_call of message.tool_calls) {
              if (tool_call.type === "function") {
                this._emit("functionToolCall", tool_call.function);
              }
            }
          }
        }
      }
      /**
       * @returns a promise that resolves with the final ChatCompletion, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
       */
      async finalChatCompletion() {
        await this.done();
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (!completion)
          throw new OpenAIError("stream ended without producing a ChatCompletion");
        return completion;
      }
      /**
       * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalContent() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
       * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the content of the final FunctionCall, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalFunctionToolCall() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
      }
      async finalFunctionToolCallResult() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
      }
      async totalUsage() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
      }
      allChatCompletions() {
        return [...this._chatCompletions];
      }
      _emitFinal() {
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (completion)
          this._emit("finalChatCompletion", completion);
        const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
        if (finalMessage)
          this._emit("finalMessage", finalMessage);
        const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
        if (finalContent)
          this._emit("finalContent", finalContent);
        const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
        if (finalFunctionCall)
          this._emit("finalFunctionToolCall", finalFunctionCall);
        const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
        if (finalFunctionCallResult != null)
          this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
        if (this._chatCompletions.some((c) => c.usage)) {
          this._emit("totalUsage", __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
        }
      }
      async _createChatCompletion(client2, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
        const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
        this._connected();
        return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
      }
      async _runChatCompletion(client2, params, options) {
        for (const message of params.messages) {
          this._addMessage(message, false);
        }
        return await this._createChatCompletion(client2, params, options);
      }
      async _runTools(client2, params, options) {
        const role = "tool";
        const { tool_choice = "auto", stream, ...restParams } = params;
        const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && tool_choice?.function?.name;
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
        const inputTools = params.tools.map((tool2) => {
          if (isAutoParsableTool(tool2)) {
            if (!tool2.$callback) {
              throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
            }
            return {
              type: "function",
              function: {
                function: tool2.$callback,
                name: tool2.function.name,
                description: tool2.function.description || "",
                parameters: tool2.function.parameters,
                parse: tool2.$parseRaw,
                strict: true
              }
            };
          }
          return tool2;
        });
        const functionsByName = {};
        for (const f of inputTools) {
          if (f.type === "function") {
            functionsByName[f.function.name || f.function.function.name] = f.function;
          }
        }
        const tools2 = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
          type: "function",
          function: {
            name: t.function.name || t.function.function.name,
            parameters: t.function.parameters,
            description: t.function.description,
            strict: t.function.strict
          }
        } : t) : void 0;
        for (const message of params.messages) {
          this._addMessage(message, false);
        }
        for (let i = 0; i < maxChatCompletions; ++i) {
          const chatCompletion = await this._createChatCompletion(client2, {
            ...restParams,
            tool_choice,
            tools: tools2,
            messages: [...this.messages]
          }, options);
          const message = chatCompletion.choices[0]?.message;
          if (!message) {
            throw new OpenAIError(`missing message in ChatCompletion response`);
          }
          if (!message.tool_calls?.length) {
            return;
          }
          for (const tool_call of message.tool_calls) {
            if (tool_call.type !== "function")
              continue;
            const tool_call_id = tool_call.id;
            const { name, arguments: args } = tool_call.function;
            const fn = functionsByName[name];
            if (!fn) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            } else if (singleFunctionToCall && singleFunctionToCall !== name) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            let parsed;
            try {
              parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
            } catch (error40) {
              const content2 = error40 instanceof Error ? error40.message : String(error40);
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            const rawContent = await fn.function(parsed, this);
            const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
            this._addMessage({ role, tool_call_id, content });
            if (singleFunctionToCall) {
              return;
            }
          }
        }
        return;
      }
    };
    _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
      return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
    }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
      let i = this.messages.length;
      while (i-- > 0) {
        const message = this.messages[i];
        if (isAssistantMessage(message)) {
          const ret = {
            ...message,
            content: message.content ?? null,
            refusal: message.refusal ?? null
          };
          return ret;
        }
      }
      throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
    }, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if (isAssistantMessage(message) && message?.tool_calls?.length) {
          return message.tool_calls.filter((x) => x.type === "function").at(-1)?.function;
        }
      }
      return;
    }, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if (isToolMessage2(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
          return message.content;
        }
      }
      return;
    }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
      const total = {
        completion_tokens: 0,
        prompt_tokens: 0,
        total_tokens: 0
      };
      for (const { usage } of this._chatCompletions) {
        if (usage) {
          total.completion_tokens += usage.completion_tokens;
          total.prompt_tokens += usage.prompt_tokens;
          total.total_tokens += usage.total_tokens;
        }
      }
      return total;
    }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
      if (params.n != null && params.n > 1) {
        throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
      }
    }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
      return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner;
var init_ChatCompletionRunner = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/ChatCompletionRunner.mjs"() {
    init_AbstractChatCompletionRunner();
    init_chatCompletionUtils();
    ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
      static runTools(client2, params, options) {
        const runner = new _ChatCompletionRunner();
        const opts = {
          ...options,
          headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
        };
        runner._run(() => runner._runTools(client2, params, opts));
        return runner;
      }
      _addMessage(message, emit = true) {
        super._addMessage(message, emit);
        if (isAssistantMessage(message) && message.content) {
          this._emit("content", message.content);
        }
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/partial-json-parser/parser.mjs
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var STR, NUM, ARR, OBJ, NULL, BOOL, NAN, INFINITY, MINUS_INFINITY, INF, SPECIAL, ATOM, COLLECTION, ALL, Allow, PartialJSON, MalformedJSON, _parseJSON, partialParse;
var init_parser2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/partial-json-parser/parser.mjs"() {
    STR = 1;
    NUM = 2;
    ARR = 4;
    OBJ = 8;
    NULL = 16;
    BOOL = 32;
    NAN = 64;
    INFINITY = 128;
    MINUS_INFINITY = 256;
    INF = INFINITY | MINUS_INFINITY;
    SPECIAL = NULL | BOOL | INF | NAN;
    ATOM = STR | NUM | SPECIAL;
    COLLECTION = ARR | OBJ;
    ALL = ATOM | COLLECTION;
    Allow = {
      STR,
      NUM,
      ARR,
      OBJ,
      NULL,
      BOOL,
      NAN,
      INFINITY,
      MINUS_INFINITY,
      INF,
      SPECIAL,
      ATOM,
      COLLECTION,
      ALL
    };
    PartialJSON = class extends Error {
    };
    MalformedJSON = class extends Error {
    };
    _parseJSON = (jsonString, allow) => {
      const length = jsonString.length;
      let index2 = 0;
      const markPartialJSON = (msg) => {
        throw new PartialJSON(`${msg} at position ${index2}`);
      };
      const throwMalformedError = (msg) => {
        throw new MalformedJSON(`${msg} at position ${index2}`);
      };
      const parseAny = () => {
        skipBlank();
        if (index2 >= length)
          markPartialJSON("Unexpected end of input");
        if (jsonString[index2] === '"')
          return parseStr();
        if (jsonString[index2] === "{")
          return parseObj();
        if (jsonString[index2] === "[")
          return parseArr();
        if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
          index2 += 4;
          return null;
        }
        if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
          index2 += 4;
          return true;
        }
        if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
          index2 += 5;
          return false;
        }
        if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
          index2 += 8;
          return Infinity;
        }
        if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
          index2 += 9;
          return -Infinity;
        }
        if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
          index2 += 3;
          return NaN;
        }
        return parseNum();
      };
      const parseStr = () => {
        const start = index2;
        let escape2 = false;
        index2++;
        while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
          escape2 = jsonString[index2] === "\\" ? !escape2 : false;
          index2++;
        }
        if (jsonString.charAt(index2) == '"') {
          try {
            return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
          } catch (e) {
            throwMalformedError(String(e));
          }
        } else if (Allow.STR & allow) {
          try {
            return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
          } catch (e) {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
          }
        }
        markPartialJSON("Unterminated string literal");
      };
      const parseObj = () => {
        index2++;
        skipBlank();
        const obj = {};
        try {
          while (jsonString[index2] !== "}") {
            skipBlank();
            if (index2 >= length && Allow.OBJ & allow)
              return obj;
            const key = parseStr();
            skipBlank();
            index2++;
            try {
              const value = parseAny();
              Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
            } catch (e) {
              if (Allow.OBJ & allow)
                return obj;
              else
                throw e;
            }
            skipBlank();
            if (jsonString[index2] === ",")
              index2++;
          }
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            markPartialJSON("Expected '}' at end of object");
        }
        index2++;
        return obj;
      };
      const parseArr = () => {
        index2++;
        const arr3 = [];
        try {
          while (jsonString[index2] !== "]") {
            arr3.push(parseAny());
            skipBlank();
            if (jsonString[index2] === ",") {
              index2++;
            }
          }
        } catch (e) {
          if (Allow.ARR & allow) {
            return arr3;
          }
          markPartialJSON("Expected ']' at end of array");
        }
        index2++;
        return arr3;
      };
      const parseNum = () => {
        if (index2 === 0) {
          if (jsonString === "-" && Allow.NUM & allow)
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString);
          } catch (e) {
            if (Allow.NUM & allow) {
              try {
                if ("." === jsonString[jsonString.length - 1])
                  return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
              } catch (e2) {
              }
            }
            throwMalformedError(String(e));
          }
        }
        const start = index2;
        if (jsonString[index2] === "-")
          index2++;
        while (jsonString[index2] && !",]}".includes(jsonString[index2]))
          index2++;
        if (index2 == length && !(Allow.NUM & allow))
          markPartialJSON("Unterminated number literal");
        try {
          return JSON.parse(jsonString.substring(start, index2));
        } catch (e) {
          if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
          } catch (e2) {
            throwMalformedError(String(e2));
          }
        }
      };
      const skipBlank = () => {
        while (index2 < length && " \n\r	".includes(jsonString[index2])) {
          index2++;
        }
      };
      return parseAny();
    };
    partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
  }
});

// node_modules/@langchain/openai/node_modules/openai/streaming.mjs
var init_streaming2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/streaming.mjs"() {
    init_streaming();
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/ChatCompletionStream.mjs
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever2(_x) {
}
var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion, ChatCompletionStream;
var init_ChatCompletionStream = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/ChatCompletionStream.mjs"() {
    init_tslib();
    init_parser2();
    init_error3();
    init_parser();
    init_streaming2();
    init_AbstractChatCompletionRunner();
    ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
      constructor(params) {
        super();
        _ChatCompletionStream_instances.add(this);
        _ChatCompletionStream_params.set(this, void 0);
        _ChatCompletionStream_choiceEventStates.set(this, void 0);
        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
      }
      get currentChatCompletionSnapshot() {
        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _ChatCompletionStream(null);
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createChatCompletion(client2, params, options) {
        const runner = new _ChatCompletionStream(params);
        runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      async _createChatCompletion(client2, params, options) {
        super._createChatCompletion;
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        const stream = await client2.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
        this._connected();
        for await (const chunk of stream) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      async _fromReadableStream(readableStream, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        this._connected();
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        let chatId;
        for await (const chunk of stream) {
          if (chatId && chatId !== chunk.id) {
            this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
          }
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
          chatId = chunk.id;
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
      }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
        let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
        if (state) {
          return state;
        }
        state = {
          content_done: false,
          refusal_done: false,
          logprobs_content_done: false,
          logprobs_refusal_done: false,
          done_tool_calls: /* @__PURE__ */ new Set(),
          current_tool_call_index: null
        };
        __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
        return state;
      }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
        if (this.ended)
          return;
        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
        this._emit("chunk", chunk, completion);
        for (const choice of chunk.choices) {
          const choiceSnapshot = completion.choices[choice.index];
          if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
            this._emit("content", choice.delta.content, choiceSnapshot.message.content);
            this._emit("content.delta", {
              delta: choice.delta.content,
              snapshot: choiceSnapshot.message.content,
              parsed: choiceSnapshot.message.parsed
            });
          }
          if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
            this._emit("refusal.delta", {
              delta: choice.delta.refusal,
              snapshot: choiceSnapshot.message.refusal
            });
          }
          if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
            this._emit("logprobs.content.delta", {
              content: choice.logprobs?.content,
              snapshot: choiceSnapshot.logprobs?.content ?? []
            });
          }
          if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
            this._emit("logprobs.refusal.delta", {
              refusal: choice.logprobs?.refusal,
              snapshot: choiceSnapshot.logprobs?.refusal ?? []
            });
          }
          const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
          if (choiceSnapshot.finish_reason) {
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
            if (state.current_tool_call_index != null) {
              __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
            }
          }
          for (const toolCall of choice.delta.tool_calls ?? []) {
            if (state.current_tool_call_index !== toolCall.index) {
              __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
              if (state.current_tool_call_index != null) {
                __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
              }
            }
            state.current_tool_call_index = toolCall.index;
          }
          for (const toolCallDelta of choice.delta.tool_calls ?? []) {
            const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
            if (!toolCallSnapshot?.type) {
              continue;
            }
            if (toolCallSnapshot?.type === "function") {
              this._emit("tool_calls.function.arguments.delta", {
                name: toolCallSnapshot.function?.name,
                index: toolCallDelta.index,
                arguments: toolCallSnapshot.function.arguments,
                parsed_arguments: toolCallSnapshot.function.parsed_arguments,
                arguments_delta: toolCallDelta.function?.arguments ?? ""
              });
            } else {
              assertNever2(toolCallSnapshot?.type);
            }
          }
        }
      }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (state.done_tool_calls.has(toolCallIndex)) {
          return;
        }
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
        if (!toolCallSnapshot) {
          throw new Error("no tool call snapshot");
        }
        if (!toolCallSnapshot.type) {
          throw new Error("tool call snapshot missing `type`");
        }
        if (toolCallSnapshot.type === "function") {
          const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.tools?.find((tool2) => isChatCompletionFunctionTool(tool2) && tool2.function.name === toolCallSnapshot.function.name);
          this._emit("tool_calls.function.arguments.done", {
            name: toolCallSnapshot.function.name,
            index: toolCallIndex,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
          });
        } else {
          assertNever2(toolCallSnapshot.type);
        }
      }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (choiceSnapshot.message.content && !state.content_done) {
          state.content_done = true;
          const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
          this._emit("content.done", {
            content: choiceSnapshot.message.content,
            parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
          });
        }
        if (choiceSnapshot.message.refusal && !state.refusal_done) {
          state.refusal_done = true;
          this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
        }
        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
          state.logprobs_content_done = true;
          this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
        }
        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
          state.logprobs_refusal_done = true;
          this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
        }
      }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
        if (this.ended) {
          throw new OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        if (!snapshot) {
          throw new OpenAIError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
        return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
      }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
        const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.response_format;
        if (isAutoParsableResponseFormat(responseFormat)) {
          return responseFormat;
        }
        return null;
      }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
        var _a3, _b, _c, _d;
        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        const { choices, ...rest } = chunk;
        if (!snapshot) {
          snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
            ...rest,
            choices: []
          }, "f");
        } else {
          Object.assign(snapshot, rest);
        }
        for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
          let choice = snapshot.choices[index2];
          if (!choice) {
            choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
          }
          if (logprobs) {
            if (!choice.logprobs) {
              choice.logprobs = Object.assign({}, logprobs);
            } else {
              const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
              assertIsEmpty(rest3);
              Object.assign(choice.logprobs, rest3);
              if (content2) {
                (_a3 = choice.logprobs).content ?? (_a3.content = []);
                choice.logprobs.content.push(...content2);
              }
              if (refusal2) {
                (_b = choice.logprobs).refusal ?? (_b.refusal = []);
                choice.logprobs.refusal.push(...refusal2);
              }
            }
          }
          if (finish_reason) {
            choice.finish_reason = finish_reason;
            if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
              if (finish_reason === "length") {
                throw new LengthFinishReasonError();
              }
              if (finish_reason === "content_filter") {
                throw new ContentFilterFinishReasonError();
              }
            }
          }
          Object.assign(choice, other);
          if (!delta)
            continue;
          const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
          assertIsEmpty(rest2);
          Object.assign(choice.message, rest2);
          if (refusal) {
            choice.message.refusal = (choice.message.refusal || "") + refusal;
          }
          if (role)
            choice.message.role = role;
          if (function_call) {
            if (!choice.message.function_call) {
              choice.message.function_call = function_call;
            } else {
              if (function_call.name)
                choice.message.function_call.name = function_call.name;
              if (function_call.arguments) {
                (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
                choice.message.function_call.arguments += function_call.arguments;
              }
            }
          }
          if (content) {
            choice.message.content = (choice.message.content || "") + content;
            if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
              choice.message.parsed = partialParse(choice.message.content);
            }
          }
          if (tool_calls) {
            if (!choice.message.tool_calls)
              choice.message.tool_calls = [];
            for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
              const tool_call = (_d = choice.message.tool_calls)[index3] ?? (_d[index3] = {});
              Object.assign(tool_call, rest3);
              if (id)
                tool_call.id = id;
              if (type)
                tool_call.type = type;
              if (fn)
                tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
              if (fn?.name)
                tool_call.function.name = fn.name;
              if (fn?.arguments) {
                tool_call.function.arguments += fn.arguments;
                if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
                  tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
                }
              }
            }
          }
        }
        return snapshot;
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("chunk", (chunk) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(chunk);
          } else {
            pushQueue.push(chunk);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner;
var init_ChatCompletionStreamingRunner = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/ChatCompletionStreamingRunner.mjs"() {
    init_ChatCompletionStream();
    ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
      static fromReadableStream(stream) {
        const runner = new _ChatCompletionStreamingRunner(null);
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static runTools(client2, params, options) {
        const runner = new _ChatCompletionStreamingRunner(
          // @ts-expect-error TODO these types are incompatible
          params
        );
        const opts = {
          ...options,
          headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
        };
        runner._run(() => runner._runTools(client2, params, opts));
        return runner;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/chat/completions/completions.mjs
var Completions;
var init_completions = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/chat/completions/completions.mjs"() {
    init_resource();
    init_messages5();
    init_messages5();
    init_pagination();
    init_path();
    init_ChatCompletionRunner();
    init_ChatCompletionStreamingRunner();
    init_ChatCompletionStream();
    init_parser();
    init_ChatCompletionStreamingRunner();
    init_RunnableFunction();
    init_ChatCompletionStream();
    init_ChatCompletionRunner();
    Completions = class extends APIResource {
      constructor() {
        super(...arguments);
        this.messages = new Messages(this._client);
      }
      create(body, options) {
        return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
      }
      /**
       * Get a stored chat completion. Only Chat Completions that have been created with
       * the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * const chatCompletion =
       *   await client.chat.completions.retrieve('completion_id');
       * ```
       */
      retrieve(completionID, options) {
        return this._client.get(path2`/chat/completions/${completionID}`, options);
      }
      /**
       * Modify a stored chat completion. Only Chat Completions that have been created
       * with the `store` parameter set to `true` can be modified. Currently, the only
       * supported modification is to update the `metadata` field.
       *
       * @example
       * ```ts
       * const chatCompletion = await client.chat.completions.update(
       *   'completion_id',
       *   { metadata: { foo: 'string' } },
       * );
       * ```
       */
      update(completionID, body, options) {
        return this._client.post(path2`/chat/completions/${completionID}`, { body, ...options });
      }
      /**
       * List stored Chat Completions. Only Chat Completions that have been stored with
       * the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatCompletion of client.chat.completions.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
      }
      /**
       * Delete a stored chat completion. Only Chat Completions that have been created
       * with the `store` parameter set to `true` can be deleted.
       *
       * @example
       * ```ts
       * const chatCompletionDeleted =
       *   await client.chat.completions.delete('completion_id');
       * ```
       */
      delete(completionID, options) {
        return this._client.delete(path2`/chat/completions/${completionID}`, options);
      }
      parse(body, options) {
        validateInputTools(body.tools);
        return this._client.chat.completions.create(body, {
          ...options,
          headers: {
            ...options?.headers,
            "X-Stainless-Helper-Method": "chat.completions.parse"
          }
        })._thenUnwrap((completion) => parseChatCompletion(completion, body));
      }
      runTools(body, options) {
        if (body.stream) {
          return ChatCompletionStreamingRunner.runTools(this._client, body, options);
        }
        return ChatCompletionRunner.runTools(this._client, body, options);
      }
      /**
       * Creates a chat completion stream
       */
      stream(body, options) {
        return ChatCompletionStream.createChatCompletion(this._client, body, options);
      }
    };
    Completions.Messages = Messages;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/chat/chat.mjs
var Chat;
var init_chat3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/chat/chat.mjs"() {
    init_resource();
    init_completions();
    init_completions();
    Chat = class extends APIResource {
      constructor() {
        super(...arguments);
        this.completions = new Completions(this._client);
      }
    };
    Chat.Completions = Completions;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/chat/completions/index.mjs
var init_completions2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/chat/completions/index.mjs"() {
    init_completions();
    init_completions();
    init_messages5();
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/chat/index.mjs
var init_chat4 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/chat/index.mjs"() {
    init_chat3();
    init_completions2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/shared.mjs
var init_shared = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/shared.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/headers.mjs
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var brand_privateNullableHeaders, buildHeaders;
var init_headers = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/headers.mjs"() {
    init_values2();
    brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
    buildHeaders = (newHeaders) => {
      const targetHeaders = new Headers();
      const nullHeaders = /* @__PURE__ */ new Set();
      for (const headers of newHeaders) {
        const seenHeaders = /* @__PURE__ */ new Set();
        for (const [name, value] of iterateHeaders(headers)) {
          const lowerName = name.toLowerCase();
          if (!seenHeaders.has(lowerName)) {
            targetHeaders.delete(name);
            seenHeaders.add(lowerName);
          }
          if (value === null) {
            targetHeaders.delete(name);
            nullHeaders.add(lowerName);
          } else {
            targetHeaders.append(name, value);
            nullHeaders.delete(lowerName);
          }
        }
      }
      return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/audio/speech.mjs
var Speech;
var init_speech = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/audio/speech.mjs"() {
    init_resource();
    init_headers();
    Speech = class extends APIResource {
      /**
       * Generates audio from the input text.
       *
       * @example
       * ```ts
       * const speech = await client.audio.speech.create({
       *   input: 'input',
       *   model: 'string',
       *   voice: 'ash',
       * });
       *
       * const content = await speech.blob();
       * console.log(content);
       * ```
       */
      create(body, options) {
        return this._client.post("/audio/speech", {
          body,
          ...options,
          headers: buildHeaders([{ Accept: "application/octet-stream" }, options?.headers]),
          __binaryResponse: true
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions;
var init_transcriptions = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/audio/transcriptions.mjs"() {
    init_resource();
    init_uploads();
    Transcriptions = class extends APIResource {
      create(body, options) {
        return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
          body,
          ...options,
          stream: body.stream ?? false,
          __metadata: { model: body.model }
        }, this._client));
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/audio/translations.mjs
var Translations;
var init_translations = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/audio/translations.mjs"() {
    init_resource();
    init_uploads();
    Translations = class extends APIResource {
      create(body, options) {
        return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }, this._client));
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/audio/audio.mjs
var Audio;
var init_audio = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/audio/audio.mjs"() {
    init_resource();
    init_speech();
    init_speech();
    init_transcriptions();
    init_transcriptions();
    init_translations();
    init_translations();
    Audio = class extends APIResource {
      constructor() {
        super(...arguments);
        this.transcriptions = new Transcriptions(this._client);
        this.translations = new Translations(this._client);
        this.speech = new Speech(this._client);
      }
    };
    Audio.Transcriptions = Transcriptions;
    Audio.Translations = Translations;
    Audio.Speech = Speech;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/batches.mjs
var Batches;
var init_batches = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/batches.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    Batches = class extends APIResource {
      /**
       * Creates and executes a batch from an uploaded file of requests
       */
      create(body, options) {
        return this._client.post("/batches", { body, ...options });
      }
      /**
       * Retrieves a batch.
       */
      retrieve(batchID, options) {
        return this._client.get(path2`/batches/${batchID}`, options);
      }
      /**
       * List your organization's batches.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/batches", CursorPage, { query, ...options });
      }
      /**
       * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
       * 10 minutes, before changing to `cancelled`, where it will have partial results
       * (if any) available in the output file.
       */
      cancel(batchID, options) {
        return this._client.post(path2`/batches/${batchID}/cancel`, options);
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/assistants.mjs
var Assistants;
var init_assistants = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/assistants.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Assistants = class extends APIResource {
      /**
       * Create an assistant with a model and instructions.
       *
       * @deprecated
       */
      create(body, options) {
        return this._client.post("/assistants", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Retrieves an assistant.
       *
       * @deprecated
       */
      retrieve(assistantID, options) {
        return this._client.get(path2`/assistants/${assistantID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Modifies an assistant.
       *
       * @deprecated
       */
      update(assistantID, body, options) {
        return this._client.post(path2`/assistants/${assistantID}`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Returns a list of assistants.
       *
       * @deprecated
       */
      list(query = {}, options) {
        return this._client.getAPIList("/assistants", CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Delete an assistant.
       *
       * @deprecated
       */
      delete(assistantID, options) {
        return this._client.delete(path2`/assistants/${assistantID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions;
var init_sessions = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/realtime/sessions.mjs"() {
    init_resource();
    init_headers();
    Sessions = class extends APIResource {
      /**
       * Create an ephemeral API token for use in client-side applications with the
       * Realtime API. Can be configured with the same session parameters as the
       * `session.update` client event.
       *
       * It responds with a session object, plus a `client_secret` key which contains a
       * usable ephemeral API token that can be used to authenticate browser clients for
       * the Realtime API.
       *
       * @example
       * ```ts
       * const session =
       *   await client.beta.realtime.sessions.create();
       * ```
       */
      create(body, options) {
        return this._client.post("/realtime/sessions", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions;
var init_transcription_sessions = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/realtime/transcription-sessions.mjs"() {
    init_resource();
    init_headers();
    TranscriptionSessions = class extends APIResource {
      /**
       * Create an ephemeral API token for use in client-side applications with the
       * Realtime API specifically for realtime transcriptions. Can be configured with
       * the same session parameters as the `transcription_session.update` client event.
       *
       * It responds with a session object, plus a `client_secret` key which contains a
       * usable ephemeral API token that can be used to authenticate browser clients for
       * the Realtime API.
       *
       * @example
       * ```ts
       * const transcriptionSession =
       *   await client.beta.realtime.transcriptionSessions.create();
       * ```
       */
      create(body, options) {
        return this._client.post("/realtime/transcription_sessions", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime;
var init_realtime = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/realtime/realtime.mjs"() {
    init_resource();
    init_sessions();
    init_sessions();
    init_transcription_sessions();
    init_transcription_sessions();
    Realtime = class extends APIResource {
      constructor() {
        super(...arguments);
        this.sessions = new Sessions(this._client);
        this.transcriptionSessions = new TranscriptionSessions(this._client);
      }
    };
    Realtime.Sessions = Sessions;
    Realtime.TranscriptionSessions = TranscriptionSessions;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/chatkit/sessions.mjs
var Sessions2;
var init_sessions2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/chatkit/sessions.mjs"() {
    init_resource();
    init_headers();
    init_path();
    Sessions2 = class extends APIResource {
      /**
       * Create a ChatKit session
       *
       * @example
       * ```ts
       * const chatSession =
       *   await client.beta.chatkit.sessions.create({
       *     user: 'x',
       *     workflow: { id: 'id' },
       *   });
       * ```
       */
      create(body, options) {
        return this._client.post("/chatkit/sessions", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
        });
      }
      /**
       * Cancel a ChatKit session
       *
       * @example
       * ```ts
       * const chatSession =
       *   await client.beta.chatkit.sessions.cancel('cksess_123');
       * ```
       */
      cancel(sessionID, options) {
        return this._client.post(path2`/chatkit/sessions/${sessionID}/cancel`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/chatkit/threads.mjs
var Threads;
var init_threads = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/chatkit/threads.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Threads = class extends APIResource {
      /**
       * Retrieve a ChatKit thread
       *
       * @example
       * ```ts
       * const chatkitThread =
       *   await client.beta.chatkit.threads.retrieve('cthr_123');
       * ```
       */
      retrieve(threadID, options) {
        return this._client.get(path2`/chatkit/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
        });
      }
      /**
       * List ChatKit threads
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
        });
      }
      /**
       * Delete a ChatKit thread
       *
       * @example
       * ```ts
       * const thread = await client.beta.chatkit.threads.delete(
       *   'cthr_123',
       * );
       * ```
       */
      delete(threadID, options) {
        return this._client.delete(path2`/chatkit/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
        });
      }
      /**
       * List ChatKit thread items
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const thread of client.beta.chatkit.threads.listItems(
       *   'cthr_123',
       * )) {
       *   // ...
       * }
       * ```
       */
      listItems(threadID, query = {}, options) {
        return this._client.getAPIList(path2`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/chatkit/chatkit.mjs
var ChatKit;
var init_chatkit = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/chatkit/chatkit.mjs"() {
    init_resource();
    init_sessions2();
    init_sessions2();
    init_threads();
    init_threads();
    ChatKit = class extends APIResource {
      constructor() {
        super(...arguments);
        this.sessions = new Sessions2(this._client);
        this.threads = new Threads(this._client);
      }
    };
    ChatKit.Sessions = Sessions2;
    ChatKit.Threads = Threads;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/messages.mjs
var Messages2;
var init_messages6 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/messages.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Messages2 = class extends APIResource {
      /**
       * Create a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      create(threadID, body, options) {
        return this._client.post(path2`/threads/${threadID}/messages`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Retrieve a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(messageID, params, options) {
        const { thread_id } = params;
        return this._client.get(path2`/threads/${thread_id}/messages/${messageID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Modifies a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(messageID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post(path2`/threads/${thread_id}/messages/${messageID}`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Returns a list of messages for a given thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(threadID, query = {}, options) {
        return this._client.getAPIList(path2`/threads/${threadID}/messages`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Deletes a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      delete(messageID, params, options) {
        const { thread_id } = params;
        return this._client.delete(path2`/threads/${thread_id}/messages/${messageID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps;
var init_steps = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/runs/steps.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Steps = class extends APIResource {
      /**
       * Retrieves a run step.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(stepID, params, options) {
        const { thread_id, run_id, ...query } = params;
        return this._client.get(path2`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Returns a list of run steps belonging to a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(runID, params, options) {
        const { thread_id, ...query } = params;
        return this._client.getAPIList(path2`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/base64.mjs
var toFloat32Array;
var init_base64 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/base64.mjs"() {
    init_error2();
    init_bytes2();
    toFloat32Array = (base64Str) => {
      if (typeof Buffer !== "undefined") {
        const buf = Buffer.from(base64Str, "base64");
        return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
      } else {
        const binaryStr = atob(base64Str);
        const len = binaryStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        return Array.from(new Float32Array(bytes.buffer));
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils/env.mjs
var readEnv;
var init_env4 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils/env.mjs"() {
    readEnv = (env) => {
      if (typeof globalThis.process !== "undefined") {
        return globalThis.process.env?.[env]?.trim() ?? void 0;
      }
      if (typeof globalThis.Deno !== "undefined") {
        return globalThis.Deno.env?.get?.(env)?.trim();
      }
      return void 0;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/internal/utils.mjs
var init_utils11 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/internal/utils.mjs"() {
    init_values2();
    init_base64();
    init_env4();
    init_log();
    init_uuid3();
    init_sleep();
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/AssistantStream.mjs
function assertNever3(_x) {
}
var _AssistantStream_instances, _a, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun, AssistantStream;
var init_AssistantStream = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/AssistantStream.mjs"() {
    init_tslib();
    init_streaming2();
    init_error3();
    init_EventStream();
    init_utils11();
    AssistantStream = class extends EventStream {
      constructor() {
        super(...arguments);
        _AssistantStream_instances.add(this);
        _AssistantStream_events.set(this, []);
        _AssistantStream_runStepSnapshots.set(this, {});
        _AssistantStream_messageSnapshots.set(this, {});
        _AssistantStream_messageSnapshot.set(this, void 0);
        _AssistantStream_finalRun.set(this, void 0);
        _AssistantStream_currentContentIndex.set(this, void 0);
        _AssistantStream_currentContent.set(this, void 0);
        _AssistantStream_currentToolCallIndex.set(this, void 0);
        _AssistantStream_currentToolCall.set(this, void 0);
        _AssistantStream_currentEvent.set(this, void 0);
        _AssistantStream_currentRunSnapshot.set(this, void 0);
        _AssistantStream_currentRunStepSnapshot.set(this, void 0);
      }
      [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("event", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      static fromReadableStream(stream) {
        const runner = new _a();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      async _fromReadableStream(readableStream, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        this._connected();
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
      static createToolAssistantStream(runId, runs, params, options) {
        const runner = new _a();
        runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
          ...options,
          headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      async _createToolAssistantStream(run, runId, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream = await run.submitToolOutputs(runId, body, {
          ...options,
          signal: this.controller.signal
        });
        this._connected();
        for await (const event of stream) {
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      static createThreadAssistantStream(params, thread, options) {
        const runner = new _a();
        runner._run(() => runner._threadAssistantStream(params, thread, {
          ...options,
          headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      static createAssistantStream(threadId, runs, params, options) {
        const runner = new _a();
        runner._run(() => runner._runAssistantStream(threadId, runs, params, {
          ...options,
          headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      currentEvent() {
        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
      }
      currentRun() {
        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
      }
      currentMessageSnapshot() {
        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
      }
      currentRunStepSnapshot() {
        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
      }
      async finalRunSteps() {
        await this.done();
        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
      }
      async finalMessages() {
        await this.done();
        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
      }
      async finalRun() {
        await this.done();
        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
          throw Error("Final run was not received.");
        return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
      }
      async _createThreadAssistantStream(thread, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
        this._connected();
        for await (const event of stream) {
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      async _createAssistantStream(run, threadId, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
        this._connected();
        for await (const event of stream) {
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      static accumulateDelta(acc, delta) {
        for (const [key, deltaValue] of Object.entries(delta)) {
          if (!acc.hasOwnProperty(key)) {
            acc[key] = deltaValue;
            continue;
          }
          let accValue = acc[key];
          if (accValue === null || accValue === void 0) {
            acc[key] = deltaValue;
            continue;
          }
          if (key === "index" || key === "type") {
            acc[key] = deltaValue;
            continue;
          }
          if (typeof accValue === "string" && typeof deltaValue === "string") {
            accValue += deltaValue;
          } else if (typeof accValue === "number" && typeof deltaValue === "number") {
            accValue += deltaValue;
          } else if (isObj(accValue) && isObj(deltaValue)) {
            accValue = this.accumulateDelta(accValue, deltaValue);
          } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
            if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
              accValue.push(...deltaValue);
              continue;
            }
            for (const deltaEntry of deltaValue) {
              if (!isObj(deltaEntry)) {
                throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
              }
              const index2 = deltaEntry["index"];
              if (index2 == null) {
                console.error(deltaEntry);
                throw new Error("Expected array delta entry to have an `index` property");
              }
              if (typeof index2 !== "number") {
                throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
              }
              const accEntry = accValue[index2];
              if (accEntry == null) {
                accValue.push(deltaEntry);
              } else {
                accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
              }
            }
            continue;
          } else {
            throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
          }
          acc[key] = accValue;
        }
        return acc;
      }
      _addRun(run) {
        return run;
      }
      async _threadAssistantStream(params, thread, options) {
        return await this._createThreadAssistantStream(thread, params, options);
      }
      async _runAssistantStream(threadId, runs, params, options) {
        return await this._createAssistantStream(runs, threadId, params, options);
      }
      async _runToolAssistantStream(runId, runs, params, options) {
        return await this._createToolAssistantStream(runs, runId, params, options);
      }
    };
    _a = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
      if (this.ended)
        return;
      __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
      switch (event.event) {
        case "thread.created":
          break;
        case "thread.run.created":
        case "thread.run.queued":
        case "thread.run.in_progress":
        case "thread.run.requires_action":
        case "thread.run.completed":
        case "thread.run.incomplete":
        case "thread.run.failed":
        case "thread.run.cancelling":
        case "thread.run.cancelled":
        case "thread.run.expired":
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
          break;
        case "thread.run.step.created":
        case "thread.run.step.in_progress":
        case "thread.run.step.delta":
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
          break;
        case "thread.message.created":
        case "thread.message.in_progress":
        case "thread.message.delta":
        case "thread.message.completed":
        case "thread.message.incomplete":
          __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
          break;
        case "error":
          throw new Error("Encountered an error event in event processing - errors should be processed earlier");
        default:
          assertNever3(event);
      }
    }, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
      if (this.ended) {
        throw new OpenAIError(`stream has ended, this shouldn't happen`);
      }
      if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
        throw Error("Final run has not been received");
      return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
    }, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
      const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
      __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
      for (const content of newContent) {
        const snapshotContent = accumulatedMessage.content[content.index];
        if (snapshotContent?.type == "text") {
          this._emit("textCreated", snapshotContent.text);
        }
      }
      switch (event.event) {
        case "thread.message.created":
          this._emit("messageCreated", event.data);
          break;
        case "thread.message.in_progress":
          break;
        case "thread.message.delta":
          this._emit("messageDelta", event.data.delta, accumulatedMessage);
          if (event.data.delta.content) {
            for (const content of event.data.delta.content) {
              if (content.type == "text" && content.text) {
                let textDelta = content.text;
                let snapshot = accumulatedMessage.content[content.index];
                if (snapshot && snapshot.type == "text") {
                  this._emit("textDelta", textDelta, snapshot.text);
                } else {
                  throw Error("The snapshot associated with this text delta is not text or missing");
                }
              }
              if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
                if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
                  switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                    case "text":
                      this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                      break;
                    case "image_file":
                      this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                      break;
                  }
                }
                __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
              }
              __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
            }
          }
          break;
        case "thread.message.completed":
        case "thread.message.incomplete":
          if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
            const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
            if (currentContent) {
              switch (currentContent.type) {
                case "image_file":
                  this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "text":
                  this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
          }
          if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
            this._emit("messageDone", event.data);
          }
          __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
      }
    }, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
      const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
      switch (event.event) {
        case "thread.run.step.created":
          this._emit("runStepCreated", event.data);
          break;
        case "thread.run.step.delta":
          const delta = event.data.delta;
          if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
            for (const toolCall of delta.step_details.tool_calls) {
              if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
                this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
              } else {
                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                  this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
                }
                __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
                  this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              }
            }
          }
          this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
          break;
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
          __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
          const details = event.data.step_details;
          if (details.type == "tool_calls") {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
            }
          }
          this._emit("runStepDone", event.data, accumulatedRunStep);
          break;
        case "thread.run.step.in_progress":
          break;
      }
    }, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
      __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
      this._emit("event", event);
    }, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
      switch (event.event) {
        case "thread.run.step.created":
          __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
          return event.data;
        case "thread.run.step.delta":
          let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
          if (!snapshot) {
            throw Error("Received a RunStepDelta before creation of a snapshot");
          }
          let data = event.data;
          if (data.delta) {
            const accumulated = _a.accumulateDelta(snapshot, data.delta);
            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
          }
          return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
        case "thread.run.step.in_progress":
          __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
          break;
      }
      if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      throw new Error("No snapshot available");
    }, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
      let newContent = [];
      switch (event.event) {
        case "thread.message.created":
          return [event.data, newContent];
        case "thread.message.delta":
          if (!snapshot) {
            throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
          }
          let data = event.data;
          if (data.delta.content) {
            for (const contentElement of data.delta.content) {
              if (contentElement.index in snapshot.content) {
                let currentContent = snapshot.content[contentElement.index];
                snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
              } else {
                snapshot.content[contentElement.index] = contentElement;
                newContent.push(contentElement);
              }
            }
          }
          return [snapshot, newContent];
        case "thread.message.in_progress":
        case "thread.message.completed":
        case "thread.message.incomplete":
          if (snapshot) {
            return [snapshot, newContent];
          } else {
            throw Error("Received thread message event with no existing snapshot");
          }
      }
      throw Error("Tried to accumulate a non-message event");
    }, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
      return _a.accumulateDelta(currentContent, contentElement);
    }, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
      __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
      switch (event.event) {
        case "thread.run.created":
          break;
        case "thread.run.queued":
          break;
        case "thread.run.in_progress":
          break;
        case "thread.run.requires_action":
        case "thread.run.cancelled":
        case "thread.run.failed":
        case "thread.run.completed":
        case "thread.run.expired":
        case "thread.run.incomplete":
          __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
          if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
            this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
          }
          break;
        case "thread.run.cancelling":
          break;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs;
var init_runs = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/runs/runs.mjs"() {
    init_resource();
    init_steps();
    init_steps();
    init_pagination();
    init_headers();
    init_AssistantStream();
    init_sleep();
    init_path();
    Runs = class extends APIResource {
      constructor() {
        super(...arguments);
        this.steps = new Steps(this._client);
      }
      create(threadID, params, options) {
        const { include, ...body } = params;
        return this._client.post(path2`/threads/${threadID}/runs`, {
          query: { include },
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
          stream: params.stream ?? false
        });
      }
      /**
       * Retrieves a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(runID, params, options) {
        const { thread_id } = params;
        return this._client.get(path2`/threads/${thread_id}/runs/${runID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Modifies a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(runID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post(path2`/threads/${thread_id}/runs/${runID}`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Returns a list of runs belonging to a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(threadID, query = {}, options) {
        return this._client.getAPIList(path2`/threads/${threadID}/runs`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Cancels a run that is `in_progress`.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      cancel(runID, params, options) {
        const { thread_id } = params;
        return this._client.post(path2`/threads/${thread_id}/runs/${runID}/cancel`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * A helper to create a run an poll for a terminal state. More information on Run
       * lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async createAndPoll(threadId, body, options) {
        const run = await this.create(threadId, body, options);
        return await this.poll(run.id, { thread_id: threadId }, options);
      }
      /**
       * Create a Run stream
       *
       * @deprecated use `stream` instead
       */
      createAndStream(threadId, body, options) {
        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
      }
      /**
       * A helper to poll a run status until it reaches a terminal state. More
       * information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async poll(runId, params, options) {
        const headers = buildHeaders([
          options?.headers,
          {
            "X-Stainless-Poll-Helper": "true",
            "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
          }
        ]);
        while (true) {
          const { data: run, response } = await this.retrieve(runId, params, {
            ...options,
            headers: { ...options?.headers, ...headers }
          }).withResponse();
          switch (run.status) {
            //If we are in any sort of intermediate state we poll
            case "queued":
            case "in_progress":
            case "cancelling":
              let sleepInterval = 5e3;
              if (options?.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = response.headers.get("openai-poll-after-ms");
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await sleep(sleepInterval);
              break;
            //We return the run in any terminal state.
            case "requires_action":
            case "incomplete":
            case "cancelled":
            case "completed":
            case "failed":
            case "expired":
              return run;
          }
        }
      }
      /**
       * Create a Run stream
       */
      stream(threadId, body, options) {
        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
      }
      submitToolOutputs(runID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post(path2`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
          stream: params.stream ?? false
        });
      }
      /**
       * A helper to submit a tool output to a run and poll for a terminal run state.
       * More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async submitToolOutputsAndPoll(runId, params, options) {
        const run = await this.submitToolOutputs(runId, params, options);
        return await this.poll(run.id, params, options);
      }
      /**
       * Submit the tool outputs from a previous run and stream the run to a terminal
       * state. More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      submitToolOutputsStream(runId, params, options) {
        return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
      }
    };
    Runs.Steps = Steps;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/threads.mjs
var Threads2;
var init_threads2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/threads/threads.mjs"() {
    init_resource();
    init_messages6();
    init_messages6();
    init_runs();
    init_runs();
    init_headers();
    init_AssistantStream();
    init_path();
    Threads2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.runs = new Runs(this._client);
        this.messages = new Messages2(this._client);
      }
      /**
       * Create a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      create(body = {}, options) {
        return this._client.post("/threads", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Retrieves a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(threadID, options) {
        return this._client.get(path2`/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Modifies a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(threadID, body, options) {
        return this._client.post(path2`/threads/${threadID}`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Delete a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      delete(threadID, options) {
        return this._client.delete(path2`/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      createAndRun(body, options) {
        return this._client.post("/threads/runs", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
          stream: body.stream ?? false
        });
      }
      /**
       * A helper to create a thread, start a run and then poll for a terminal state.
       * More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async createAndRunPoll(body, options) {
        const run = await this.createAndRun(body, options);
        return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
      }
      /**
       * Create a thread and stream the run back
       */
      createAndRunStream(body, options) {
        return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
      }
    };
    Threads2.Runs = Runs;
    Threads2.Messages = Messages2;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/beta/beta.mjs
var Beta;
var init_beta = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/beta/beta.mjs"() {
    init_resource();
    init_assistants();
    init_assistants();
    init_realtime();
    init_realtime();
    init_chatkit();
    init_chatkit();
    init_threads2();
    init_threads2();
    Beta = class extends APIResource {
      constructor() {
        super(...arguments);
        this.realtime = new Realtime(this._client);
        this.chatkit = new ChatKit(this._client);
        this.assistants = new Assistants(this._client);
        this.threads = new Threads2(this._client);
      }
    };
    Beta.Realtime = Realtime;
    Beta.ChatKit = ChatKit;
    Beta.Assistants = Assistants;
    Beta.Threads = Threads2;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/completions.mjs
var Completions2;
var init_completions3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/completions.mjs"() {
    init_resource();
    Completions2 = class extends APIResource {
      create(body, options) {
        return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/containers/files/content.mjs
var Content;
var init_content2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/containers/files/content.mjs"() {
    init_resource();
    init_headers();
    init_path();
    Content = class extends APIResource {
      /**
       * Retrieve Container File Content
       */
      retrieve(fileID, params, options) {
        const { container_id } = params;
        return this._client.get(path2`/containers/${container_id}/files/${fileID}/content`, {
          ...options,
          headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
          __binaryResponse: true
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/containers/files/files.mjs
var Files;
var init_files = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/containers/files/files.mjs"() {
    init_resource();
    init_content2();
    init_content2();
    init_pagination();
    init_headers();
    init_uploads();
    init_path();
    Files = class extends APIResource {
      constructor() {
        super(...arguments);
        this.content = new Content(this._client);
      }
      /**
       * Create a Container File
       *
       * You can send either a multipart/form-data request with the raw file content, or
       * a JSON request with a file ID.
       */
      create(containerID, body, options) {
        return this._client.post(path2`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options }, this._client));
      }
      /**
       * Retrieve Container File
       */
      retrieve(fileID, params, options) {
        const { container_id } = params;
        return this._client.get(path2`/containers/${container_id}/files/${fileID}`, options);
      }
      /**
       * List Container files
       */
      list(containerID, query = {}, options) {
        return this._client.getAPIList(path2`/containers/${containerID}/files`, CursorPage, {
          query,
          ...options
        });
      }
      /**
       * Delete Container File
       */
      delete(fileID, params, options) {
        const { container_id } = params;
        return this._client.delete(path2`/containers/${container_id}/files/${fileID}`, {
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
    };
    Files.Content = Content;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/containers/containers.mjs
var Containers;
var init_containers = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/containers/containers.mjs"() {
    init_resource();
    init_files();
    init_files();
    init_pagination();
    init_headers();
    init_path();
    Containers = class extends APIResource {
      constructor() {
        super(...arguments);
        this.files = new Files(this._client);
      }
      /**
       * Create Container
       */
      create(body, options) {
        return this._client.post("/containers", { body, ...options });
      }
      /**
       * Retrieve Container
       */
      retrieve(containerID, options) {
        return this._client.get(path2`/containers/${containerID}`, options);
      }
      /**
       * List Containers
       */
      list(query = {}, options) {
        return this._client.getAPIList("/containers", CursorPage, { query, ...options });
      }
      /**
       * Delete Container
       */
      delete(containerID, options) {
        return this._client.delete(path2`/containers/${containerID}`, {
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
    };
    Containers.Files = Files;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/conversations/items.mjs
var Items;
var init_items = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/conversations/items.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    Items = class extends APIResource {
      /**
       * Create items in a conversation with the given ID.
       */
      create(conversationID, params, options) {
        const { include, ...body } = params;
        return this._client.post(path2`/conversations/${conversationID}/items`, {
          query: { include },
          body,
          ...options
        });
      }
      /**
       * Get a single item from a conversation with the given IDs.
       */
      retrieve(itemID, params, options) {
        const { conversation_id, ...query } = params;
        return this._client.get(path2`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
      }
      /**
       * List all items for a conversation with the given ID.
       */
      list(conversationID, query = {}, options) {
        return this._client.getAPIList(path2`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
      }
      /**
       * Delete an item from a conversation with the given IDs.
       */
      delete(itemID, params, options) {
        const { conversation_id } = params;
        return this._client.delete(path2`/conversations/${conversation_id}/items/${itemID}`, options);
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/conversations/conversations.mjs
var Conversations;
var init_conversations = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/conversations/conversations.mjs"() {
    init_resource();
    init_items();
    init_items();
    init_path();
    Conversations = class extends APIResource {
      constructor() {
        super(...arguments);
        this.items = new Items(this._client);
      }
      /**
       * Create a conversation.
       */
      create(body = {}, options) {
        return this._client.post("/conversations", { body, ...options });
      }
      /**
       * Get a conversation
       */
      retrieve(conversationID, options) {
        return this._client.get(path2`/conversations/${conversationID}`, options);
      }
      /**
       * Update a conversation
       */
      update(conversationID, body, options) {
        return this._client.post(path2`/conversations/${conversationID}`, { body, ...options });
      }
      /**
       * Delete a conversation. Items in the conversation will not be deleted.
       */
      delete(conversationID, options) {
        return this._client.delete(path2`/conversations/${conversationID}`, options);
      }
    };
    Conversations.Items = Items;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/embeddings.mjs
var Embeddings2;
var init_embeddings3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/embeddings.mjs"() {
    init_resource();
    init_utils11();
    Embeddings2 = class extends APIResource {
      /**
       * Creates an embedding vector representing the input text.
       *
       * @example
       * ```ts
       * const createEmbeddingResponse =
       *   await client.embeddings.create({
       *     input: 'The quick brown fox jumped over the lazy dog',
       *     model: 'text-embedding-3-small',
       *   });
       * ```
       */
      create(body, options) {
        const hasUserProvidedEncodingFormat = !!body.encoding_format;
        let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
        if (hasUserProvidedEncodingFormat) {
          loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
        }
        const response = this._client.post("/embeddings", {
          body: {
            ...body,
            encoding_format
          },
          ...options
        });
        if (hasUserProvidedEncodingFormat) {
          return response;
        }
        loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
        return response._thenUnwrap((response2) => {
          if (response2 && response2.data) {
            response2.data.forEach((embeddingBase64Obj) => {
              const embeddingBase64Str = embeddingBase64Obj.embedding;
              embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
            });
          }
          return response2;
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems;
var init_output_items = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/evals/runs/output-items.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    OutputItems = class extends APIResource {
      /**
       * Get an evaluation run output item by ID.
       */
      retrieve(outputItemID, params, options) {
        const { eval_id, run_id } = params;
        return this._client.get(path2`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
      }
      /**
       * Get a list of output items for an evaluation run.
       */
      list(runID, params, options) {
        const { eval_id, ...query } = params;
        return this._client.getAPIList(path2`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/evals/runs/runs.mjs
var Runs2;
var init_runs2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/evals/runs/runs.mjs"() {
    init_resource();
    init_output_items();
    init_output_items();
    init_pagination();
    init_path();
    Runs2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.outputItems = new OutputItems(this._client);
      }
      /**
       * Kicks off a new run for a given evaluation, specifying the data source, and what
       * model configuration to use to test. The datasource will be validated against the
       * schema specified in the config of the evaluation.
       */
      create(evalID, body, options) {
        return this._client.post(path2`/evals/${evalID}/runs`, { body, ...options });
      }
      /**
       * Get an evaluation run by ID.
       */
      retrieve(runID, params, options) {
        const { eval_id } = params;
        return this._client.get(path2`/evals/${eval_id}/runs/${runID}`, options);
      }
      /**
       * Get a list of runs for an evaluation.
       */
      list(evalID, query = {}, options) {
        return this._client.getAPIList(path2`/evals/${evalID}/runs`, CursorPage, {
          query,
          ...options
        });
      }
      /**
       * Delete an eval run.
       */
      delete(runID, params, options) {
        const { eval_id } = params;
        return this._client.delete(path2`/evals/${eval_id}/runs/${runID}`, options);
      }
      /**
       * Cancel an ongoing evaluation run.
       */
      cancel(runID, params, options) {
        const { eval_id } = params;
        return this._client.post(path2`/evals/${eval_id}/runs/${runID}`, options);
      }
    };
    Runs2.OutputItems = OutputItems;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/evals/evals.mjs
var Evals;
var init_evals = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/evals/evals.mjs"() {
    init_resource();
    init_runs2();
    init_runs2();
    init_pagination();
    init_path();
    Evals = class extends APIResource {
      constructor() {
        super(...arguments);
        this.runs = new Runs2(this._client);
      }
      /**
       * Create the structure of an evaluation that can be used to test a model's
       * performance. An evaluation is a set of testing criteria and the config for a
       * data source, which dictates the schema of the data used in the evaluation. After
       * creating an evaluation, you can run it on different models and model parameters.
       * We support several types of graders and datasources. For more information, see
       * the [Evals guide](https://platform.openai.com/docs/guides/evals).
       */
      create(body, options) {
        return this._client.post("/evals", { body, ...options });
      }
      /**
       * Get an evaluation by ID.
       */
      retrieve(evalID, options) {
        return this._client.get(path2`/evals/${evalID}`, options);
      }
      /**
       * Update certain properties of an evaluation.
       */
      update(evalID, body, options) {
        return this._client.post(path2`/evals/${evalID}`, { body, ...options });
      }
      /**
       * List evaluations for a project.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/evals", CursorPage, { query, ...options });
      }
      /**
       * Delete an evaluation.
       */
      delete(evalID, options) {
        return this._client.delete(path2`/evals/${evalID}`, options);
      }
    };
    Evals.Runs = Runs2;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/files.mjs
var Files2;
var init_files2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/files.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_sleep();
    init_error3();
    init_uploads();
    init_path();
    Files2 = class extends APIResource {
      /**
       * Upload a file that can be used across various endpoints. Individual files can be
       * up to 512 MB, and each project can store up to 2.5 TB of files in total. There
       * is no organization-wide storage limit.
       *
       * - The Assistants API supports files up to 2 million tokens and of specific file
       *   types. See the
       *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
       *   for details.
       * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
       *   required formats for fine-tuning
       *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
       *   or
       *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
       *   models.
       * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
       *   also has a specific required
       *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
       *
       * Please [contact us](https://help.openai.com/) if you need to increase these
       * storage limits.
       */
      create(body, options) {
        return this._client.post("/files", multipartFormRequestOptions({ body, ...options }, this._client));
      }
      /**
       * Returns information about a specific file.
       */
      retrieve(fileID, options) {
        return this._client.get(path2`/files/${fileID}`, options);
      }
      /**
       * Returns a list of files.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/files", CursorPage, { query, ...options });
      }
      /**
       * Delete a file and remove it from all vector stores.
       */
      delete(fileID, options) {
        return this._client.delete(path2`/files/${fileID}`, options);
      }
      /**
       * Returns the contents of the specified file.
       */
      content(fileID, options) {
        return this._client.get(path2`/files/${fileID}/content`, {
          ...options,
          headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
          __binaryResponse: true
        });
      }
      /**
       * Waits for the given file to be processed, default timeout is 30 mins.
       */
      async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
        const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
        const start = Date.now();
        let file2 = await this.retrieve(id);
        while (!file2.status || !TERMINAL_STATES.has(file2.status)) {
          await sleep(pollInterval);
          file2 = await this.retrieve(id);
          if (Date.now() - start > maxWait) {
            throw new APIConnectionTimeoutError({
              message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
            });
          }
        }
        return file2;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/methods.mjs
var Methods;
var init_methods = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/methods.mjs"() {
    init_resource();
    Methods = class extends APIResource {
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders;
var init_graders = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/alpha/graders.mjs"() {
    init_resource();
    Graders = class extends APIResource {
      /**
       * Run a grader.
       *
       * @example
       * ```ts
       * const response = await client.fineTuning.alpha.graders.run({
       *   grader: {
       *     input: 'input',
       *     name: 'name',
       *     operation: 'eq',
       *     reference: 'reference',
       *     type: 'string_check',
       *   },
       *   model_sample: 'model_sample',
       * });
       * ```
       */
      run(body, options) {
        return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
      }
      /**
       * Validate a grader.
       *
       * @example
       * ```ts
       * const response =
       *   await client.fineTuning.alpha.graders.validate({
       *     grader: {
       *       input: 'input',
       *       name: 'name',
       *       operation: 'eq',
       *       reference: 'reference',
       *       type: 'string_check',
       *     },
       *   });
       * ```
       */
      validate(body, options) {
        return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha;
var init_alpha = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/alpha/alpha.mjs"() {
    init_resource();
    init_graders();
    init_graders();
    Alpha = class extends APIResource {
      constructor() {
        super(...arguments);
        this.graders = new Graders(this._client);
      }
    };
    Alpha.Graders = Graders;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions;
var init_permissions = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    Permissions = class extends APIResource {
      /**
       * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
       *
       * This enables organization owners to share fine-tuned models with other projects
       * in their organization.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
       *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
       *   { project_ids: ['string'] },
       * )) {
       *   // ...
       * }
       * ```
       */
      create(fineTunedModelCheckpoint, body, options) {
        return this._client.getAPIList(path2`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options });
      }
      /**
       * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
       *
       * Organization owners can use this endpoint to view all permissions for a
       * fine-tuned model checkpoint.
       *
       * @example
       * ```ts
       * const permission =
       *   await client.fineTuning.checkpoints.permissions.retrieve(
       *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       *   );
       * ```
       */
      retrieve(fineTunedModelCheckpoint, query = {}, options) {
        return this._client.get(path2`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
          query,
          ...options
        });
      }
      /**
       * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
       *
       * Organization owners can use this endpoint to delete a permission for a
       * fine-tuned model checkpoint.
       *
       * @example
       * ```ts
       * const permission =
       *   await client.fineTuning.checkpoints.permissions.delete(
       *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
       *     {
       *       fine_tuned_model_checkpoint:
       *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
       *     },
       *   );
       * ```
       */
      delete(permissionID, params, options) {
        const { fine_tuned_model_checkpoint } = params;
        return this._client.delete(path2`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints;
var init_checkpoints = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs"() {
    init_resource();
    init_permissions();
    init_permissions();
    Checkpoints = class extends APIResource {
      constructor() {
        super(...arguments);
        this.permissions = new Permissions(this._client);
      }
    };
    Checkpoints.Permissions = Permissions;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2;
var init_checkpoints2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    Checkpoints2 = class extends APIResource {
      /**
       * List checkpoints for a fine-tuning job.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(fineTuningJobID, query = {}, options) {
        return this._client.getAPIList(path2`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs;
var init_jobs = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/jobs/jobs.mjs"() {
    init_resource();
    init_checkpoints2();
    init_checkpoints2();
    init_pagination();
    init_path();
    Jobs = class extends APIResource {
      constructor() {
        super(...arguments);
        this.checkpoints = new Checkpoints2(this._client);
      }
      /**
       * Creates a fine-tuning job which begins the process of creating a new model from
       * a given dataset.
       *
       * Response includes details of the enqueued job including job status and the name
       * of the fine-tuned models once complete.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.create({
       *   model: 'gpt-4o-mini',
       *   training_file: 'file-abc123',
       * });
       * ```
       */
      create(body, options) {
        return this._client.post("/fine_tuning/jobs", { body, ...options });
      }
      /**
       * Get info about a fine-tuning job.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.retrieve(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      retrieve(fineTuningJobID, options) {
        return this._client.get(path2`/fine_tuning/jobs/${fineTuningJobID}`, options);
      }
      /**
       * List your organization's fine-tuning jobs
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
      }
      /**
       * Immediately cancel a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.cancel(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      cancel(fineTuningJobID, options) {
        return this._client.post(path2`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
      }
      /**
       * Get status updates for a fine-tuning job.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * )) {
       *   // ...
       * }
       * ```
       */
      listEvents(fineTuningJobID, query = {}, options) {
        return this._client.getAPIList(path2`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
      }
      /**
       * Pause a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.pause(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      pause(fineTuningJobID, options) {
        return this._client.post(path2`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
      }
      /**
       * Resume a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.resume(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      resume(fineTuningJobID, options) {
        return this._client.post(path2`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
      }
    };
    Jobs.Checkpoints = Checkpoints2;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning;
var init_fine_tuning = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/fine-tuning/fine-tuning.mjs"() {
    init_resource();
    init_methods();
    init_methods();
    init_alpha();
    init_alpha();
    init_checkpoints();
    init_checkpoints();
    init_jobs();
    init_jobs();
    FineTuning = class extends APIResource {
      constructor() {
        super(...arguments);
        this.methods = new Methods(this._client);
        this.jobs = new Jobs(this._client);
        this.checkpoints = new Checkpoints(this._client);
        this.alpha = new Alpha(this._client);
      }
    };
    FineTuning.Methods = Methods;
    FineTuning.Jobs = Jobs;
    FineTuning.Checkpoints = Checkpoints;
    FineTuning.Alpha = Alpha;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/graders/grader-models.mjs
var GraderModels;
var init_grader_models = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/graders/grader-models.mjs"() {
    init_resource();
    GraderModels = class extends APIResource {
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/graders/graders.mjs
var Graders2;
var init_graders2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/graders/graders.mjs"() {
    init_resource();
    init_grader_models();
    init_grader_models();
    Graders2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.graderModels = new GraderModels(this._client);
      }
    };
    Graders2.GraderModels = GraderModels;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/images.mjs
var Images;
var init_images = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/images.mjs"() {
    init_resource();
    init_uploads();
    Images = class extends APIResource {
      /**
       * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
       *
       * @example
       * ```ts
       * const imagesResponse = await client.images.createVariation({
       *   image: fs.createReadStream('otter.png'),
       * });
       * ```
       */
      createVariation(body, options) {
        return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }, this._client));
      }
      edit(body, options) {
        return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options, stream: body.stream ?? false }, this._client));
      }
      generate(body, options) {
        return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/models.mjs
var Models;
var init_models = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/models.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    Models = class extends APIResource {
      /**
       * Retrieves a model instance, providing basic information about the model such as
       * the owner and permissioning.
       */
      retrieve(model, options) {
        return this._client.get(path2`/models/${model}`, options);
      }
      /**
       * Lists the currently available models, and provides basic information about each
       * one such as the owner and availability.
       */
      list(options) {
        return this._client.getAPIList("/models", Page, options);
      }
      /**
       * Delete a fine-tuned model. You must have the Owner role in your organization to
       * delete a model.
       */
      delete(model, options) {
        return this._client.delete(path2`/models/${model}`, options);
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/moderations.mjs
var Moderations;
var init_moderations = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/moderations.mjs"() {
    init_resource();
    Moderations = class extends APIResource {
      /**
       * Classifies if text and/or image inputs are potentially harmful. Learn more in
       * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
       */
      create(body, options) {
        return this._client.post("/moderations", { body, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/realtime/calls.mjs
var Calls;
var init_calls = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/realtime/calls.mjs"() {
    init_resource();
    init_headers();
    init_path();
    Calls = class extends APIResource {
      /**
       * Accept an incoming SIP call and configure the realtime session that will handle
       * it.
       *
       * @example
       * ```ts
       * await client.realtime.calls.accept('call_id', {
       *   type: 'realtime',
       * });
       * ```
       */
      accept(callID, body, options) {
        return this._client.post(path2`/realtime/calls/${callID}/accept`, {
          body,
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
      /**
       * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
       *
       * @example
       * ```ts
       * await client.realtime.calls.hangup('call_id');
       * ```
       */
      hangup(callID, options) {
        return this._client.post(path2`/realtime/calls/${callID}/hangup`, {
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
      /**
       * Transfer an active SIP call to a new destination using the SIP REFER verb.
       *
       * @example
       * ```ts
       * await client.realtime.calls.refer('call_id', {
       *   target_uri: 'tel:+14155550123',
       * });
       * ```
       */
      refer(callID, body, options) {
        return this._client.post(path2`/realtime/calls/${callID}/refer`, {
          body,
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
      /**
       * Decline an incoming SIP call by returning a SIP status code to the caller.
       *
       * @example
       * ```ts
       * await client.realtime.calls.reject('call_id');
       * ```
       */
      reject(callID, body = {}, options) {
        return this._client.post(path2`/realtime/calls/${callID}/reject`, {
          body,
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/realtime/client-secrets.mjs
var ClientSecrets;
var init_client_secrets = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/realtime/client-secrets.mjs"() {
    init_resource();
    ClientSecrets = class extends APIResource {
      /**
       * Create a Realtime client secret with an associated session configuration.
       *
       * @example
       * ```ts
       * const clientSecret =
       *   await client.realtime.clientSecrets.create();
       * ```
       */
      create(body, options) {
        return this._client.post("/realtime/client_secrets", { body, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/realtime/realtime.mjs
var Realtime2;
var init_realtime2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/realtime/realtime.mjs"() {
    init_resource();
    init_calls();
    init_calls();
    init_client_secrets();
    init_client_secrets();
    Realtime2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.clientSecrets = new ClientSecrets(this._client);
        this.calls = new Calls(this._client);
      }
    };
    Realtime2.ClientSecrets = ClientSecrets;
    Realtime2.Calls = Calls;
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall3(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool2) {
  return tool2?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool2) => tool2.type === "function" && tool2.name === name);
}
function parseToolCall3(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}
var init_ResponsesParser = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/ResponsesParser.mjs"() {
    init_error3();
    init_parser();
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/responses/ResponseStream.mjs
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}
var _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse, ResponseStream;
var init_ResponseStream = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/responses/ResponseStream.mjs"() {
    init_tslib();
    init_error3();
    init_EventStream();
    init_ResponsesParser();
    ResponseStream = class _ResponseStream extends EventStream {
      constructor(params) {
        super();
        _ResponseStream_instances.add(this);
        _ResponseStream_params.set(this, void 0);
        _ResponseStream_currentResponseSnapshot.set(this, void 0);
        _ResponseStream_finalResponse.set(this, void 0);
        __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
      }
      static createResponse(client2, params, options) {
        const runner = new _ResponseStream(params);
        runner._run(() => runner._createOrRetrieveResponse(client2, params, {
          ...options,
          headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      async _createOrRetrieveResponse(client2, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
        let stream;
        let starting_after = null;
        if ("response_id" in params) {
          stream = await client2.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
          starting_after = params.starting_after ?? null;
        } else {
          stream = await client2.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
        }
        this._connected();
        for await (const event of stream) {
          __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
      }
      [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
      }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
        if (this.ended)
          return;
        const maybeEmit = (name, event2) => {
          if (starting_after == null || event2.sequence_number > starting_after) {
            this._emit(name, event2);
          }
        };
        const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
        maybeEmit("event", event);
        switch (event.type) {
          case "response.output_text.delta": {
            const output = response.output[event.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "message") {
              const content = output.content[event.content_index];
              if (!content) {
                throw new OpenAIError(`missing content at index ${event.content_index}`);
              }
              if (content.type !== "output_text") {
                throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
              }
              maybeEmit("response.output_text.delta", {
                ...event,
                snapshot: content.text
              });
            }
            break;
          }
          case "response.function_call_arguments.delta": {
            const output = response.output[event.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "function_call") {
              maybeEmit("response.function_call_arguments.delta", {
                ...event,
                snapshot: output.arguments
              });
            }
            break;
          }
          default:
            maybeEmit(event.type, event);
            break;
        }
      }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
        if (this.ended) {
          throw new OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
        if (!snapshot) {
          throw new OpenAIError(`request ended without sending any events`);
        }
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
        const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
        __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
        return parsedResponse;
      }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
        let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
        if (!snapshot) {
          if (event.type !== "response.created") {
            throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
          }
          snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
          return snapshot;
        }
        switch (event.type) {
          case "response.output_item.added": {
            snapshot.output.push(event.item);
            break;
          }
          case "response.content_part.added": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event.output_index}`);
            }
            const type = output.type;
            const part = event.part;
            if (type === "message" && part.type !== "reasoning_text") {
              output.content.push(part);
            } else if (type === "reasoning" && part.type === "reasoning_text") {
              if (!output.content) {
                output.content = [];
              }
              output.content.push(part);
            }
            break;
          }
          case "response.output_text.delta": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "message") {
              const content = output.content[event.content_index];
              if (!content) {
                throw new OpenAIError(`missing content at index ${event.content_index}`);
              }
              if (content.type !== "output_text") {
                throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
              }
              content.text += event.delta;
            }
            break;
          }
          case "response.function_call_arguments.delta": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "function_call") {
              output.arguments += event.delta;
            }
            break;
          }
          case "response.reasoning_text.delta": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "reasoning") {
              const content = output.content?.[event.content_index];
              if (!content) {
                throw new OpenAIError(`missing content at index ${event.content_index}`);
              }
              if (content.type !== "reasoning_text") {
                throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
              }
              content.text += event.delta;
            }
            break;
          }
          case "response.completed": {
            __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
            break;
          }
        }
        return snapshot;
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("event", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
            }
            const event = pushQueue.shift();
            return { value: event, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      /**
       * @returns a promise that resolves with the final Response, or rejects
       * if an error occurred or the stream ended prematurely without producing a REsponse.
       */
      async finalResponse() {
        await this.done();
        const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
        if (!response)
          throw new OpenAIError("stream ended without producing a ChatCompletion");
        return response;
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/responses/input-items.mjs
var InputItems;
var init_input_items = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/responses/input-items.mjs"() {
    init_resource();
    init_pagination();
    init_path();
    InputItems = class extends APIResource {
      /**
       * Returns a list of input items for a given response.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const responseItem of client.responses.inputItems.list(
       *   'response_id',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(responseID, query = {}, options) {
        return this._client.getAPIList(path2`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/responses/input-tokens.mjs
var InputTokens;
var init_input_tokens = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/responses/input-tokens.mjs"() {
    init_resource();
    InputTokens = class extends APIResource {
      /**
       * Get input token counts
       *
       * @example
       * ```ts
       * const response = await client.responses.inputTokens.count();
       * ```
       */
      count(body = {}, options) {
        return this._client.post("/responses/input_tokens", { body, ...options });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/responses/responses.mjs
var Responses;
var init_responses = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/responses/responses.mjs"() {
    init_ResponsesParser();
    init_ResponseStream();
    init_resource();
    init_input_items();
    init_input_items();
    init_input_tokens();
    init_input_tokens();
    init_headers();
    init_path();
    Responses = class extends APIResource {
      constructor() {
        super(...arguments);
        this.inputItems = new InputItems(this._client);
        this.inputTokens = new InputTokens(this._client);
      }
      create(body, options) {
        return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
          if ("object" in rsp && rsp.object === "response") {
            addOutputText(rsp);
          }
          return rsp;
        });
      }
      retrieve(responseID, query = {}, options) {
        return this._client.get(path2`/responses/${responseID}`, {
          query,
          ...options,
          stream: query?.stream ?? false
        })._thenUnwrap((rsp) => {
          if ("object" in rsp && rsp.object === "response") {
            addOutputText(rsp);
          }
          return rsp;
        });
      }
      /**
       * Deletes a model response with the given ID.
       *
       * @example
       * ```ts
       * await client.responses.delete(
       *   'resp_677efb5139a88190b512bc3fef8e535d',
       * );
       * ```
       */
      delete(responseID, options) {
        return this._client.delete(path2`/responses/${responseID}`, {
          ...options,
          headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
        });
      }
      parse(body, options) {
        return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
      }
      /**
       * Creates a model response stream
       */
      stream(body, options) {
        return ResponseStream.createResponse(this._client, body, options);
      }
      /**
       * Cancels a model response with the given ID. Only responses created with the
       * `background` parameter set to `true` can be cancelled.
       * [Learn more](https://platform.openai.com/docs/guides/background).
       *
       * @example
       * ```ts
       * const response = await client.responses.cancel(
       *   'resp_677efb5139a88190b512bc3fef8e535d',
       * );
       * ```
       */
      cancel(responseID, options) {
        return this._client.post(path2`/responses/${responseID}/cancel`, options);
      }
      /**
       * Compact conversation
       *
       * @example
       * ```ts
       * const compactedResponse = await client.responses.compact({
       *   model: 'gpt-5.2',
       * });
       * ```
       */
      compact(body, options) {
        return this._client.post("/responses/compact", { body, ...options });
      }
    };
    Responses.InputItems = InputItems;
    Responses.InputTokens = InputTokens;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/uploads/parts.mjs
var Parts;
var init_parts = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/uploads/parts.mjs"() {
    init_resource();
    init_uploads();
    init_path();
    Parts = class extends APIResource {
      /**
       * Adds a
       * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
       * A Part represents a chunk of bytes from the file you are trying to upload.
       *
       * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
       * maximum of 8 GB.
       *
       * It is possible to add multiple Parts in parallel. You can decide the intended
       * order of the Parts when you
       * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
       */
      create(uploadID, body, options) {
        return this._client.post(path2`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options }, this._client));
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/uploads/uploads.mjs
var Uploads;
var init_uploads3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/uploads/uploads.mjs"() {
    init_resource();
    init_parts();
    init_parts();
    init_path();
    Uploads = class extends APIResource {
      constructor() {
        super(...arguments);
        this.parts = new Parts(this._client);
      }
      /**
       * Creates an intermediate
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
       * that you can add
       * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
       * Currently, an Upload can accept at most 8 GB in total and expires after an hour
       * after you create it.
       *
       * Once you complete the Upload, we will create a
       * [File](https://platform.openai.com/docs/api-reference/files/object) object that
       * contains all the parts you uploaded. This File is usable in the rest of our
       * platform as a regular File object.
       *
       * For certain `purpose` values, the correct `mime_type` must be specified. Please
       * refer to documentation for the
       * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
       *
       * For guidance on the proper filename extensions for each purpose, please follow
       * the documentation on
       * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
       */
      create(body, options) {
        return this._client.post("/uploads", { body, ...options });
      }
      /**
       * Cancels the Upload. No Parts may be added after an Upload is cancelled.
       */
      cancel(uploadID, options) {
        return this._client.post(path2`/uploads/${uploadID}/cancel`, options);
      }
      /**
       * Completes the
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
       *
       * Within the returned Upload object, there is a nested
       * [File](https://platform.openai.com/docs/api-reference/files/object) object that
       * is ready to use in the rest of the platform.
       *
       * You can specify the order of the Parts by passing in an ordered list of the Part
       * IDs.
       *
       * The number of bytes uploaded upon completion must match the number of bytes
       * initially specified when creating the Upload object. No Parts may be added after
       * an Upload is completed.
       */
      complete(uploadID, body, options) {
        return this._client.post(path2`/uploads/${uploadID}/complete`, { body, ...options });
      }
    };
    Uploads.Parts = Parts;
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/Util.mjs
var allSettledWithThrow;
var init_Util = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/Util.mjs"() {
    allSettledWithThrow = async (promises) => {
      const results = await Promise.allSettled(promises);
      const rejected = results.filter((result) => result.status === "rejected");
      if (rejected.length) {
        for (const result of rejected) {
          console.error(result.reason);
        }
        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
      }
      const values = [];
      for (const result of results) {
        if (result.status === "fulfilled") {
          values.push(result.value);
        }
      }
      return values;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches;
var init_file_batches = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/vector-stores/file-batches.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_sleep();
    init_Util();
    init_path();
    FileBatches = class extends APIResource {
      /**
       * Create a vector store file batch.
       */
      create(vectorStoreID, body, options) {
        return this._client.post(path2`/vector_stores/${vectorStoreID}/file_batches`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Retrieves a vector store file batch.
       */
      retrieve(batchID, params, options) {
        const { vector_store_id } = params;
        return this._client.get(path2`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Cancel a vector store file batch. This attempts to cancel the processing of
       * files in this batch as soon as possible.
       */
      cancel(batchID, params, options) {
        const { vector_store_id } = params;
        return this._client.post(path2`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Create a vector store batch and poll until all files have been processed.
       */
      async createAndPoll(vectorStoreId, body, options) {
        const batch = await this.create(vectorStoreId, body);
        return await this.poll(vectorStoreId, batch.id, options);
      }
      /**
       * Returns a list of vector store files in a batch.
       */
      listFiles(batchID, params, options) {
        const { vector_store_id, ...query } = params;
        return this._client.getAPIList(path2`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
      }
      /**
       * Wait for the given file batch to be processed.
       *
       * Note: this will return even if one of the files failed to process, you need to
       * check batch.file_counts.failed_count to handle this case.
       */
      async poll(vectorStoreID, batchID, options) {
        const headers = buildHeaders([
          options?.headers,
          {
            "X-Stainless-Poll-Helper": "true",
            "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
          }
        ]);
        while (true) {
          const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
            ...options,
            headers
          }).withResponse();
          switch (batch.status) {
            case "in_progress":
              let sleepInterval = 5e3;
              if (options?.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = response.headers.get("openai-poll-after-ms");
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await sleep(sleepInterval);
              break;
            case "failed":
            case "cancelled":
            case "completed":
              return batch;
          }
        }
      }
      /**
       * Uploads the given files concurrently and then creates a vector store file batch.
       *
       * The concurrency limit is configurable using the `maxConcurrency` parameter.
       */
      async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
        if (files == null || files.length == 0) {
          throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
        }
        const configuredConcurrency = options?.maxConcurrency ?? 5;
        const concurrencyLimit = Math.min(configuredConcurrency, files.length);
        const client2 = this._client;
        const fileIterator = files.values();
        const allFileIds = [...fileIds];
        async function processFiles(iterator) {
          for (let item of iterator) {
            const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options);
            allFileIds.push(fileObj.id);
          }
        }
        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
        await allSettledWithThrow(workers);
        return await this.createAndPoll(vectorStoreId, {
          file_ids: allFileIds
        });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/vector-stores/files.mjs
var Files3;
var init_files3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/vector-stores/files.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_utils11();
    init_path();
    Files3 = class extends APIResource {
      /**
       * Create a vector store file by attaching a
       * [File](https://platform.openai.com/docs/api-reference/files) to a
       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
       */
      create(vectorStoreID, body, options) {
        return this._client.post(path2`/vector_stores/${vectorStoreID}/files`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Retrieves a vector store file.
       */
      retrieve(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.get(path2`/vector_stores/${vector_store_id}/files/${fileID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Update attributes on a vector store file.
       */
      update(fileID, params, options) {
        const { vector_store_id, ...body } = params;
        return this._client.post(path2`/vector_stores/${vector_store_id}/files/${fileID}`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Returns a list of vector store files.
       */
      list(vectorStoreID, query = {}, options) {
        return this._client.getAPIList(path2`/vector_stores/${vectorStoreID}/files`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Delete a vector store file. This will remove the file from the vector store but
       * the file itself will not be deleted. To delete the file, use the
       * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
       * endpoint.
       */
      delete(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.delete(path2`/vector_stores/${vector_store_id}/files/${fileID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Attach a file to the given vector store and wait for it to be processed.
       */
      async createAndPoll(vectorStoreId, body, options) {
        const file2 = await this.create(vectorStoreId, body, options);
        return await this.poll(vectorStoreId, file2.id, options);
      }
      /**
       * Wait for the vector store file to finish processing.
       *
       * Note: this will return even if the file failed to process, you need to check
       * file.last_error and file.status to handle these cases
       */
      async poll(vectorStoreID, fileID, options) {
        const headers = buildHeaders([
          options?.headers,
          {
            "X-Stainless-Poll-Helper": "true",
            "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
          }
        ]);
        while (true) {
          const fileResponse = await this.retrieve(fileID, {
            vector_store_id: vectorStoreID
          }, { ...options, headers }).withResponse();
          const file2 = fileResponse.data;
          switch (file2.status) {
            case "in_progress":
              let sleepInterval = 5e3;
              if (options?.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await sleep(sleepInterval);
              break;
            case "failed":
            case "completed":
              return file2;
          }
        }
      }
      /**
       * Upload a file to the `files` API and then attach it to the given vector store.
       *
       * Note the file will be asynchronously processed (you can use the alternative
       * polling helper method to wait for processing to complete).
       */
      async upload(vectorStoreId, file2, options) {
        const fileInfo = await this._client.files.create({ file: file2, purpose: "assistants" }, options);
        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
      }
      /**
       * Add a file to a vector store and poll until processing is complete.
       */
      async uploadAndPoll(vectorStoreId, file2, options) {
        const fileInfo = await this.upload(vectorStoreId, file2, options);
        return await this.poll(vectorStoreId, fileInfo.id, options);
      }
      /**
       * Retrieve the parsed contents of a vector store file.
       */
      content(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.getAPIList(path2`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores;
var init_vector_stores = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/vector-stores/vector-stores.mjs"() {
    init_resource();
    init_file_batches();
    init_file_batches();
    init_files3();
    init_files3();
    init_pagination();
    init_headers();
    init_path();
    VectorStores = class extends APIResource {
      constructor() {
        super(...arguments);
        this.files = new Files3(this._client);
        this.fileBatches = new FileBatches(this._client);
      }
      /**
       * Create a vector store.
       */
      create(body, options) {
        return this._client.post("/vector_stores", {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Retrieves a vector store.
       */
      retrieve(vectorStoreID, options) {
        return this._client.get(path2`/vector_stores/${vectorStoreID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Modifies a vector store.
       */
      update(vectorStoreID, body, options) {
        return this._client.post(path2`/vector_stores/${vectorStoreID}`, {
          body,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Returns a list of vector stores.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/vector_stores", CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Delete a vector store.
       */
      delete(vectorStoreID, options) {
        return this._client.delete(path2`/vector_stores/${vectorStoreID}`, {
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
      /**
       * Search a vector store for relevant chunks based on a query and file attributes
       * filter.
       */
      search(vectorStoreID, body, options) {
        return this._client.getAPIList(path2`/vector_stores/${vectorStoreID}/search`, Page, {
          body,
          method: "post",
          ...options,
          headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
        });
      }
    };
    VectorStores.Files = Files3;
    VectorStores.FileBatches = FileBatches;
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/videos.mjs
var Videos;
var init_videos = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/videos.mjs"() {
    init_resource();
    init_pagination();
    init_headers();
    init_uploads();
    init_path();
    Videos = class extends APIResource {
      /**
       * Create a video
       */
      create(body, options) {
        return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
      }
      /**
       * Retrieve a video
       */
      retrieve(videoID, options) {
        return this._client.get(path2`/videos/${videoID}`, options);
      }
      /**
       * List videos
       */
      list(query = {}, options) {
        return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
      }
      /**
       * Delete a video
       */
      delete(videoID, options) {
        return this._client.delete(path2`/videos/${videoID}`, options);
      }
      /**
       * Download video content
       */
      downloadContent(videoID, query = {}, options) {
        return this._client.get(path2`/videos/${videoID}/content`, {
          query,
          ...options,
          headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
          __binaryResponse: true
        });
      }
      /**
       * Create a video remix
       */
      remix(videoID, body, options) {
        return this._client.post(path2`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
      }
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances, _Webhooks_validateSecret, _Webhooks_getRequiredHeader, Webhooks;
var init_webhooks = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/webhooks.mjs"() {
    init_tslib();
    init_error3();
    init_resource();
    init_headers();
    Webhooks = class extends APIResource {
      constructor() {
        super(...arguments);
        _Webhooks_instances.add(this);
      }
      /**
       * Validates that the given payload was sent by OpenAI and parses the payload.
       */
      async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
        await this.verifySignature(payload, headers, secret, tolerance);
        return JSON.parse(payload);
      }
      /**
       * Validates whether or not the webhook payload was sent by OpenAI.
       *
       * An error will be raised if the webhook payload was not sent by OpenAI.
       *
       * @param payload - The webhook payload
       * @param headers - The webhook headers
       * @param secret - The webhook secret (optional, will use client secret if not provided)
       * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
       */
      async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
        if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
          throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
        }
        __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
        const headersObj = buildHeaders([headers]).values;
        const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
        const timestamp2 = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
        const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
        const timestampSeconds = parseInt(timestamp2, 10);
        if (isNaN(timestampSeconds)) {
          throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
        }
        const nowSeconds = Math.floor(Date.now() / 1e3);
        if (nowSeconds - timestampSeconds > tolerance) {
          throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
        }
        if (timestampSeconds > nowSeconds + tolerance) {
          throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
        }
        const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
        const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
        const signedPayload = webhookId ? `${webhookId}.${timestamp2}.${payload}` : `${timestamp2}.${payload}`;
        const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
        for (const signature of signatures) {
          try {
            const signatureBytes = Buffer.from(signature, "base64");
            const isValid2 = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
            if (isValid2) {
              return;
            }
          } catch {
            continue;
          }
        }
        throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
      }
    };
    _Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
      if (typeof secret !== "string" || secret.length === 0) {
        throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
      }
    }, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
      if (!headers) {
        throw new Error(`Headers are required`);
      }
      const value = headers.get(name);
      if (value === null || value === void 0) {
        throw new Error(`Missing required header: ${name}`);
      }
      return value;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/resources/index.mjs
var init_resources = __esm({
  "node_modules/@langchain/openai/node_modules/openai/resources/index.mjs"() {
    init_chat4();
    init_shared();
    init_audio();
    init_batches();
    init_beta();
    init_completions3();
    init_containers();
    init_conversations();
    init_embeddings3();
    init_evals();
    init_files2();
    init_fine_tuning();
    init_graders2();
    init_images();
    init_models();
    init_moderations();
    init_realtime2();
    init_responses();
    init_uploads3();
    init_vector_stores();
    init_videos();
    init_webhooks();
  }
});

// node_modules/@langchain/openai/node_modules/openai/client.mjs
var _OpenAI_instances, _a2, _OpenAI_encoder, _OpenAI_baseURLOverridden, OpenAI;
var init_client2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/client.mjs"() {
    init_tslib();
    init_uuid3();
    init_values2();
    init_sleep();
    init_errors7();
    init_detect_platform();
    init_shims();
    init_request_options();
    init_qs();
    init_version();
    init_error2();
    init_pagination();
    init_uploads2();
    init_resources();
    init_api_promise();
    init_batches();
    init_completions3();
    init_embeddings3();
    init_files2();
    init_images();
    init_models();
    init_moderations();
    init_videos();
    init_webhooks();
    init_audio();
    init_beta();
    init_chat3();
    init_containers();
    init_conversations();
    init_evals();
    init_fine_tuning();
    init_graders2();
    init_realtime2();
    init_responses();
    init_uploads3();
    init_vector_stores();
    init_detect_platform();
    init_headers();
    init_env4();
    init_log();
    init_values2();
    OpenAI = class {
      /**
       * API Client for interfacing with the OpenAI API.
       *
       * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
       * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
       * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
       * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
       * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
       * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
        _OpenAI_instances.add(this);
        _OpenAI_encoder.set(this, void 0);
        this.completions = new Completions2(this);
        this.chat = new Chat(this);
        this.embeddings = new Embeddings2(this);
        this.files = new Files2(this);
        this.images = new Images(this);
        this.audio = new Audio(this);
        this.moderations = new Moderations(this);
        this.models = new Models(this);
        this.fineTuning = new FineTuning(this);
        this.graders = new Graders2(this);
        this.vectorStores = new VectorStores(this);
        this.webhooks = new Webhooks(this);
        this.beta = new Beta(this);
        this.batches = new Batches(this);
        this.uploads = new Uploads(this);
        this.responses = new Responses(this);
        this.realtime = new Realtime2(this);
        this.conversations = new Conversations(this);
        this.evals = new Evals(this);
        this.containers = new Containers(this);
        this.videos = new Videos(this);
        if (apiKey === void 0) {
          throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
        }
        const options = {
          apiKey,
          organization,
          project,
          webhookSecret,
          ...opts,
          baseURL: baseURL || `https://api.openai.com/v1`
        };
        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
          throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
        }
        this.baseURL = options.baseURL;
        this.timeout = options.timeout ?? _a2.DEFAULT_TIMEOUT;
        this.logger = options.logger ?? console;
        const defaultLogLevel = "warn";
        this.logLevel = defaultLogLevel;
        this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
        this.fetchOptions = options.fetchOptions;
        this.maxRetries = options.maxRetries ?? 2;
        this.fetch = options.fetch ?? getDefaultFetch();
        __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder, "f");
        this._options = options;
        this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
        this.organization = organization;
        this.project = project;
        this.webhookSecret = webhookSecret;
      }
      /**
       * Create a new client instance re-using the same options given to the current client with optional overriding.
       */
      withOptions(options) {
        const client2 = new this.constructor({
          ...this._options,
          baseURL: this.baseURL,
          maxRetries: this.maxRetries,
          timeout: this.timeout,
          logger: this.logger,
          logLevel: this.logLevel,
          fetch: this.fetch,
          fetchOptions: this.fetchOptions,
          apiKey: this.apiKey,
          organization: this.organization,
          project: this.project,
          webhookSecret: this.webhookSecret,
          ...options
        });
        return client2;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      validateHeaders({ values, nulls }) {
        return;
      }
      async authHeaders(opts) {
        return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
      }
      stringifyQuery(query) {
        return stringify2(query, { arrayFormat: "brackets" });
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid42()}`;
      }
      makeStatusError(status, error40, message, headers) {
        return APIError.generate(status, error40, message, headers);
      }
      async _callApiKey() {
        const apiKey = this._options.apiKey;
        if (typeof apiKey !== "function")
          return false;
        let token;
        try {
          token = await apiKey();
        } catch (err) {
          if (err instanceof OpenAIError)
            throw err;
          throw new OpenAIError(
            `Failed to get token from 'apiKey' function: ${err.message}`,
            // @ts-ignore
            { cause: err }
          );
        }
        if (typeof token !== "string" || !token) {
          throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
        }
        this.apiKey = token;
        return true;
      }
      buildURL(path3, query, defaultBaseURL) {
        const baseURL = !__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
        const url2 = isAbsoluteURL(path3) ? new URL(path3) : new URL(baseURL + (baseURL.endsWith("/") && path3.startsWith("/") ? path3.slice(1) : path3));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url2.search = this.stringifyQuery(query);
        }
        return url2.toString();
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
        await this._callApiKey();
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url: url2, options }) {
      }
      get(path3, opts) {
        return this.methodRequest("get", path3, opts);
      }
      post(path3, opts) {
        return this.methodRequest("post", path3, opts);
      }
      patch(path3, opts) {
        return this.methodRequest("patch", path3, opts);
      }
      put(path3, opts) {
        return this.methodRequest("put", path3, opts);
      }
      delete(path3, opts) {
        return this.methodRequest("delete", path3, opts);
      }
      methodRequest(method, path3, opts) {
        return this.request(Promise.resolve(opts).then((opts2) => {
          return { method, path: path3, ...opts2 };
        }));
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
      }
      async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
        const options = await optionsInput;
        const maxRetries = options.maxRetries ?? this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url: url2, timeout } = await this.buildRequest(options, {
          retryCount: maxRetries - retriesRemaining
        });
        await this.prepareRequest(req, { url: url2, options });
        const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
        const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
        const startTime = Date.now();
        loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
          retryOfRequestLogID,
          method: options.method,
          url: url2,
          options,
          headers: req.headers
        }));
        if (options.signal?.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url2, req, timeout, controller).catch(castToError);
        const headersTime = Date.now();
        if (response instanceof globalThis.Error) {
          const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
          if (options.signal?.aborted) {
            throw new APIUserAbortError();
          }
          const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
          if (retriesRemaining) {
            loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
            loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
              retryOfRequestLogID,
              url: url2,
              durationMs: headersTime - startTime,
              message: response.message
            }));
            return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
          }
          loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
          loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
            retryOfRequestLogID,
            url: url2,
            durationMs: headersTime - startTime,
            message: response.message
          }));
          if (isTimeout) {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
        const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url2} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
          const shouldRetry = await this.shouldRetry(response);
          if (retriesRemaining && shouldRetry) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            await CancelReadableStream(response.body);
            loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
            loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
              retryOfRequestLogID,
              url: response.url,
              status: response.status,
              headers: response.headers,
              durationMs: headersTime - startTime
            }));
            return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
          }
          const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
          loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
          const errText = await response.text().catch((err2) => castToError(err2).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
            retryOfRequestLogID,
            url: response.url,
            status: response.status,
            headers: response.headers,
            message: errMessage,
            durationMs: Date.now() - startTime
          }));
          const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
          throw err;
        }
        loggerFor(this).info(responseInfo);
        loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
      }
      getAPIList(path3, Page2, opts) {
        return this.requestAPIList(Page2, { method: "get", path: path3, ...opts });
      }
      requestAPIList(Page2, options) {
        const request = this.makeRequest(options, null, void 0);
        return new PagePromise(this, request, Page2);
      }
      async fetchWithTimeout(url2, init, ms, controller) {
        const { signal, method, ...options } = init || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
        const fetchOptions = {
          signal: controller.signal,
          ...isReadableBody ? { duplex: "half" } : {},
          method: "GET",
          ...options
        };
        if (method) {
          fetchOptions.method = method.toUpperCase();
        }
        try {
          return await this.fetch.call(void 0, url2, fetchOptions);
        } finally {
          clearTimeout(timeout);
        }
      }
      async shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders?.get("retry-after");
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = options.maxRetries ?? this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1, requestLogID);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      async buildRequest(inputOptions, { retryCount = 0 } = {}) {
        const options = { ...inputOptions };
        const { method, path: path3, query, defaultBaseURL } = options;
        const url2 = this.buildURL(path3, query, defaultBaseURL);
        if ("timeout" in options)
          validatePositiveInteger("timeout", options.timeout);
        options.timeout = options.timeout ?? this.timeout;
        const { bodyHeaders, body } = this.buildBody({ options });
        const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
        const req = {
          method,
          headers: reqHeaders,
          ...options.signal && { signal: options.signal },
          ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
          ...body && { body },
          ...this.fetchOptions ?? {},
          ...options.fetchOptions ?? {}
        };
        return { req, url: url2, timeout: options.timeout };
      }
      async buildHeaders({ options, method, bodyHeaders, retryCount }) {
        let idempotencyHeaders = {};
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
        }
        const headers = buildHeaders([
          idempotencyHeaders,
          {
            Accept: "application/json",
            "User-Agent": this.getUserAgent(),
            "X-Stainless-Retry-Count": String(retryCount),
            ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
            ...getPlatformHeaders(),
            "OpenAI-Organization": this.organization,
            "OpenAI-Project": this.project
          },
          await this.authHeaders(options),
          this._options.defaultHeaders,
          bodyHeaders,
          options.headers
        ]);
        this.validateHeaders(headers);
        return headers.values;
      }
      buildBody({ options: { body, headers: rawHeaders } }) {
        if (!body) {
          return { bodyHeaders: void 0, body: void 0 };
        }
        const headers = buildHeaders([rawHeaders]);
        if (
          // Pass raw type verbatim
          ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
          headers.values.has("content-type") || // `Blob` is superset of `File`
          globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
          body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
          body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
          globalThis.ReadableStream && body instanceof globalThis.ReadableStream
        ) {
          return { bodyHeaders: void 0, body };
        } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
          return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
        } else {
          return __classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
        }
      }
    };
    _a2 = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
      return this.baseURL !== "https://api.openai.com/v1";
    };
    OpenAI.OpenAI = _a2;
    OpenAI.DEFAULT_TIMEOUT = 6e5;
    OpenAI.OpenAIError = OpenAIError;
    OpenAI.APIError = APIError;
    OpenAI.APIConnectionError = APIConnectionError;
    OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
    OpenAI.APIUserAbortError = APIUserAbortError;
    OpenAI.NotFoundError = NotFoundError;
    OpenAI.ConflictError = ConflictError;
    OpenAI.RateLimitError = RateLimitError;
    OpenAI.BadRequestError = BadRequestError;
    OpenAI.AuthenticationError = AuthenticationError;
    OpenAI.InternalServerError = InternalServerError;
    OpenAI.PermissionDeniedError = PermissionDeniedError;
    OpenAI.UnprocessableEntityError = UnprocessableEntityError;
    OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
    OpenAI.toFile = toFile;
    OpenAI.Completions = Completions2;
    OpenAI.Chat = Chat;
    OpenAI.Embeddings = Embeddings2;
    OpenAI.Files = Files2;
    OpenAI.Images = Images;
    OpenAI.Audio = Audio;
    OpenAI.Moderations = Moderations;
    OpenAI.Models = Models;
    OpenAI.FineTuning = FineTuning;
    OpenAI.Graders = Graders2;
    OpenAI.VectorStores = VectorStores;
    OpenAI.Webhooks = Webhooks;
    OpenAI.Beta = Beta;
    OpenAI.Batches = Batches;
    OpenAI.Uploads = Uploads;
    OpenAI.Responses = Responses;
    OpenAI.Realtime = Realtime2;
    OpenAI.Conversations = Conversations;
    OpenAI.Evals = Evals;
    OpenAI.Containers = Containers;
    OpenAI.Videos = Videos;
  }
});

// node_modules/@langchain/openai/node_modules/openai/azure.mjs
var init_azure = __esm({
  "node_modules/@langchain/openai/node_modules/openai/azure.mjs"() {
    init_headers();
    init_error3();
    init_utils11();
    init_client2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/index.mjs
var init_openai2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/index.mjs"() {
    init_client2();
    init_uploads2();
    init_api_promise();
    init_client2();
    init_pagination();
    init_error2();
    init_azure();
  }
});

// node_modules/@langchain/openai/dist/utils/client.js
function wrapOpenAIClientError(e) {
  if (!e || typeof e !== "object") return e;
  let error40;
  if (e.constructor.name === APIConnectionTimeoutError.name && "message" in e && typeof e.message === "string") {
    error40 = new Error(e.message);
    error40.name = "TimeoutError";
  } else if (e.constructor.name === APIUserAbortError.name && "message" in e && typeof e.message === "string") {
    error40 = new Error(e.message);
    error40.name = "AbortError";
  } else if ("status" in e && e.status === 400 && "message" in e && typeof e.message === "string" && e.message.includes("tool_calls")) error40 = addLangChainErrorFields2(e, "INVALID_TOOL_RESULTS");
  else if ("status" in e && e.status === 401) error40 = addLangChainErrorFields2(e, "MODEL_AUTHENTICATION");
  else if ("status" in e && e.status === 429) error40 = addLangChainErrorFields2(e, "MODEL_RATE_LIMIT");
  else if ("status" in e && e.status === 404) error40 = addLangChainErrorFields2(e, "MODEL_NOT_FOUND");
  else error40 = e;
  return error40;
}
var init_client3 = __esm({
  "node_modules/@langchain/openai/dist/utils/client.js"() {
    init_errors6();
    init_openai2();
  }
});

// node_modules/@langchain/openai/dist/utils/misc.js
function isReasoningModel(model) {
  if (!model) return false;
  if (/^o\d/.test(model ?? "")) return true;
  if (model.startsWith("gpt-5") && !model.startsWith("gpt-5-chat")) return true;
  return false;
}
function extractGenericMessageCustomRole(message) {
  if (message.role !== "system" && message.role !== "developer" && message.role !== "assistant" && message.role !== "user" && message.role !== "function" && message.role !== "tool") console.warn(`Unknown message role: ${message.role}`);
  return message.role;
}
function getFilenameFromMetadata(block) {
  return block.metadata?.filename ?? block.metadata?.name ?? block.metadata?.title;
}
function getRequiredFilenameFromMetadata(block) {
  const filename = block.metadata?.filename ?? block.metadata?.name ?? block.metadata?.title;
  if (!filename) throw new Error("a filename or name or title is needed via meta-data for OpenAI when working with multimodal blocks");
  return filename;
}
function messageToOpenAIRole(message) {
  const type = message._getType();
  switch (type) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic":
      if (!ChatMessage.isInstance(message)) throw new Error("Invalid generic chat message");
      return extractGenericMessageCustomRole(message);
    default:
      throw new Error(`Unknown message type: ${type}`);
  }
}
function _modelPrefersResponsesAPI(model) {
  return model.includes("gpt-5.2-pro");
}
var iife$1;
var init_misc = __esm({
  "node_modules/@langchain/openai/dist/utils/misc.js"() {
    init_messages2();
    iife$1 = (fn) => fn();
  }
});

// node_modules/@langchain/openai/dist/utils/azure.js
function getEndpoint(config2) {
  const { azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName, azureOpenAIApiKey, azureOpenAIBasePath, baseURL, azureADTokenProvider, azureOpenAIEndpoint } = config2;
  if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIBasePath && azureOpenAIApiDeploymentName) return `${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`;
  if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIEndpoint && azureOpenAIApiDeploymentName) return `${azureOpenAIEndpoint}/openai/deployments/${azureOpenAIApiDeploymentName}`;
  if (azureOpenAIApiKey || azureADTokenProvider) {
    if (!azureOpenAIApiInstanceName) throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!azureOpenAIApiDeploymentName) throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${azureOpenAIApiDeploymentName}`;
  }
  return baseURL;
}
function isHeaders(headers) {
  return typeof Headers !== "undefined" && headers !== null && typeof headers === "object" && Object.prototype.toString.call(headers) === "[object Headers]";
}
function normalizeHeaders(headers) {
  const output = iife$1(() => {
    if (isHeaders(headers)) return headers;
    else if (Array.isArray(headers)) return new Headers(headers);
    else if (typeof headers === "object" && headers !== null && "values" in headers && isHeaders(headers.values)) return headers.values;
    else if (typeof headers === "object" && headers !== null) {
      const entries = Object.entries(headers).filter(([, v]) => typeof v === "string").map(([k, v]) => [k, v]);
      return new Headers(entries);
    }
    return new Headers();
  });
  return Object.fromEntries(output.entries());
}
function getFormattedEnv() {
  let env = getEnv();
  if (env === "node" || env === "deno") env = `(${env}/${process.version}; ${process.platform}; ${process.arch})`;
  return env;
}
function getHeadersWithUserAgent(headers, isAzure = false, version2 = "1.0.0") {
  const normalizedHeaders = normalizeHeaders(headers);
  const env = getFormattedEnv();
  const library = `langchainjs${isAzure ? "-azure" : ""}-openai`;
  return {
    ...normalizedHeaders,
    "User-Agent": normalizedHeaders["User-Agent"] ? `${library}/${version2} (${env})${normalizedHeaders["User-Agent"]}` : `${library}/${version2} (${env})`
  };
}
var init_azure2 = __esm({
  "node_modules/@langchain/openai/dist/utils/azure.js"() {
    init_misc();
    init_env();
  }
});

// node_modules/@langchain/openai/dist/utils/tools.js
function _convertToOpenAITool(tool2, fields) {
  let toolDef;
  if (isLangChainTool(tool2)) toolDef = convertToOpenAITool(tool2);
  else toolDef = tool2;
  if (fields?.strict !== void 0) toolDef.function.strict = fields.strict;
  return toolDef;
}
function isAnyOfProp(prop) {
  return prop.anyOf !== void 0 && Array.isArray(prop.anyOf);
}
function formatFunctionDefinitions(functions) {
  const lines = ["namespace functions {", ""];
  for (const f of functions) {
    if (f.description) lines.push(`// ${f.description}`);
    if (Object.keys(f.parameters.properties ?? {}).length > 0) {
      lines.push(`type ${f.name} = (_: {`);
      lines.push(formatObjectProperties(f.parameters, 0));
      lines.push("}) => any;");
    } else lines.push(`type ${f.name} = () => any;`);
    lines.push("");
  }
  lines.push("} // namespace functions");
  return lines.join("\n");
}
function formatObjectProperties(obj, indent) {
  const lines = [];
  for (const [name, param] of Object.entries(obj.properties ?? {})) {
    if (param.description && indent < 2) lines.push(`// ${param.description}`);
    if (obj.required?.includes(name)) lines.push(`${name}: ${formatType(param, indent)},`);
    else lines.push(`${name}?: ${formatType(param, indent)},`);
  }
  return lines.map((line) => " ".repeat(indent) + line).join("\n");
}
function formatType(param, indent) {
  if (isAnyOfProp(param)) return param.anyOf.map((v) => formatType(v, indent)).join(" | ");
  switch (param.type) {
    case "string":
      if (param.enum) return param.enum.map((v) => `"${v}"`).join(" | ");
      return "string";
    case "number":
      if (param.enum) return param.enum.map((v) => `${v}`).join(" | ");
      return "number";
    case "integer":
      if (param.enum) return param.enum.map((v) => `${v}`).join(" | ");
      return "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return [
        "{",
        formatObjectProperties(param, indent + 2),
        "}"
      ].join("\n");
    case "array":
      if (param.items) return `${formatType(param.items, indent)}[]`;
      return "any[]";
    default:
      return "";
  }
}
function formatToOpenAIToolChoice(toolChoice) {
  if (!toolChoice) return void 0;
  else if (toolChoice === "any" || toolChoice === "required") return "required";
  else if (toolChoice === "auto") return "auto";
  else if (toolChoice === "none") return "none";
  else if (typeof toolChoice === "string") return {
    type: "function",
    function: { name: toolChoice }
  };
  else return toolChoice;
}
function isBuiltInTool(tool2) {
  return "type" in tool2 && tool2.type !== "function";
}
function hasProviderToolDefinition(tool2) {
  return typeof tool2 === "object" && tool2 !== null && "extras" in tool2 && typeof tool2.extras === "object" && tool2.extras !== null && "providerToolDefinition" in tool2.extras && typeof tool2.extras.providerToolDefinition === "object" && tool2.extras.providerToolDefinition !== null;
}
function isBuiltInToolChoice(tool_choice) {
  return tool_choice != null && typeof tool_choice === "object" && "type" in tool_choice && tool_choice.type !== "function";
}
function isCustomTool(tool2) {
  return typeof tool2 === "object" && tool2 !== null && "metadata" in tool2 && typeof tool2.metadata === "object" && tool2.metadata !== null && "customTool" in tool2.metadata && typeof tool2.metadata.customTool === "object" && tool2.metadata.customTool !== null;
}
function isOpenAICustomTool(tool2) {
  return "type" in tool2 && tool2.type === "custom" && "custom" in tool2 && typeof tool2.custom === "object" && tool2.custom !== null;
}
function parseCustomToolCall(rawToolCall) {
  if (rawToolCall.type !== "custom_tool_call") return void 0;
  return {
    ...rawToolCall,
    type: "tool_call",
    call_id: rawToolCall.id,
    id: rawToolCall.call_id,
    name: rawToolCall.name,
    isCustomTool: true,
    args: { input: rawToolCall.input }
  };
}
function parseComputerCall(rawToolCall) {
  if (rawToolCall.type !== "computer_call") return void 0;
  return {
    ...rawToolCall,
    type: "tool_call",
    call_id: rawToolCall.id,
    id: rawToolCall.call_id,
    name: "computer_use",
    isComputerTool: true,
    args: { action: rawToolCall.action }
  };
}
function isComputerToolCall(toolCall) {
  return typeof toolCall === "object" && toolCall !== null && "type" in toolCall && toolCall.type === "tool_call" && "isComputerTool" in toolCall && toolCall.isComputerTool === true;
}
function isCustomToolCall(toolCall) {
  return typeof toolCall === "object" && toolCall !== null && "type" in toolCall && toolCall.type === "tool_call" && "isCustomTool" in toolCall && toolCall.isCustomTool === true;
}
function convertCompletionsCustomTool(tool2) {
  const getFormat = () => {
    if (!tool2.custom.format) return void 0;
    if (tool2.custom.format.type === "grammar") return {
      type: "grammar",
      definition: tool2.custom.format.grammar.definition,
      syntax: tool2.custom.format.grammar.syntax
    };
    if (tool2.custom.format.type === "text") return { type: "text" };
    return void 0;
  };
  return {
    type: "custom",
    name: tool2.custom.name,
    description: tool2.custom.description,
    format: getFormat()
  };
}
function convertResponsesCustomTool(tool2) {
  const getFormat = () => {
    if (!tool2.format) return void 0;
    if (tool2.format.type === "grammar") return {
      type: "grammar",
      grammar: {
        definition: tool2.format.definition,
        syntax: tool2.format.syntax
      }
    };
    if (tool2.format.type === "text") return { type: "text" };
    return void 0;
  };
  return {
    type: "custom",
    custom: {
      name: tool2.name,
      description: tool2.description,
      format: getFormat()
    }
  };
}
var init_tools4 = __esm({
  "node_modules/@langchain/openai/dist/utils/tools.js"() {
    init_function_calling();
    init_types5();
    init_json_schema2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/Options.mjs
var ignoreOverride2, defaultOptions4, getDefaultOptions2;
var init_Options2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/Options.mjs"() {
    ignoreOverride2 = Symbol("Let zodToJsonSchema decide on which parser to use");
    defaultOptions4 = {
      name: void 0,
      $refStrategy: "root",
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      nullableStrategy: "from-target",
      removeAdditionalStrategy: "passthrough",
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions2 = (options) => {
      return typeof options === "string" ? {
        ...defaultOptions4,
        basePath: ["#"],
        definitions: {},
        name: options
      } : {
        ...defaultOptions4,
        basePath: ["#"],
        definitions: {},
        ...options
      };
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/util.mjs
function isEmptyObj2(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
var zodDef;
var init_util3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/util.mjs"() {
    zodDef = (zodSchema) => {
      return "_def" in zodSchema ? zodSchema._def : zodSchema;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/Refs.mjs
var getRefs2;
var init_Refs2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/Refs.mjs"() {
    init_Options2();
    init_util3();
    getRefs2 = (options) => {
      const _options = getDefaultOptions2(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seenRefs: /* @__PURE__ */ new Set(),
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
          zodDef(def),
          {
            def: zodDef(def),
            path: [..._options.basePath, _options.definitionPath, name],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ]))
      };
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/errorMessages.mjs
function addErrorMessage2(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors2(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage2(res, key, errorMessage, refs);
}
var init_errorMessages2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/errorMessages.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/any.mjs
function parseAnyDef2() {
  return {};
}
var init_any2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/any.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/array.mjs
function parseArrayDef2(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors2(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors2(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors2(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors2(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
var init_array2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/array.mjs"() {
    init_v3();
    init_errorMessages2();
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/bigint.mjs
function parseBigintDef2(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors2(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors2(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors2(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors2(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors2(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}
var init_bigint2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/bigint.mjs"() {
    init_errorMessages2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/boolean.mjs
function parseBooleanDef2() {
  return {
    type: "boolean"
  };
}
var init_boolean2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/boolean.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/branded.mjs
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
var init_branded2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/branded.mjs"() {
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/catch.mjs
var parseCatchDef2;
var init_catch2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/catch.mjs"() {
    init_parseDef2();
    parseCatchDef2 = (def, refs) => {
      return parseDef2(def.innerType._def, refs);
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/date.mjs
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
var integerDateParser2;
var init_date2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/date.mjs"() {
    init_errorMessages2();
    integerDateParser2 = (def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      if (refs.target === "openApi3") {
        return res;
      }
      for (const check2 of def.checks) {
        switch (check2.kind) {
          case "min":
            setResponseValueAndErrors2(
              res,
              "minimum",
              check2.value,
              // This is in milliseconds
              check2.message,
              refs
            );
            break;
          case "max":
            setResponseValueAndErrors2(
              res,
              "maximum",
              check2.value,
              // This is in milliseconds
              check2.message,
              refs
            );
            break;
        }
      }
      return res;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/default.mjs
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
var init_default2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/default.mjs"() {
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/effects.mjs
function parseEffectsDef2(_def, refs, forceResolution) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs, forceResolution) : {};
}
var init_effects2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/effects.mjs"() {
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/enum.mjs
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: [...def.values]
  };
}
var init_enum2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/enum.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/intersection.mjs
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
var isJsonSchema7AllOfType2;
var init_intersection2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/intersection.mjs"() {
    init_parseDef2();
    isJsonSchema7AllOfType2 = (type) => {
      if ("type" in type && type.type === "string")
        return false;
      return "allOf" in type;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/literal.mjs
function parseLiteralDef2(def, refs) {
  const parsedType4 = typeof def.value;
  if (parsedType4 !== "bigint" && parsedType4 !== "number" && parsedType4 !== "boolean" && parsedType4 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType4 === "bigint" ? "integer" : parsedType4,
      enum: [def.value]
    };
  }
  return {
    type: parsedType4 === "bigint" ? "integer" : parsedType4,
    const: def.value
  };
}
var init_literal2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/literal.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/string.mjs
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(value) : value;
  }
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          setResponseValueAndErrors2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "max":
          setResponseValueAndErrors2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern2(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern2(res, RegExp(`^${processPattern(check2.value)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern2(res, RegExp(`${processPattern(check2.value)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat2(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check2.message, refs);
          break;
        case "length":
          setResponseValueAndErrors2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          setResponseValueAndErrors2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "includes": {
          addPattern2(res, RegExp(processPattern(check2.value)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat2(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat2(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji, check2.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors2(res, "contentEncoding", "base64", check2.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check2);
      }
    }
  }
  return res;
}
var emojiRegex3, zodPatterns2, escapeNonAlphaNumeric2, addFormat2, addPattern2, processRegExp;
var init_string4 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/string.mjs"() {
    init_errorMessages2();
    zodPatterns2 = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => {
        if (emojiRegex3 === void 0) {
          emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex3;
      },
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/
    };
    escapeNonAlphaNumeric2 = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
    addFormat2 = (schema, value, message, refs) => {
      if (schema.format || schema.anyOf?.some((x) => x.format)) {
        if (!schema.anyOf) {
          schema.anyOf = [];
        }
        if (schema.format) {
          schema.anyOf.push({
            format: schema.format,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { format: schema.errorMessage.format }
            }
          });
          delete schema.format;
          if (schema.errorMessage) {
            delete schema.errorMessage.format;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.anyOf.push({
          format: value,
          ...message && refs.errorMessages && { errorMessage: { format: message } }
        });
      } else {
        setResponseValueAndErrors2(schema, "format", value, message, refs);
      }
    };
    addPattern2 = (schema, regex2, message, refs) => {
      if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
        if (!schema.allOf) {
          schema.allOf = [];
        }
        if (schema.pattern) {
          schema.allOf.push({
            pattern: schema.pattern,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { pattern: schema.errorMessage.pattern }
            }
          });
          delete schema.pattern;
          if (schema.errorMessage) {
            delete schema.errorMessage.pattern;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.allOf.push({
          pattern: processRegExp(regex2, refs),
          ...message && refs.errorMessages && { errorMessage: { pattern: message } }
        });
      } else {
        setResponseValueAndErrors2(schema, "pattern", processRegExp(regex2, refs), message, refs);
      }
    };
    processRegExp = (regexOrFunction, refs) => {
      const regex2 = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
      if (!refs.applyRegexFlags || !regex2.flags)
        return regex2.source;
      const flags = {
        i: regex2.flags.includes("i"),
        // Case-insensitive
        m: regex2.flags.includes("m"),
        // `^` and `$` matches adjacent to newline characters
        s: regex2.flags.includes("s")
        // `.` matches newlines
      };
      const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
      let pattern = "";
      let isEscaped = false;
      let inCharGroup = false;
      let inCharRange = false;
      for (let i = 0; i < source.length; i++) {
        if (isEscaped) {
          pattern += source[i];
          isEscaped = false;
          continue;
        }
        if (flags.i) {
          if (inCharGroup) {
            if (source[i].match(/[a-z]/)) {
              if (inCharRange) {
                pattern += source[i];
                pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                inCharRange = false;
              } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                pattern += source[i];
                inCharRange = true;
              } else {
                pattern += `${source[i]}${source[i].toUpperCase()}`;
              }
              continue;
            }
          } else if (source[i].match(/[a-z]/)) {
            pattern += `[${source[i]}${source[i].toUpperCase()}]`;
            continue;
          }
        }
        if (flags.m) {
          if (source[i] === "^") {
            pattern += `(^|(?<=[\r
]))`;
            continue;
          } else if (source[i] === "$") {
            pattern += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (flags.s && source[i] === ".") {
          pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
          continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
          isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
          inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
          inCharGroup = true;
        }
      }
      try {
        const regexTest = new RegExp(pattern);
      } catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex2.source;
      }
      return pattern;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/record.mjs
function parseRecordDef2(def, refs) {
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef2(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const keyType = Object.entries(parseStringDef2(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}
var init_record2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/record.mjs"() {
    init_v3();
    init_parseDef2();
    init_string4();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/map.mjs
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys = parseDef2(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
var init_map2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/map.mjs"() {
    init_parseDef2();
    init_record2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/nativeEnum.mjs
function parseNativeEnumDef2(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
var init_nativeEnum2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/nativeEnum.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/never.mjs
function parseNeverDef2() {
  return {
    not: {}
  };
}
var init_never2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/never.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/null.mjs
function parseNullDef2(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
var init_null2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/null.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/union.mjs
function parseUnionDef2(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf2(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings2[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))], [])
    };
  }
  return asAnyOf2(def, refs);
}
var primitiveMappings2, asAnyOf2;
var init_union2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/union.mjs"() {
    init_parseDef2();
    primitiveMappings2 = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf2 = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`]
      })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/nullable.mjs
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3" || refs.nullableStrategy === "property") {
      return {
        type: primitiveMappings2[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings2[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
var init_nullable2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/nullable.mjs"() {
    init_parseDef2();
    init_union2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/number.mjs
function parseNumberDef2(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage2(res, "type", check2.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors2(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors2(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors2(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors2(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors2(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}
var init_number2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/number.mjs"() {
    init_errorMessages2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/object.mjs
function decideAdditionalProperties2(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
function parseObjectDef2(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName2, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const propertyPath = [...refs.currentPath, "properties", propName2];
      const parsedDef = parseDef2(propDef._def, {
        ...refs,
        currentPath: propertyPath,
        propertyPath
      });
      if (parsedDef === void 0)
        return acc;
      if (refs.openaiStrictMode && propDef.isOptional() && !propDef.isNullable() && typeof propDef._def?.defaultValue === "undefined") {
        throw new Error(`Zod field at \`${propertyPath.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      }
      return {
        properties: {
          ...acc.properties,
          [propName2]: parsedDef
        },
        required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName2]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties2(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}
var init_object2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/object.mjs"() {
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/optional.mjs
var parseOptionalDef2;
var init_optional2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/optional.mjs"() {
    init_parseDef2();
    parseOptionalDef2 = (def, refs) => {
      if (refs.propertyPath && refs.currentPath.slice(0, refs.propertyPath.length).toString() === refs.propertyPath.toString()) {
        return parseDef2(def.innerType._def, { ...refs, currentPath: refs.currentPath });
      }
      const innerSchema = parseDef2(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? {
        anyOf: [
          {
            not: {}
          },
          innerSchema
        ]
      } : {};
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/pipeline.mjs
var parsePipelineDef2;
var init_pipeline3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/pipeline.mjs"() {
    init_parseDef2();
    parsePipelineDef2 = (def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef2(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef2(def.out._def, refs);
      }
      const a = parseDef2(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef2(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
      });
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/promise.mjs
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
var init_promise2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/promise.mjs"() {
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/set.mjs
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors2(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors2(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
var init_set2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/set.mjs"() {
    init_errorMessages2();
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/tuple.mjs
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
var init_tuple2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/tuple.mjs"() {
    init_parseDef2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/undefined.mjs
function parseUndefinedDef2() {
  return {
    not: {}
  };
}
var init_undefined2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/undefined.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/unknown.mjs
function parseUnknownDef2() {
  return {};
}
var init_unknown2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/unknown.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/readonly.mjs
var parseReadonlyDef2;
var init_readonly2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parsers/readonly.mjs"() {
    init_parseDef2();
    parseReadonlyDef2 = (def, refs) => {
      return parseDef2(def.innerType._def, refs);
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parseDef.mjs
function parseDef2(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      if ("$ref" in seenSchema) {
        refs.seenRefs.add(seenSchema.$ref);
      }
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser2(def, def.typeName, refs, forceResolution);
  if (jsonSchema) {
    addMeta2(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref2, getRelativePath2, selectParser2, addMeta2;
var init_parseDef2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/parseDef.mjs"() {
    init_v3();
    init_any2();
    init_array2();
    init_bigint2();
    init_boolean2();
    init_branded2();
    init_catch2();
    init_date2();
    init_default2();
    init_effects2();
    init_enum2();
    init_intersection2();
    init_literal2();
    init_map2();
    init_nativeEnum2();
    init_never2();
    init_null2();
    init_nullable2();
    init_number2();
    init_object2();
    init_optional2();
    init_pipeline3();
    init_promise2();
    init_record2();
    init_set2();
    init_string4();
    init_tuple2();
    init_undefined2();
    init_union2();
    init_unknown2();
    init_readonly2();
    init_Options2();
    get$ref2 = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
        // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
        // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
        // the schema to `#/definitions/` and reference that.
        //
        // e.g. if we need to reference a schema at
        // `["#","definitions","contactPerson","properties","person1","properties","name"]`
        // then we'll extract it out to `contactPerson_properties_person1_properties_name`
        case "extract-to-root":
          const name = item.path.slice(refs.basePath.length + 1).join("_");
          if (name !== refs.name && refs.nameStrategy === "duplicate-ref") {
            refs.definitions[name] = item.def;
          }
          return { $ref: [...refs.basePath, refs.definitionPath, name].join("/") };
        case "relative":
          return { $ref: getRelativePath2(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index2) => refs.currentPath[index2] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return {};
          }
          return refs.$refStrategy === "seen" ? {} : void 0;
        }
      }
    };
    getRelativePath2 = (pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i])
          break;
      }
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    };
    selectParser2 = (def, typeName, refs, forceResolution) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef2();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef2();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef2(refs);
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef2(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef2(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return parseDef2(def.getter()._def, refs);
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef2();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef2(def, refs, forceResolution);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef2();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef2();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef2(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    };
    addMeta2 = (def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
          jsonSchema.markdownDescription = def.description;
        }
      }
      return jsonSchema;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/zodToJsonSchema.mjs
var zodToJsonSchema2;
var init_zodToJsonSchema2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/zodToJsonSchema.mjs"() {
    init_parseDef2();
    init_Refs2();
    init_util3();
    zodToJsonSchema2 = (schema, options) => {
      const refs = getRefs2(options);
      const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
      const main = parseDef2(schema._def, name === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name]
      }, false) ?? {};
      const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title !== void 0) {
        main.title = title;
      }
      const definitions = (() => {
        if (isEmptyObj2(refs.definitions)) {
          return void 0;
        }
        const definitions2 = {};
        const processedDefinitions = /* @__PURE__ */ new Set();
        for (let i = 0; i < 500; i++) {
          const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));
          if (newDefinitions.length === 0)
            break;
          for (const [key, schema2] of newDefinitions) {
            definitions2[key] = parseDef2(zodDef(schema2), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};
            processedDefinitions.add(key);
          }
        }
        return definitions2;
      })();
      const combined = name === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : refs.nameStrategy === "duplicate-ref" ? {
        ...main,
        ...definitions || refs.seenRefs.size ? {
          [refs.definitionPath]: {
            ...definitions,
            // only actually duplicate the schema definition if it was ever referenced
            // otherwise the duplication is completely pointless
            ...refs.seenRefs.size ? { [name]: main } : void 0
          }
        } : void 0
      } : {
        $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name]: main
        }
      };
      if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
      } else if (refs.target === "jsonSchema2019-09") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      }
      return combined;
    };
  }
});

// node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/index.mjs
var init_zod_to_json_schema2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/_vendor/zod-to-json-schema/index.mjs"() {
    init_Options2();
    init_Refs2();
    init_errorMessages2();
    init_parseDef2();
    init_any2();
    init_array2();
    init_bigint2();
    init_boolean2();
    init_branded2();
    init_catch2();
    init_date2();
    init_default2();
    init_effects2();
    init_enum2();
    init_intersection2();
    init_literal2();
    init_map2();
    init_nativeEnum2();
    init_never2();
    init_null2();
    init_nullable2();
    init_number2();
    init_object2();
    init_optional2();
    init_pipeline3();
    init_promise2();
    init_readonly2();
    init_record2();
    init_set2();
    init_string4();
    init_tuple2();
    init_undefined2();
    init_union2();
    init_unknown2();
    init_zodToJsonSchema2();
    init_zodToJsonSchema2();
  }
});

// node_modules/@langchain/openai/node_modules/openai/lib/transform.mjs
function toStrictJsonSchema(schema) {
  if (schema.type !== "object") {
    throw new Error(`Root schema must have type: 'object' but got type: ${schema.type ? `'${schema.type}'` : "undefined"}`);
  }
  const schemaCopy = structuredClone(schema);
  return ensureStrictJsonSchema(schemaCopy, [], schemaCopy);
}
function isNullable(schema) {
  if (typeof schema === "boolean") {
    return false;
  }
  if (schema.type === "null") {
    return true;
  }
  for (const oneOfVariant of schema.oneOf ?? []) {
    if (isNullable(oneOfVariant)) {
      return true;
    }
  }
  for (const allOfVariant of schema.anyOf ?? []) {
    if (isNullable(allOfVariant)) {
      return true;
    }
  }
  return false;
}
function ensureStrictJsonSchema(jsonSchema, path3, root) {
  if (typeof jsonSchema === "boolean") {
    throw new TypeError(`Expected object schema but got boolean; path=${path3.join("/")}`);
  }
  if (!isObject3(jsonSchema)) {
    throw new TypeError(`Expected ${JSON.stringify(jsonSchema)} to be an object; path=${path3.join("/")}`);
  }
  const defs = jsonSchema.$defs;
  if (isObject3(defs)) {
    for (const [defName, defSchema] of Object.entries(defs)) {
      ensureStrictJsonSchema(defSchema, [...path3, "$defs", defName], root);
    }
  }
  const definitions = jsonSchema.definitions;
  if (isObject3(definitions)) {
    for (const [definitionName, definitionSchema] of Object.entries(definitions)) {
      ensureStrictJsonSchema(definitionSchema, [...path3, "definitions", definitionName], root);
    }
  }
  const typ = jsonSchema.type;
  if (typ === "object" && !("additionalProperties" in jsonSchema)) {
    jsonSchema.additionalProperties = false;
  }
  const required2 = jsonSchema.required ?? [];
  const properties = jsonSchema.properties;
  if (isObject3(properties)) {
    for (const [key, value] of Object.entries(properties)) {
      if (!isNullable(value) && !required2.includes(key)) {
        throw new Error(`Zod field at \`${[...path3, "properties", key].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      }
    }
    jsonSchema.required = Object.keys(properties);
    jsonSchema.properties = Object.fromEntries(Object.entries(properties).map(([key, propSchema]) => [
      key,
      ensureStrictJsonSchema(propSchema, [...path3, "properties", key], root)
    ]));
  }
  const items = jsonSchema.items;
  if (isObject3(items)) {
    jsonSchema.items = ensureStrictJsonSchema(items, [...path3, "items"], root);
  }
  const anyOf = jsonSchema.anyOf;
  if (Array.isArray(anyOf)) {
    jsonSchema.anyOf = anyOf.map((variant, i) => ensureStrictJsonSchema(variant, [...path3, "anyOf", String(i)], root));
  }
  const allOf = jsonSchema.allOf;
  if (Array.isArray(allOf)) {
    if (allOf.length === 1) {
      const resolved = ensureStrictJsonSchema(allOf[0], [...path3, "allOf", "0"], root);
      Object.assign(jsonSchema, resolved);
      delete jsonSchema.allOf;
    } else {
      jsonSchema.allOf = allOf.map((entry, i) => ensureStrictJsonSchema(entry, [...path3, "allOf", String(i)], root));
    }
  }
  if (jsonSchema.default === null) {
    delete jsonSchema.default;
  }
  const ref = jsonSchema.$ref;
  if (ref && hasMoreThanNKeys(jsonSchema, 1)) {
    if (typeof ref !== "string") {
      throw new TypeError(`Received non-string $ref - ${ref}; path=${path3.join("/")}`);
    }
    const resolved = resolveRef(root, ref);
    if (typeof resolved === "boolean") {
      throw new Error(`Expected \`$ref: ${ref}\` to resolve to an object schema but got boolean`);
    }
    if (!isObject3(resolved)) {
      throw new Error(`Expected \`$ref: ${ref}\` to resolve to an object but got ${JSON.stringify(resolved)}`);
    }
    Object.assign(jsonSchema, { ...resolved, ...jsonSchema });
    delete jsonSchema.$ref;
    return ensureStrictJsonSchema(jsonSchema, path3, root);
  }
  return jsonSchema;
}
function resolveRef(root, ref) {
  if (!ref.startsWith("#/")) {
    throw new Error(`Unexpected $ref format ${JSON.stringify(ref)}; Does not start with #/`);
  }
  const pathParts = ref.slice(2).split("/");
  let resolved = root;
  for (const key of pathParts) {
    if (!isObject3(resolved)) {
      throw new Error(`encountered non-object entry while resolving ${ref} - ${JSON.stringify(resolved)}`);
    }
    const value = resolved[key];
    if (value === void 0) {
      throw new Error(`Key ${key} not found while resolving ${ref}`);
    }
    resolved = value;
  }
  return resolved;
}
function isObject3(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function hasMoreThanNKeys(obj, n2) {
  let i = 0;
  for (const _ in obj) {
    i++;
    if (i > n2) {
      return true;
    }
  }
  return false;
}
var init_transform2 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/lib/transform.mjs"() {
  }
});

// node_modules/@langchain/openai/node_modules/openai/helpers/zod.mjs
function zodV3ToJsonSchema(schema, options) {
  return zodToJsonSchema2(schema, {
    openaiStrictMode: true,
    name: options.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function zodV4ToJsonSchema(schema) {
  return toStrictJsonSchema(toJSONSchema(schema, {
    target: "draft-7"
  }));
}
function isZodV4(zodObject) {
  return "_zod" in zodObject;
}
function zodResponseFormat(zodObject, name, props) {
  return makeParseableResponseFormat({
    type: "json_schema",
    json_schema: {
      ...props,
      name,
      strict: true,
      schema: isZodV4(zodObject) ? zodV4ToJsonSchema(zodObject) : zodV3ToJsonSchema(zodObject, { name })
    }
  }, (content) => zodObject.parse(JSON.parse(content)));
}
var init_zod3 = __esm({
  "node_modules/@langchain/openai/node_modules/openai/helpers/zod.mjs"() {
    init_v43();
    init_parser();
    init_zod_to_json_schema2();
    init_ResponsesParser();
    init_transform2();
  }
});

// node_modules/@langchain/openai/dist/utils/output.js
function getStructuredOutputMethod(model, method) {
  if (typeof method !== "undefined" && !SUPPORTED_METHODS.includes(method)) throw new Error(`Invalid method: ${method}. Supported methods are: ${SUPPORTED_METHODS.join(", ")}`);
  const hasSupportForJsonSchema = !model.startsWith("gpt-3") && !model.startsWith("gpt-4-") && model !== "gpt-4";
  if (hasSupportForJsonSchema && !method) return "jsonSchema";
  if (!hasSupportForJsonSchema && method === "jsonSchema") throw new Error(`JSON Schema is not supported for model "${model}". Please use a different method, e.g. "functionCalling" or "jsonMode".`);
  return method ?? "functionCalling";
}
function makeParseableResponseFormat2(response_format, parser) {
  const obj = { ...response_format };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    }
  });
  return obj;
}
function interopZodResponseFormat(zodSchema, name, props) {
  if (isZodSchemaV3(zodSchema)) return zodResponseFormat(zodSchema, name, props);
  if (isZodSchemaV4(zodSchema)) return makeParseableResponseFormat2({
    type: "json_schema",
    json_schema: {
      ...props,
      name,
      strict: true,
      schema: toJsonSchema(zodSchema, {
        cycles: "ref",
        reused: "ref",
        override(ctx) {
          ctx.jsonSchema.title = name;
        }
      })
    }
  }, (content) => parse4(zodSchema, JSON.parse(content)));
  throw new Error("Unsupported schema response format");
}
function handleMultiModalOutput(content, messages) {
  if (messages && typeof messages === "object" && "images" in messages && Array.isArray(messages.images)) {
    const images = messages.images.filter((image) => typeof image?.image_url?.url === "string").map((image) => ({
      type: "image",
      url: image.image_url.url
    }));
    return [{
      type: "text",
      text: content
    }, ...images];
  }
  return content;
}
var SUPPORTED_METHODS;
var init_output = __esm({
  "node_modules/@langchain/openai/dist/utils/output.js"() {
    init_types5();
    init_json_schema2();
    init_core3();
    init_zod3();
    SUPPORTED_METHODS = [
      "jsonSchema",
      "functionCalling",
      "jsonMode"
    ];
  }
});

// node_modules/@langchain/openai/dist/chat_models/profiles.js
var PROFILES, profiles_default;
var init_profiles = __esm({
  "node_modules/@langchain/openai/dist/chat_models/profiles.js"() {
    PROFILES = {
      "gpt-4.1-nano": {
        maxInputTokens: 1047576,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 32768,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "text-embedding-3-small": {
        maxInputTokens: 8191,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1536,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4": {
        maxInputTokens: 8192,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 8192,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o1-pro": {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4o-2024-05-13": {
        maxInputTokens: 128e3,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 4096,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4o-2024-08-06": {
        maxInputTokens: 128e3,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 16384,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4.1-mini": {
        maxInputTokens: 1047576,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 32768,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o3-deep-research": {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-3.5-turbo": {
        maxInputTokens: 16385,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: false,
        videoInputs: false,
        maxOutputTokens: 4096,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: false,
        imageUrlInputs: false,
        pdfToolMessage: false,
        imageToolMessage: false,
        toolChoice: true
      },
      "text-embedding-3-large": {
        maxInputTokens: 8191,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 3072,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4-turbo": {
        maxInputTokens: 128e3,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 4096,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o1-preview": {
        maxInputTokens: 128e3,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 32768,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o3-mini": {
        maxInputTokens: 2e5,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "codex-mini-latest": {
        maxInputTokens: 2e5,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-5-nano": {
        maxInputTokens: 4e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 128e3,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-5-codex": {
        maxInputTokens: 4e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 128e3,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4o": {
        maxInputTokens: 128e3,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 16384,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4.1": {
        maxInputTokens: 1047576,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 32768,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o4-mini": {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      o1: {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-5-mini": {
        maxInputTokens: 4e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 128e3,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o1-mini": {
        maxInputTokens: 128e3,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 65536,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "text-embedding-ada-002": {
        maxInputTokens: 8192,
        imageInputs: false,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1536,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o3-pro": {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4o-2024-11-20": {
        maxInputTokens: 128e3,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 16384,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      o3: {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "o4-mini-deep-research": {
        maxInputTokens: 2e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 1e5,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-5-chat-latest": {
        maxInputTokens: 4e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 128e3,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: false,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-4o-mini": {
        maxInputTokens: 128e3,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 16384,
        reasoningOutput: false,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-5": {
        maxInputTokens: 4e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 128e3,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      },
      "gpt-5-pro": {
        maxInputTokens: 4e5,
        imageInputs: true,
        audioInputs: false,
        pdfInputs: true,
        videoInputs: false,
        maxOutputTokens: 272e3,
        reasoningOutput: true,
        imageOutputs: false,
        audioOutputs: false,
        videoOutputs: false,
        toolCalling: true,
        structuredOutput: true,
        imageUrlInputs: true,
        pdfToolMessage: true,
        imageToolMessage: true,
        toolChoice: true
      }
    };
    profiles_default = PROFILES;
  }
});

// node_modules/@langchain/openai/dist/chat_models/base.js
var BaseChatOpenAI;
var init_base16 = __esm({
  "node_modules/@langchain/openai/dist/chat_models/base.js"() {
    init_client3();
    init_tools4();
    init_misc();
    init_azure2();
    init_output();
    init_profiles();
    init_openai2();
    init_types5();
    init_json_schema2();
    init_env();
    init_chat_models();
    init_base8();
    init_runnables();
    init_output_parsers();
    init_openai_tools();
    BaseChatOpenAI = class extends BaseChatModel {
      temperature;
      topP;
      frequencyPenalty;
      presencePenalty;
      n;
      logitBias;
      model = "gpt-3.5-turbo";
      modelKwargs;
      stop;
      stopSequences;
      user;
      timeout;
      streaming = false;
      streamUsage = true;
      maxTokens;
      logprobs;
      topLogprobs;
      apiKey;
      organization;
      __includeRawResponse;
      /** @internal */
      client;
      /** @internal */
      clientConfig;
      /**
      * Whether the model supports the `strict` argument when passing in tools.
      * If `undefined` the `strict` argument will not be passed to OpenAI.
      */
      supportsStrictToolCalling;
      audio;
      modalities;
      reasoning;
      /**
      * Must be set to `true` in tenancies with Zero Data Retention. Setting to `true` will disable
      * output storage in the Responses API, but this DOES NOT enable Zero Data Retention in your
      * OpenAI organization or project. This must be configured directly with OpenAI.
      *
      * See:
      * https://platform.openai.com/docs/guides/your-data
      * https://platform.openai.com/docs/api-reference/responses/create#responses-create-store
      *
      * @default false
      */
      zdrEnabled;
      /**
      * Service tier to use for this request. Can be "auto", "default", or "flex" or "priority".
      * Specifies the service tier for prioritization and latency optimization.
      */
      service_tier;
      /**
      * Used by OpenAI to cache responses for similar requests to optimize your cache
      * hit rates.
      * [Learn more](https://platform.openai.com/docs/guides/prompt-caching).
      */
      promptCacheKey;
      /**
      * Used by OpenAI to set cache retention time
      */
      promptCacheRetention;
      /**
      * The verbosity of the model's response.
      */
      verbosity;
      defaultOptions;
      _llmType() {
        return "openai";
      }
      static lc_name() {
        return "ChatOpenAI";
      }
      get callKeys() {
        return [
          ...super.callKeys,
          "options",
          "function_call",
          "functions",
          "tools",
          "tool_choice",
          "promptIndex",
          "response_format",
          "seed",
          "reasoning",
          "reasoning_effort",
          "service_tier"
        ];
      }
      lc_serializable = true;
      get lc_secrets() {
        return {
          apiKey: "OPENAI_API_KEY",
          organization: "OPENAI_ORGANIZATION"
        };
      }
      get lc_aliases() {
        return {
          apiKey: "openai_api_key",
          modelName: "model"
        };
      }
      get lc_serializable_keys() {
        return [
          "configuration",
          "logprobs",
          "topLogprobs",
          "prefixMessages",
          "supportsStrictToolCalling",
          "modalities",
          "audio",
          "temperature",
          "maxTokens",
          "topP",
          "frequencyPenalty",
          "presencePenalty",
          "n",
          "logitBias",
          "user",
          "streaming",
          "streamUsage",
          "model",
          "modelName",
          "modelKwargs",
          "stop",
          "stopSequences",
          "timeout",
          "apiKey",
          "cache",
          "maxConcurrency",
          "maxRetries",
          "verbose",
          "callbacks",
          "tags",
          "metadata",
          "disableStreaming",
          "zdrEnabled",
          "reasoning",
          "promptCacheKey",
          "promptCacheRetention",
          "verbosity"
        ];
      }
      getLsParams(options) {
        const params = this.invocationParams(options);
        return {
          ls_provider: "openai",
          ls_model_name: this.model,
          ls_model_type: "chat",
          ls_temperature: params.temperature ?? void 0,
          ls_max_tokens: params.max_tokens ?? void 0,
          ls_stop: options.stop
        };
      }
      /** @ignore */
      _identifyingParams() {
        return {
          model_name: this.model,
          ...this.invocationParams(),
          ...this.clientConfig
        };
      }
      /**
      * Get the identifying parameters for the model
      */
      identifyingParams() {
        return this._identifyingParams();
      }
      constructor(fields) {
        super(fields ?? {});
        const configApiKey = typeof fields?.configuration?.apiKey === "string" || typeof fields?.configuration?.apiKey === "function" ? fields?.configuration?.apiKey : void 0;
        this.apiKey = fields?.apiKey ?? configApiKey ?? getEnvironmentVariable("OPENAI_API_KEY");
        this.organization = fields?.configuration?.organization ?? getEnvironmentVariable("OPENAI_ORGANIZATION");
        this.model = fields?.model ?? fields?.modelName ?? this.model;
        this.modelKwargs = fields?.modelKwargs ?? {};
        this.timeout = fields?.timeout;
        this.temperature = fields?.temperature ?? this.temperature;
        this.topP = fields?.topP ?? this.topP;
        this.frequencyPenalty = fields?.frequencyPenalty ?? this.frequencyPenalty;
        this.presencePenalty = fields?.presencePenalty ?? this.presencePenalty;
        this.logprobs = fields?.logprobs;
        this.topLogprobs = fields?.topLogprobs;
        this.n = fields?.n ?? this.n;
        this.logitBias = fields?.logitBias;
        this.stop = fields?.stopSequences ?? fields?.stop;
        this.stopSequences = this.stop;
        this.user = fields?.user;
        this.__includeRawResponse = fields?.__includeRawResponse;
        this.audio = fields?.audio;
        this.modalities = fields?.modalities;
        this.reasoning = fields?.reasoning;
        this.maxTokens = fields?.maxCompletionTokens ?? fields?.maxTokens;
        this.promptCacheKey = fields?.promptCacheKey ?? this.promptCacheKey;
        this.promptCacheRetention = fields?.promptCacheRetention ?? this.promptCacheRetention;
        this.verbosity = fields?.verbosity ?? this.verbosity;
        this.disableStreaming = fields?.disableStreaming === true;
        this.streaming = fields?.streaming === true;
        if (this.disableStreaming) this.streaming = false;
        if (fields?.streaming === false) this.disableStreaming = true;
        this.streamUsage = fields?.streamUsage ?? this.streamUsage;
        if (this.disableStreaming) this.streamUsage = false;
        this.clientConfig = {
          apiKey: this.apiKey,
          organization: this.organization,
          dangerouslyAllowBrowser: true,
          ...fields?.configuration
        };
        if (fields?.supportsStrictToolCalling !== void 0) this.supportsStrictToolCalling = fields.supportsStrictToolCalling;
        if (fields?.service_tier !== void 0) this.service_tier = fields.service_tier;
        this.zdrEnabled = fields?.zdrEnabled ?? false;
      }
      /**
      * Returns backwards compatible reasoning parameters from constructor params and call options
      * @internal
      */
      _getReasoningParams(options) {
        if (!isReasoningModel(this.model)) return;
        let reasoning;
        if (this.reasoning !== void 0) reasoning = {
          ...reasoning,
          ...this.reasoning
        };
        if (options?.reasoning !== void 0) reasoning = {
          ...reasoning,
          ...options.reasoning
        };
        if (options?.reasoningEffort !== void 0 && reasoning?.effort === void 0) reasoning = {
          ...reasoning,
          effort: options.reasoningEffort
        };
        return reasoning;
      }
      /**
      * Returns an openai compatible response format from a set of options
      * @internal
      */
      _getResponseFormat(resFormat) {
        if (resFormat && resFormat.type === "json_schema" && resFormat.json_schema.schema && isInteropZodSchema(resFormat.json_schema.schema)) return interopZodResponseFormat(resFormat.json_schema.schema, resFormat.json_schema.name, { description: resFormat.json_schema.description });
        return resFormat;
      }
      _combineCallOptions(additionalOptions) {
        return {
          ...this.defaultOptions,
          ...additionalOptions ?? {}
        };
      }
      /** @internal */
      _getClientOptions(options) {
        if (!this.client) {
          const openAIEndpointConfig = { baseURL: this.clientConfig.baseURL };
          const endpoint = getEndpoint(openAIEndpointConfig);
          const params = {
            ...this.clientConfig,
            baseURL: endpoint,
            timeout: this.timeout,
            maxRetries: 0
          };
          if (!params.baseURL) delete params.baseURL;
          params.defaultHeaders = getHeadersWithUserAgent(params.defaultHeaders);
          this.client = new OpenAI(params);
        }
        const requestOptions = {
          ...this.clientConfig,
          ...options
        };
        return requestOptions;
      }
      _convertChatOpenAIToolToCompletionsTool(tool2, fields) {
        if (isCustomTool(tool2)) return convertResponsesCustomTool(tool2.metadata.customTool);
        if (isOpenAITool(tool2)) {
          if (fields?.strict !== void 0) return {
            ...tool2,
            function: {
              ...tool2.function,
              strict: fields.strict
            }
          };
          return tool2;
        }
        return _convertToOpenAITool(tool2, fields);
      }
      bindTools(tools2, kwargs) {
        let strict;
        if (kwargs?.strict !== void 0) strict = kwargs.strict;
        else if (this.supportsStrictToolCalling !== void 0) strict = this.supportsStrictToolCalling;
        return this.withConfig({
          tools: tools2.map((tool2) => {
            if (isBuiltInTool(tool2) || isCustomTool(tool2)) return tool2;
            if (hasProviderToolDefinition(tool2)) return tool2.extras.providerToolDefinition;
            return this._convertChatOpenAIToolToCompletionsTool(tool2, { strict });
          }),
          ...kwargs
        });
      }
      async stream(input, options) {
        return super.stream(input, this._combineCallOptions(options));
      }
      async invoke(input, options) {
        return super.invoke(input, this._combineCallOptions(options));
      }
      /** @ignore */
      _combineLLMOutput(...llmOutputs) {
        return llmOutputs.reduce((acc, llmOutput) => {
          if (llmOutput && llmOutput.tokenUsage) {
            acc.tokenUsage.completionTokens += llmOutput.tokenUsage.completionTokens ?? 0;
            acc.tokenUsage.promptTokens += llmOutput.tokenUsage.promptTokens ?? 0;
            acc.tokenUsage.totalTokens += llmOutput.tokenUsage.totalTokens ?? 0;
          }
          return acc;
        }, { tokenUsage: {
          completionTokens: 0,
          promptTokens: 0,
          totalTokens: 0
        } });
      }
      async getNumTokensFromMessages(messages) {
        let totalCount = 0;
        let tokensPerMessage = 0;
        let tokensPerName = 0;
        if (this.model === "gpt-3.5-turbo-0301") {
          tokensPerMessage = 4;
          tokensPerName = -1;
        } else {
          tokensPerMessage = 3;
          tokensPerName = 1;
        }
        const countPerMessage = await Promise.all(messages.map(async (message) => {
          const [textCount, roleCount] = await Promise.all([this.getNumTokens(message.content), this.getNumTokens(messageToOpenAIRole(message))]);
          const nameCount = message.name !== void 0 ? tokensPerName + await this.getNumTokens(message.name) : 0;
          let count = textCount + tokensPerMessage + roleCount + nameCount;
          const openAIMessage = message;
          if (openAIMessage._getType() === "function") count -= 2;
          if (openAIMessage.additional_kwargs?.function_call) count += 3;
          if (openAIMessage?.additional_kwargs.function_call?.name) count += await this.getNumTokens(openAIMessage.additional_kwargs.function_call?.name);
          if (openAIMessage.additional_kwargs.function_call?.arguments) try {
            count += await this.getNumTokens(JSON.stringify(JSON.parse(openAIMessage.additional_kwargs.function_call?.arguments)));
          } catch (error40) {
            console.error("Error parsing function arguments", error40, JSON.stringify(openAIMessage.additional_kwargs.function_call));
            count += await this.getNumTokens(openAIMessage.additional_kwargs.function_call?.arguments);
          }
          totalCount += count;
          return count;
        }));
        totalCount += 3;
        return {
          totalCount,
          countPerMessage
        };
      }
      /** @internal */
      async _getNumTokensFromGenerations(generations) {
        const generationUsages = await Promise.all(generations.map(async (generation) => {
          if (generation.message.additional_kwargs?.function_call) return (await this.getNumTokensFromMessages([generation.message])).countPerMessage[0];
          else return await this.getNumTokens(generation.message.content);
        }));
        return generationUsages.reduce((a, b) => a + b, 0);
      }
      /** @internal */
      async _getEstimatedTokenCountFromPrompt(messages, functions, function_call) {
        let tokens = (await this.getNumTokensFromMessages(messages)).totalCount;
        if (functions && function_call !== "auto") {
          const promptDefinitions = formatFunctionDefinitions(functions);
          tokens += await this.getNumTokens(promptDefinitions);
          tokens += 9;
        }
        if (functions && messages.find((m) => m._getType() === "system")) tokens -= 4;
        if (function_call === "none") tokens += 1;
        else if (typeof function_call === "object") tokens += await this.getNumTokens(function_call.name) + 4;
        return tokens;
      }
      /**
      * Moderate content using OpenAI's Moderation API.
      *
      * This method checks whether content violates OpenAI's content policy by
      * analyzing text for categories such as hate, harassment, self-harm,
      * sexual content, violence, and more.
      *
      * @param input - The text or array of texts to moderate
      * @param params - Optional parameters for the moderation request
      * @param params.model - The moderation model to use. Defaults to "omni-moderation-latest".
      * @param params.options - Additional options to pass to the underlying request
      * @returns A promise that resolves to the moderation response containing results for each input
      *
      * @example
      * ```typescript
      * const model = new ChatOpenAI({ model: "gpt-4o-mini" });
      *
      * // Moderate a single text
      * const result = await model.moderateContent("This is a test message");
      * console.log(result.results[0].flagged); // false
      * console.log(result.results[0].categories); // { hate: false, harassment: false, ... }
      *
      * // Moderate multiple texts
      * const results = await model.moderateContent([
      *   "Hello, how are you?",
      *   "This is inappropriate content"
      * ]);
      * results.results.forEach((result, index) => {
      *   console.log(`Text ${index + 1} flagged:`, result.flagged);
      * });
      *
      * // Use a specific moderation model
      * const stableResult = await model.moderateContent(
      *   "Test content",
      *   { model: "omni-moderation-latest" }
      * );
      * ```
      */
      async moderateContent(input, params) {
        const clientOptions = this._getClientOptions(params?.options);
        const moderationModel = params?.model ?? "omni-moderation-latest";
        const moderationRequest = {
          input,
          model: moderationModel
        };
        return this.caller.call(async () => {
          try {
            const response = await this.client.moderations.create(moderationRequest, clientOptions);
            return response;
          } catch (e) {
            const error40 = wrapOpenAIClientError(e);
            throw error40;
          }
        });
      }
      /**
      * Return profiling information for the model.
      *
      * Provides information about the model's capabilities and constraints,
      * including token limits, multimodal support, and advanced features like
      * tool calling and structured output.
      *
      * @returns {ModelProfile} An object describing the model's capabilities and constraints
      *
      * @example
      * ```typescript
      * const model = new ChatOpenAI({ model: "gpt-4o" });
      * const profile = model.profile;
      * console.log(profile.maxInputTokens); // 128000
      * console.log(profile.imageInputs); // true
      * ```
      */
      get profile() {
        return profiles_default[this.model] ?? {};
      }
      /** @internal */
      _getStructuredOutputMethod(config2) {
        const ensuredConfig = { ...config2 };
        if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
          if (ensuredConfig?.method === void 0) return "jsonSchema";
        } else if (ensuredConfig.method === "jsonSchema") console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
        return ensuredConfig.method;
      }
      /**
      * Add structured output to the model.
      *
      * The OpenAI model family supports the following structured output methods:
      * - `jsonSchema`: Use the `response_format` field in the response to return a JSON schema. Only supported with the `gpt-4o-mini`,
      *   `gpt-4o-mini-2024-07-18`, and `gpt-4o-2024-08-06` model snapshots and later.
      * - `functionCalling`: Function calling is useful when you are building an application that bridges the models and functionality
      *   of your application.
      * - `jsonMode`: JSON mode is a more basic version of the Structured Outputs feature. While JSON mode ensures that model
      *   output is valid JSON, Structured Outputs reliably matches the model's output to the schema you specify.
      *   We recommend you use `functionCalling` or `jsonSchema` if it is supported for your use case.
      *
      * The default method is `functionCalling`.
      *
      * @see https://platform.openai.com/docs/guides/structured-outputs
      * @param outputSchema - The schema to use for structured output.
      * @param config - The structured output method options.
      * @returns The model with structured output.
      */
      withStructuredOutput(outputSchema, config2) {
        let llm;
        let outputParser;
        const { schema, name, includeRaw } = {
          ...config2,
          schema: outputSchema
        };
        if (config2?.strict !== void 0 && config2.method === "jsonMode") throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
        const method = getStructuredOutputMethod(this.model, config2?.method);
        if (method === "jsonMode") {
          if (isInteropZodSchema(schema)) outputParser = StructuredOutputParser.fromZodSchema(schema);
          else outputParser = new JsonOutputParser();
          const asJsonSchema = toJsonSchema(schema);
          llm = this.withConfig({
            outputVersion: "v0",
            response_format: { type: "json_object" },
            ls_structured_output_format: {
              kwargs: { method: "json_mode" },
              schema: {
                title: name ?? "extract",
                ...asJsonSchema
              }
            }
          });
        } else if (method === "jsonSchema") {
          const openaiJsonSchemaParams = {
            name: name ?? "extract",
            description: getSchemaDescription(schema),
            schema,
            strict: config2?.strict
          };
          const asJsonSchema = toJsonSchema(openaiJsonSchemaParams.schema);
          llm = this.withConfig({
            outputVersion: "v0",
            response_format: {
              type: "json_schema",
              json_schema: openaiJsonSchemaParams
            },
            ls_structured_output_format: {
              kwargs: { method: "json_schema" },
              schema: {
                title: openaiJsonSchemaParams.name,
                description: openaiJsonSchemaParams.description,
                ...asJsonSchema
              }
            }
          });
          if (isInteropZodSchema(schema)) {
            const altParser = StructuredOutputParser.fromZodSchema(schema);
            outputParser = RunnableLambda.from((aiMessage) => {
              if ("parsed" in aiMessage.additional_kwargs) return aiMessage.additional_kwargs.parsed;
              return altParser;
            });
          } else outputParser = new JsonOutputParser();
        } else {
          let functionName = name ?? "extract";
          if (isInteropZodSchema(schema)) {
            const asJsonSchema = toJsonSchema(schema);
            llm = this.withConfig({
              outputVersion: "v0",
              tools: [{
                type: "function",
                function: {
                  name: functionName,
                  description: asJsonSchema.description,
                  parameters: asJsonSchema
                }
              }],
              tool_choice: {
                type: "function",
                function: { name: functionName }
              },
              ls_structured_output_format: {
                kwargs: { method: "function_calling" },
                schema: {
                  title: functionName,
                  ...asJsonSchema
                }
              },
              ...config2?.strict !== void 0 ? { strict: config2.strict } : {}
            });
            outputParser = new JsonOutputKeyToolsParser({
              returnSingle: true,
              keyName: functionName,
              zodSchema: schema
            });
          } else {
            let openAIFunctionDefinition;
            if (typeof schema.name === "string" && typeof schema.parameters === "object" && schema.parameters != null) {
              openAIFunctionDefinition = schema;
              functionName = schema.name;
            } else {
              functionName = schema.title ?? functionName;
              openAIFunctionDefinition = {
                name: functionName,
                description: schema.description ?? "",
                parameters: schema
              };
            }
            const asJsonSchema = toJsonSchema(schema);
            llm = this.withConfig({
              outputVersion: "v0",
              tools: [{
                type: "function",
                function: openAIFunctionDefinition
              }],
              tool_choice: {
                type: "function",
                function: { name: functionName }
              },
              ls_structured_output_format: {
                kwargs: { method: "function_calling" },
                schema: {
                  title: functionName,
                  ...asJsonSchema
                }
              },
              ...config2?.strict !== void 0 ? { strict: config2.strict } : {}
            });
            outputParser = new JsonOutputKeyToolsParser({
              returnSingle: true,
              keyName: functionName
            });
          }
        }
        if (!includeRaw) return llm.pipe(outputParser);
        const parserAssign = RunnablePassthrough.assign({ parsed: (input, config$1) => outputParser.invoke(input.raw, config$1) });
        const parserNone = RunnablePassthrough.assign({ parsed: () => null });
        const parsedWithFallback = parserAssign.withFallbacks({ fallbacks: [parserNone] });
        return RunnableSequence.from([{ raw: llm }, parsedWithFallback]);
      }
    };
  }
});

// node_modules/@langchain/openai/dist/converters/completions.js
var completionsApiContentBlockConverter, convertCompletionsMessageToBaseMessage, convertCompletionsDeltaToBaseMessageChunk, convertStandardContentBlockToCompletionsContentPart, convertStandardContentMessageToCompletionsMessage, convertMessagesToCompletionsMessageParams;
var init_completions4 = __esm({
  "node_modules/@langchain/openai/dist/converters/completions.js"() {
    init_misc();
    init_output();
    init_messages2();
    init_openai_tools();
    completionsApiContentBlockConverter = {
      providerName: "ChatOpenAI",
      fromStandardTextBlock(block) {
        return {
          type: "text",
          text: block.text
        };
      },
      fromStandardImageBlock(block) {
        if (block.source_type === "url") return {
          type: "image_url",
          image_url: {
            url: block.url,
            ...block.metadata?.detail ? { detail: block.metadata.detail } : {}
          }
        };
        if (block.source_type === "base64") {
          const url2 = `data:${block.mime_type ?? ""};base64,${block.data}`;
          return {
            type: "image_url",
            image_url: {
              url: url2,
              ...block.metadata?.detail ? { detail: block.metadata.detail } : {}
            }
          };
        }
        throw new Error(`Image content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`);
      },
      fromStandardAudioBlock(block) {
        if (block.source_type === "url") {
          const data = parseBase64DataUrl({ dataUrl: block.url });
          if (!data) throw new Error(`URL audio blocks with source_type ${block.source_type} must be formatted as a data URL for ChatOpenAI`);
          const rawMimeType = data.mime_type || block.mime_type || "";
          let mimeType;
          try {
            mimeType = parseMimeType(rawMimeType);
          } catch {
            throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
          }
          if (mimeType.type !== "audio" || mimeType.subtype !== "wav" && mimeType.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
          return {
            type: "input_audio",
            input_audio: {
              format: mimeType.subtype,
              data: data.data
            }
          };
        }
        if (block.source_type === "base64") {
          let mimeType;
          try {
            mimeType = parseMimeType(block.mime_type ?? "");
          } catch {
            throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
          }
          if (mimeType.type !== "audio" || mimeType.subtype !== "wav" && mimeType.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
          return {
            type: "input_audio",
            input_audio: {
              format: mimeType.subtype,
              data: block.data
            }
          };
        }
        throw new Error(`Audio content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`);
      },
      fromStandardFileBlock(block) {
        if (block.source_type === "url") {
          const data = parseBase64DataUrl({ dataUrl: block.url });
          const filename = getRequiredFilenameFromMetadata(block);
          if (!data) throw new Error(`URL file blocks with source_type ${block.source_type} must be formatted as a data URL for ChatOpenAI`);
          return {
            type: "file",
            file: {
              file_data: block.url,
              ...block.metadata?.filename || block.metadata?.name ? { filename } : {}
            }
          };
        }
        if (block.source_type === "base64") {
          const filename = getRequiredFilenameFromMetadata(block);
          return {
            type: "file",
            file: {
              file_data: `data:${block.mime_type ?? ""};base64,${block.data}`,
              ...block.metadata?.filename || block.metadata?.name || block.metadata?.title ? { filename } : {}
            }
          };
        }
        if (block.source_type === "id") return {
          type: "file",
          file: { file_id: block.id }
        };
        throw new Error(`File content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`);
      }
    };
    convertCompletionsMessageToBaseMessage = ({ message, rawResponse, includeRawResponse }) => {
      const rawToolCalls = message.tool_calls;
      switch (message.role) {
        case "assistant": {
          const toolCalls = [];
          const invalidToolCalls = [];
          for (const rawToolCall of rawToolCalls ?? []) try {
            toolCalls.push(parseToolCall(rawToolCall, { returnId: true }));
          } catch (e) {
            invalidToolCalls.push(makeInvalidToolCall(rawToolCall, e.message));
          }
          const additional_kwargs = {
            function_call: message.function_call,
            tool_calls: rawToolCalls
          };
          if (includeRawResponse !== void 0) additional_kwargs.__raw_response = rawResponse;
          const response_metadata = {
            model_provider: "openai",
            model_name: rawResponse.model,
            ...rawResponse.system_fingerprint ? {
              usage: { ...rawResponse.usage },
              system_fingerprint: rawResponse.system_fingerprint
            } : {}
          };
          if (message.audio) additional_kwargs.audio = message.audio;
          const content = handleMultiModalOutput(message.content || "", rawResponse.choices?.[0]?.message);
          return new AIMessage({
            content,
            tool_calls: toolCalls,
            invalid_tool_calls: invalidToolCalls,
            additional_kwargs,
            response_metadata,
            id: rawResponse.id
          });
        }
        default:
          return new ChatMessage(message.content || "", message.role ?? "unknown");
      }
    };
    convertCompletionsDeltaToBaseMessageChunk = ({ delta, rawResponse, includeRawResponse, defaultRole }) => {
      const role = delta.role ?? defaultRole;
      const content = delta.content ?? "";
      let additional_kwargs;
      if (delta.function_call) additional_kwargs = { function_call: delta.function_call };
      else if (delta.tool_calls) additional_kwargs = { tool_calls: delta.tool_calls };
      else additional_kwargs = {};
      if (includeRawResponse) additional_kwargs.__raw_response = rawResponse;
      if (delta.audio) additional_kwargs.audio = {
        ...delta.audio,
        index: rawResponse.choices[0].index
      };
      const response_metadata = {
        model_provider: "openai",
        usage: { ...rawResponse.usage }
      };
      if (role === "user") return new HumanMessageChunk({
        content,
        response_metadata
      });
      else if (role === "assistant") {
        const toolCallChunks = [];
        if (Array.isArray(delta.tool_calls)) for (const rawToolCall of delta.tool_calls) toolCallChunks.push({
          name: rawToolCall.function?.name,
          args: rawToolCall.function?.arguments,
          id: rawToolCall.id,
          index: rawToolCall.index,
          type: "tool_call_chunk"
        });
        return new AIMessageChunk({
          content,
          tool_call_chunks: toolCallChunks,
          additional_kwargs,
          id: rawResponse.id,
          response_metadata
        });
      } else if (role === "system") return new SystemMessageChunk({
        content,
        response_metadata
      });
      else if (role === "developer") return new SystemMessageChunk({
        content,
        response_metadata,
        additional_kwargs: { __openai_role__: "developer" }
      });
      else if (role === "function") return new FunctionMessageChunk({
        content,
        additional_kwargs,
        name: delta.name,
        response_metadata
      });
      else if (role === "tool") return new ToolMessageChunk({
        content,
        additional_kwargs,
        tool_call_id: delta.tool_call_id,
        response_metadata
      });
      else return new ChatMessageChunk({
        content,
        role,
        response_metadata
      });
    };
    convertStandardContentBlockToCompletionsContentPart = (block) => {
      if (block.type === "image") {
        if (block.url) return {
          type: "image_url",
          image_url: { url: block.url }
        };
        else if (block.data) return {
          type: "image_url",
          image_url: { url: `data:${block.mimeType};base64,${block.data}` }
        };
      }
      if (block.type === "audio") {
        if (block.data) {
          const format2 = iife2(() => {
            const [, format$1] = block.mimeType.split("/");
            if (format$1 === "wav" || format$1 === "mp3") return format$1;
            return "wav";
          });
          return {
            type: "input_audio",
            input_audio: {
              data: block.data.toString(),
              format: format2
            }
          };
        }
      }
      if (block.type === "file") {
        if (block.data) {
          const filename = getRequiredFilenameFromMetadata(block);
          return {
            type: "file",
            file: {
              file_data: `data:${block.mimeType};base64,${block.data}`,
              filename
            }
          };
        }
        if (block.fileId) return {
          type: "file",
          file: { file_id: block.fileId }
        };
      }
      return void 0;
    };
    convertStandardContentMessageToCompletionsMessage = ({ message, model }) => {
      let role = messageToOpenAIRole(message);
      if (role === "system" && isReasoningModel(model)) role = "developer";
      if (role === "developer") return {
        role: "developer",
        content: message.contentBlocks.filter((block) => block.type === "text")
      };
      else if (role === "system") return {
        role: "system",
        content: message.contentBlocks.filter((block) => block.type === "text")
      };
      else if (role === "assistant") return {
        role: "assistant",
        content: message.contentBlocks.filter((block) => block.type === "text")
      };
      else if (role === "tool" && ToolMessage.isInstance(message)) return {
        role: "tool",
        tool_call_id: message.tool_call_id,
        content: message.contentBlocks.filter((block) => block.type === "text")
      };
      else if (role === "function") return {
        role: "function",
        name: message.name ?? "",
        content: message.contentBlocks.filter((block) => block.type === "text").join("")
      };
      function* iterateUserContent(blocks2) {
        for (const block of blocks2) {
          if (block.type === "text") yield {
            type: "text",
            text: block.text
          };
          const data = convertStandardContentBlockToCompletionsContentPart(block);
          if (data) yield data;
        }
      }
      return {
        role: "user",
        content: Array.from(iterateUserContent(message.contentBlocks))
      };
    };
    convertMessagesToCompletionsMessageParams = ({ messages, model }) => {
      return messages.flatMap((message) => {
        if ("output_version" in message.response_metadata && message.response_metadata?.output_version === "v1") return convertStandardContentMessageToCompletionsMessage({ message });
        let role = messageToOpenAIRole(message);
        if (role === "system" && isReasoningModel(model)) role = "developer";
        const content = typeof message.content === "string" ? message.content : message.content.map((m) => {
          if (isDataContentBlock(m)) return convertToProviderContentBlock(m, completionsApiContentBlockConverter);
          return m;
        });
        const completionParam = {
          role,
          content
        };
        if (message.name != null) completionParam.name = message.name;
        if (message.additional_kwargs.function_call != null) completionParam.function_call = message.additional_kwargs.function_call;
        if (AIMessage.isInstance(message) && !!message.tool_calls?.length) completionParam.tool_calls = message.tool_calls.map(convertLangChainToolCallToOpenAI);
        else {
          if (message.additional_kwargs.tool_calls != null) completionParam.tool_calls = message.additional_kwargs.tool_calls;
          if (ToolMessage.isInstance(message) && message.tool_call_id != null) completionParam.tool_call_id = message.tool_call_id;
        }
        if (message.additional_kwargs.audio && typeof message.additional_kwargs.audio === "object" && "id" in message.additional_kwargs.audio) {
          const audioMessage = {
            role: "assistant",
            audio: { id: message.additional_kwargs.audio.id }
          };
          return [completionParam, audioMessage];
        }
        return completionParam;
      });
    };
  }
});

// node_modules/@langchain/openai/dist/chat_models/completions.js
var ChatOpenAICompletions;
var init_completions5 = __esm({
  "node_modules/@langchain/openai/dist/chat_models/completions.js"() {
    init_client3();
    init_tools4();
    init_misc();
    init_base16();
    init_completions4();
    init_messages2();
    init_outputs();
    ChatOpenAICompletions = class extends BaseChatOpenAI {
      /** @internal */
      invocationParams(options, extra) {
        let strict;
        if (options?.strict !== void 0) strict = options.strict;
        else if (this.supportsStrictToolCalling !== void 0) strict = this.supportsStrictToolCalling;
        let streamOptionsConfig = {};
        if (options?.stream_options !== void 0) streamOptionsConfig = { stream_options: options.stream_options };
        else if (this.streamUsage && (this.streaming || extra?.streaming)) streamOptionsConfig = { stream_options: { include_usage: true } };
        const params = {
          model: this.model,
          temperature: this.temperature,
          top_p: this.topP,
          frequency_penalty: this.frequencyPenalty,
          presence_penalty: this.presencePenalty,
          logprobs: this.logprobs,
          top_logprobs: this.topLogprobs,
          n: this.n,
          logit_bias: this.logitBias,
          stop: options?.stop ?? this.stopSequences,
          user: this.user,
          stream: this.streaming,
          functions: options?.functions,
          function_call: options?.function_call,
          tools: options?.tools?.length ? options.tools.map((tool2) => this._convertChatOpenAIToolToCompletionsTool(tool2, { strict })) : void 0,
          tool_choice: formatToOpenAIToolChoice(options?.tool_choice),
          response_format: this._getResponseFormat(options?.response_format),
          seed: options?.seed,
          ...streamOptionsConfig,
          parallel_tool_calls: options?.parallel_tool_calls,
          ...this.audio || options?.audio ? { audio: this.audio || options?.audio } : {},
          ...this.modalities || options?.modalities ? { modalities: this.modalities || options?.modalities } : {},
          ...this.modelKwargs,
          prompt_cache_key: options?.promptCacheKey ?? this.promptCacheKey,
          prompt_cache_retention: options?.promptCacheRetention ?? this.promptCacheRetention,
          verbosity: options?.verbosity ?? this.verbosity
        };
        if (options?.prediction !== void 0) params.prediction = options.prediction;
        if (this.service_tier !== void 0) params.service_tier = this.service_tier;
        if (options?.service_tier !== void 0) params.service_tier = options.service_tier;
        const reasoning = this._getReasoningParams(options);
        if (reasoning !== void 0 && reasoning.effort !== void 0) params.reasoning_effort = reasoning.effort;
        if (isReasoningModel(params.model)) params.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens;
        else params.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens;
        return params;
      }
      async _generate(messages, options, runManager) {
        options.signal?.throwIfAborted();
        const usageMetadata = {};
        const params = this.invocationParams(options);
        const messagesMapped = convertMessagesToCompletionsMessageParams({
          messages,
          model: this.model
        });
        if (params.stream) {
          const stream = this._streamResponseChunks(messages, options, runManager);
          const finalChunks = {};
          for await (const chunk of stream) {
            chunk.message.response_metadata = {
              ...chunk.generationInfo,
              ...chunk.message.response_metadata
            };
            const index2 = chunk.generationInfo?.completion ?? 0;
            if (finalChunks[index2] === void 0) finalChunks[index2] = chunk;
            else finalChunks[index2] = finalChunks[index2].concat(chunk);
          }
          const generations = Object.entries(finalChunks).sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10)).map(([_, value]) => value);
          const { functions, function_call } = this.invocationParams(options);
          const promptTokenUsage = await this._getEstimatedTokenCountFromPrompt(messages, functions, function_call);
          const completionTokenUsage = await this._getNumTokensFromGenerations(generations);
          usageMetadata.input_tokens = promptTokenUsage;
          usageMetadata.output_tokens = completionTokenUsage;
          usageMetadata.total_tokens = promptTokenUsage + completionTokenUsage;
          return {
            generations,
            llmOutput: { estimatedTokenUsage: {
              promptTokens: usageMetadata.input_tokens,
              completionTokens: usageMetadata.output_tokens,
              totalTokens: usageMetadata.total_tokens
            } }
          };
        } else {
          const data = await this.completionWithRetry({
            ...params,
            stream: false,
            messages: messagesMapped
          }, {
            signal: options?.signal,
            ...options?.options
          });
          const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, prompt_tokens_details: promptTokensDetails, completion_tokens_details: completionTokensDetails } = data?.usage ?? {};
          if (completionTokens) usageMetadata.output_tokens = (usageMetadata.output_tokens ?? 0) + completionTokens;
          if (promptTokens) usageMetadata.input_tokens = (usageMetadata.input_tokens ?? 0) + promptTokens;
          if (totalTokens) usageMetadata.total_tokens = (usageMetadata.total_tokens ?? 0) + totalTokens;
          if (promptTokensDetails?.audio_tokens !== null || promptTokensDetails?.cached_tokens !== null) usageMetadata.input_token_details = {
            ...promptTokensDetails?.audio_tokens !== null && { audio: promptTokensDetails?.audio_tokens },
            ...promptTokensDetails?.cached_tokens !== null && { cache_read: promptTokensDetails?.cached_tokens }
          };
          if (completionTokensDetails?.audio_tokens !== null || completionTokensDetails?.reasoning_tokens !== null) usageMetadata.output_token_details = {
            ...completionTokensDetails?.audio_tokens !== null && { audio: completionTokensDetails?.audio_tokens },
            ...completionTokensDetails?.reasoning_tokens !== null && { reasoning: completionTokensDetails?.reasoning_tokens }
          };
          const generations = [];
          for (const part of data?.choices ?? []) {
            const text2 = part.message?.content ?? "";
            const generation = {
              text: text2,
              message: this._convertCompletionsMessageToBaseMessage(part.message ?? { role: "assistant" }, data)
            };
            generation.generationInfo = {
              ...part.finish_reason ? { finish_reason: part.finish_reason } : {},
              ...part.logprobs ? { logprobs: part.logprobs } : {}
            };
            if (isAIMessage(generation.message)) generation.message.usage_metadata = usageMetadata;
            generation.message = new AIMessage(Object.fromEntries(Object.entries(generation.message).filter(([key]) => !key.startsWith("lc_"))));
            generations.push(generation);
          }
          return {
            generations,
            llmOutput: { tokenUsage: {
              promptTokens: usageMetadata.input_tokens,
              completionTokens: usageMetadata.output_tokens,
              totalTokens: usageMetadata.total_tokens
            } }
          };
        }
      }
      async *_streamResponseChunks(messages, options, runManager) {
        const messagesMapped = convertMessagesToCompletionsMessageParams({
          messages,
          model: this.model
        });
        const params = {
          ...this.invocationParams(options, { streaming: true }),
          messages: messagesMapped,
          stream: true
        };
        let defaultRole;
        const streamIterable = await this.completionWithRetry(params, options);
        let usage;
        for await (const data of streamIterable) {
          if (options.signal?.aborted) return;
          const choice = data?.choices?.[0];
          if (data.usage) usage = data.usage;
          if (!choice) continue;
          const { delta } = choice;
          if (!delta) continue;
          const chunk = this._convertCompletionsDeltaToBaseMessageChunk(delta, data, defaultRole);
          defaultRole = delta.role ?? defaultRole;
          const newTokenIndices = {
            prompt: options.promptIndex ?? 0,
            completion: choice.index ?? 0
          };
          if (typeof chunk.content !== "string") {
            console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
            continue;
          }
          const generationInfo = { ...newTokenIndices };
          if (choice.finish_reason != null) {
            generationInfo.finish_reason = choice.finish_reason;
            generationInfo.system_fingerprint = data.system_fingerprint;
            generationInfo.model_name = data.model;
            generationInfo.service_tier = data.service_tier;
          }
          if (this.logprobs) generationInfo.logprobs = choice.logprobs;
          const generationChunk = new ChatGenerationChunk({
            message: chunk,
            text: chunk.content,
            generationInfo
          });
          yield generationChunk;
          await runManager?.handleLLMNewToken(generationChunk.text ?? "", newTokenIndices, void 0, void 0, void 0, { chunk: generationChunk });
        }
        if (usage) {
          const inputTokenDetails = {
            ...usage.prompt_tokens_details?.audio_tokens !== null && { audio: usage.prompt_tokens_details?.audio_tokens },
            ...usage.prompt_tokens_details?.cached_tokens !== null && { cache_read: usage.prompt_tokens_details?.cached_tokens }
          };
          const outputTokenDetails = {
            ...usage.completion_tokens_details?.audio_tokens !== null && { audio: usage.completion_tokens_details?.audio_tokens },
            ...usage.completion_tokens_details?.reasoning_tokens !== null && { reasoning: usage.completion_tokens_details?.reasoning_tokens }
          };
          const generationChunk = new ChatGenerationChunk({
            message: new AIMessageChunk({
              content: "",
              response_metadata: { usage: { ...usage } },
              usage_metadata: {
                input_tokens: usage.prompt_tokens,
                output_tokens: usage.completion_tokens,
                total_tokens: usage.total_tokens,
                ...Object.keys(inputTokenDetails).length > 0 && { input_token_details: inputTokenDetails },
                ...Object.keys(outputTokenDetails).length > 0 && { output_token_details: outputTokenDetails }
              }
            }),
            text: ""
          });
          yield generationChunk;
        }
        if (options.signal?.aborted) throw new Error("AbortError");
      }
      async completionWithRetry(request, requestOptions) {
        const clientOptions = this._getClientOptions(requestOptions);
        const isParseableFormat = request.response_format && request.response_format.type === "json_schema";
        return this.caller.call(async () => {
          try {
            if (isParseableFormat && !request.stream) return await this.client.chat.completions.parse(request, clientOptions);
            else return await this.client.chat.completions.create(request, clientOptions);
          } catch (e) {
            const error40 = wrapOpenAIClientError(e);
            throw error40;
          }
        });
      }
      /**
      * @deprecated
      * This function was hoisted into a publicly accessible function from a
      * different export, but to maintain backwards compatibility with chat models
      * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
      * method. This will be removed in a future release
      */
      _convertCompletionsDeltaToBaseMessageChunk(delta, rawResponse, defaultRole) {
        return convertCompletionsDeltaToBaseMessageChunk({
          delta,
          rawResponse,
          includeRawResponse: this.__includeRawResponse,
          defaultRole
        });
      }
      /**
      * @deprecated
      * This function was hoisted into a publicly accessible function from a
      * different export, but to maintain backwards compatibility with chat models
      * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
      * method. This will be removed in a future release
      */
      _convertCompletionsMessageToBaseMessage(message, rawResponse) {
        return convertCompletionsMessageToBaseMessage({
          message,
          rawResponse,
          includeRawResponse: this.__includeRawResponse
        });
      }
    };
  }
});

// node_modules/@langchain/openai/dist/azure/chat_models/common.js
var init_common = __esm({
  "node_modules/@langchain/openai/dist/azure/chat_models/common.js"() {
    init_azure2();
    init_openai2();
    init_env();
  }
});

// node_modules/@langchain/openai/dist/azure/chat_models/completions.js
var init_completions6 = __esm({
  "node_modules/@langchain/openai/dist/azure/chat_models/completions.js"() {
    init_completions5();
    init_common();
  }
});

// node_modules/@langchain/openai/dist/converters/responses.js
function convertOpenAIAnnotationToLangChain(annotation) {
  if (annotation.type === "url_citation") return {
    type: "citation",
    source: "url_citation",
    url: annotation.url,
    title: annotation.title,
    startIndex: annotation.start_index,
    endIndex: annotation.end_index
  };
  if (annotation.type === "file_citation") return {
    type: "citation",
    source: "file_citation",
    title: annotation.filename,
    startIndex: annotation.index,
    file_id: annotation.file_id
  };
  if (annotation.type === "container_file_citation") return {
    type: "citation",
    source: "container_file_citation",
    title: annotation.filename,
    startIndex: annotation.start_index,
    endIndex: annotation.end_index,
    file_id: annotation.file_id,
    container_id: annotation.container_id
  };
  if (annotation.type === "file_path") return {
    type: "citation",
    source: "file_path",
    startIndex: annotation.index,
    file_id: annotation.file_id
  };
  return {
    type: "non_standard",
    value: annotation
  };
}
var _FUNCTION_CALL_IDS_MAP_KEY, convertResponsesUsageToUsageMetadata, convertResponsesMessageToAIMessage, convertReasoningSummaryToResponsesReasoningItem, convertResponsesDeltaToChatGenerationChunk, convertStandardContentMessageToResponsesInput, convertMessagesToResponsesInput;
var init_responses2 = __esm({
  "node_modules/@langchain/openai/dist/converters/responses.js"() {
    init_tools4();
    init_misc();
    init_completions4();
    init_messages2();
    init_outputs();
    init_openai_tools();
    _FUNCTION_CALL_IDS_MAP_KEY = "__openai_function_call_ids__";
    convertResponsesUsageToUsageMetadata = (usage) => {
      const inputTokenDetails = { ...usage?.input_tokens_details?.cached_tokens != null && { cache_read: usage?.input_tokens_details?.cached_tokens } };
      const outputTokenDetails = { ...usage?.output_tokens_details?.reasoning_tokens != null && { reasoning: usage?.output_tokens_details?.reasoning_tokens } };
      return {
        input_tokens: usage?.input_tokens ?? 0,
        output_tokens: usage?.output_tokens ?? 0,
        total_tokens: usage?.total_tokens ?? 0,
        input_token_details: inputTokenDetails,
        output_token_details: outputTokenDetails
      };
    };
    convertResponsesMessageToAIMessage = (response) => {
      if (response.error) {
        const error40 = new Error(response.error.message);
        error40.name = response.error.code;
        throw error40;
      }
      let messageId;
      const content = [];
      const tool_calls = [];
      const invalid_tool_calls = [];
      const response_metadata = {
        model_provider: "openai",
        model: response.model,
        created_at: response.created_at,
        id: response.id,
        incomplete_details: response.incomplete_details,
        metadata: response.metadata,
        object: response.object,
        status: response.status,
        user: response.user,
        service_tier: response.service_tier,
        model_name: response.model
      };
      const additional_kwargs = {};
      for (const item of response.output) if (item.type === "message") {
        messageId = item.id;
        content.push(...item.content.flatMap((part) => {
          if (part.type === "output_text") {
            if ("parsed" in part && part.parsed != null) additional_kwargs.parsed = part.parsed;
            return {
              type: "text",
              text: part.text,
              annotations: part.annotations.map(convertOpenAIAnnotationToLangChain)
            };
          }
          if (part.type === "refusal") {
            additional_kwargs.refusal = part.refusal;
            return [];
          }
          return part;
        }));
      } else if (item.type === "function_call") {
        const fnAdapter = {
          function: {
            name: item.name,
            arguments: item.arguments
          },
          id: item.call_id
        };
        try {
          tool_calls.push(parseToolCall(fnAdapter, { returnId: true }));
        } catch (e) {
          let errMessage;
          if (typeof e === "object" && e != null && "message" in e && typeof e.message === "string") errMessage = e.message;
          invalid_tool_calls.push(makeInvalidToolCall(fnAdapter, errMessage));
        }
        additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY] ??= {};
        if (item.id) additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY][item.call_id] = item.id;
      } else if (item.type === "reasoning") {
        additional_kwargs.reasoning = item;
        const reasoningText = item.summary?.map((s) => s.text).filter(Boolean).join("");
        if (reasoningText) content.push({
          type: "reasoning",
          reasoning: reasoningText
        });
      } else if (item.type === "custom_tool_call") {
        const parsed = parseCustomToolCall(item);
        if (parsed) tool_calls.push(parsed);
        else invalid_tool_calls.push(makeInvalidToolCall(item, "Malformed custom tool call"));
      } else if (item.type === "computer_call") {
        const parsed = parseComputerCall(item);
        if (parsed) tool_calls.push(parsed);
        else invalid_tool_calls.push(makeInvalidToolCall(item, "Malformed computer call"));
      } else if (item.type === "image_generation_call") {
        if (item.result) content.push({
          type: "image",
          mimeType: "image/png",
          data: item.result,
          id: item.id,
          metadata: { status: item.status }
        });
        additional_kwargs.tool_outputs ??= [];
        additional_kwargs.tool_outputs.push(item);
      } else {
        additional_kwargs.tool_outputs ??= [];
        additional_kwargs.tool_outputs.push(item);
      }
      return new AIMessage({
        id: messageId,
        content,
        tool_calls,
        invalid_tool_calls,
        usage_metadata: convertResponsesUsageToUsageMetadata(response.usage),
        additional_kwargs,
        response_metadata
      });
    };
    convertReasoningSummaryToResponsesReasoningItem = (reasoning) => {
      const summary = (reasoning.summary.length > 1 ? reasoning.summary.reduce((acc, curr) => {
        const last = acc[acc.length - 1];
        if (last.index === curr.index) last.text += curr.text;
        else acc.push(curr);
        return acc;
      }, [{ ...reasoning.summary[0] }]) : reasoning.summary).map((s) => Object.fromEntries(Object.entries(s).filter(([k]) => k !== "index")));
      return {
        ...reasoning,
        summary
      };
    };
    convertResponsesDeltaToChatGenerationChunk = (event) => {
      const content = [];
      let generationInfo = {};
      let usage_metadata;
      const tool_call_chunks = [];
      const response_metadata = { model_provider: "openai" };
      const additional_kwargs = {};
      let id;
      if (event.type === "response.output_text.delta") content.push({
        type: "text",
        text: event.delta,
        index: event.content_index
      });
      else if (event.type === "response.output_text.annotation.added") content.push({
        type: "text",
        text: "",
        annotations: [convertOpenAIAnnotationToLangChain(event.annotation)],
        index: event.content_index
      });
      else if (event.type === "response.output_item.added" && event.item.type === "message") id = event.item.id;
      else if (event.type === "response.output_item.added" && event.item.type === "function_call") {
        tool_call_chunks.push({
          type: "tool_call_chunk",
          name: event.item.name,
          args: event.item.arguments,
          id: event.item.call_id,
          index: event.output_index
        });
        additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY] = { [event.item.call_id]: event.item.id };
      } else if (event.type === "response.output_item.done" && event.item.type === "computer_call") {
        tool_call_chunks.push({
          type: "tool_call_chunk",
          name: "computer_use",
          args: JSON.stringify({ action: event.item.action }),
          id: event.item.call_id,
          index: event.output_index
        });
        additional_kwargs.tool_outputs = [event.item];
      } else if (event.type === "response.output_item.done" && event.item.type === "image_generation_call") {
        if (event.item.result) content.push({
          type: "image",
          mimeType: "image/png",
          data: event.item.result,
          id: event.item.id,
          metadata: { status: event.item.status }
        });
        additional_kwargs.tool_outputs = [event.item];
      } else if (event.type === "response.output_item.done" && [
        "web_search_call",
        "file_search_call",
        "code_interpreter_call",
        "mcp_call",
        "mcp_list_tools",
        "mcp_approval_request",
        "custom_tool_call"
      ].includes(event.item.type)) additional_kwargs.tool_outputs = [event.item];
      else if (event.type === "response.created") {
        response_metadata.id = event.response.id;
        response_metadata.model_name = event.response.model;
        response_metadata.model = event.response.model;
      } else if (event.type === "response.completed") {
        const msg = convertResponsesMessageToAIMessage(event.response);
        usage_metadata = convertResponsesUsageToUsageMetadata(event.response.usage);
        if (event.response.text?.format?.type === "json_schema") additional_kwargs.parsed ??= JSON.parse(msg.text);
        for (const [key, value] of Object.entries(event.response)) if (key !== "id") response_metadata[key] = value;
      } else if (event.type === "response.function_call_arguments.delta" || event.type === "response.custom_tool_call_input.delta") tool_call_chunks.push({
        type: "tool_call_chunk",
        args: event.delta,
        index: event.output_index
      });
      else if (event.type === "response.web_search_call.completed" || event.type === "response.file_search_call.completed") generationInfo = { tool_outputs: {
        id: event.item_id,
        type: event.type.replace("response.", "").replace(".completed", ""),
        status: "completed"
      } };
      else if (event.type === "response.refusal.done") additional_kwargs.refusal = event.refusal;
      else if (event.type === "response.output_item.added" && "item" in event && event.item.type === "reasoning") {
        const summary = event.item.summary ? event.item.summary.map((s, index2) => ({
          ...s,
          index: index2
        })) : void 0;
        additional_kwargs.reasoning = {
          id: event.item.id,
          type: event.item.type,
          ...summary ? { summary } : {}
        };
        const reasoningText = event.item.summary?.map((s) => s.text).filter(Boolean).join("");
        if (reasoningText) content.push({
          type: "reasoning",
          reasoning: reasoningText
        });
      } else if (event.type === "response.reasoning_summary_part.added") {
        additional_kwargs.reasoning = {
          type: "reasoning",
          summary: [{
            ...event.part,
            index: event.summary_index
          }]
        };
        if (event.part.text) content.push({
          type: "reasoning",
          reasoning: event.part.text
        });
      } else if (event.type === "response.reasoning_summary_text.delta") {
        additional_kwargs.reasoning = {
          type: "reasoning",
          summary: [{
            text: event.delta,
            type: "summary_text",
            index: event.summary_index
          }]
        };
        if (event.delta) content.push({
          type: "reasoning",
          reasoning: event.delta
        });
      } else if (event.type === "response.image_generation_call.partial_image") return null;
      else return null;
      return new ChatGenerationChunk({
        text: content.map((part) => part.text).join(""),
        message: new AIMessageChunk({
          id,
          content,
          tool_call_chunks,
          usage_metadata,
          additional_kwargs,
          response_metadata
        }),
        generationInfo
      });
    };
    convertStandardContentMessageToResponsesInput = (message) => {
      const isResponsesMessage = AIMessage.isInstance(message) && message.response_metadata?.model_provider === "openai";
      function* iterateItems() {
        const messageRole = iife$1(() => {
          try {
            const role = messageToOpenAIRole(message);
            if (role === "system" || role === "developer" || role === "assistant" || role === "user") return role;
            return "assistant";
          } catch {
            return "assistant";
          }
        });
        let currentMessage = void 0;
        const functionCallIdsWithBlocks = /* @__PURE__ */ new Set();
        const serverFunctionCallIdsWithBlocks = /* @__PURE__ */ new Set();
        const pendingFunctionChunks = /* @__PURE__ */ new Map();
        const pendingServerFunctionChunks = /* @__PURE__ */ new Map();
        function* flushMessage() {
          if (!currentMessage) return;
          const content = currentMessage.content;
          if (typeof content === "string" && content.length > 0 || Array.isArray(content) && content.length > 0) yield currentMessage;
          currentMessage = void 0;
        }
        const pushMessageContent = (content) => {
          if (!currentMessage) currentMessage = {
            type: "message",
            role: messageRole,
            content: []
          };
          if (typeof currentMessage.content === "string") currentMessage.content = currentMessage.content.length > 0 ? [{
            type: "input_text",
            text: currentMessage.content
          }, ...content] : [...content];
          else currentMessage.content.push(...content);
        };
        const toJsonString = (value) => {
          if (typeof value === "string") return value;
          try {
            return JSON.stringify(value ?? {});
          } catch {
            return "{}";
          }
        };
        const resolveImageItem = (block) => {
          const detail = iife$1(() => {
            const raw = block.metadata?.detail;
            if (raw === "low" || raw === "high" || raw === "auto") return raw;
            return "auto";
          });
          if (block.fileId) return {
            type: "input_image",
            detail,
            file_id: block.fileId
          };
          if (block.url) return {
            type: "input_image",
            detail,
            image_url: block.url
          };
          if (block.data) {
            const base64Data = typeof block.data === "string" ? block.data : Buffer.from(block.data).toString("base64");
            const mimeType = block.mimeType ?? "image/png";
            return {
              type: "input_image",
              detail,
              image_url: `data:${mimeType};base64,${base64Data}`
            };
          }
          return void 0;
        };
        const resolveFileItem = (block) => {
          if (block.fileId) {
            const filename = getFilenameFromMetadata(block);
            return {
              type: "input_file",
              file_id: block.fileId,
              ...filename ? { filename } : {}
            };
          }
          if (block.url) {
            const filename = getFilenameFromMetadata(block);
            return {
              ...filename ? { filename } : {},
              type: "input_file",
              file_url: block.url
            };
          }
          if (block.data) {
            const filename = getRequiredFilenameFromMetadata(block);
            const encoded = typeof block.data === "string" ? block.data : Buffer.from(block.data).toString("base64");
            const mimeType = block.mimeType ?? "application/octet-stream";
            return {
              type: "input_file",
              file_data: `data:${mimeType};base64,${encoded}`,
              ...filename ? { filename } : {}
            };
          }
          return void 0;
        };
        const convertReasoningBlock = (block) => {
          const summaryEntries = iife$1(() => {
            if (Array.isArray(block.summary)) {
              const candidate = block.summary;
              const mapped = candidate?.map((item) => item?.text).filter((text2) => typeof text2 === "string") ?? [];
              if (mapped.length > 0) return mapped;
            }
            return block.reasoning ? [block.reasoning] : [];
          });
          const summary = summaryEntries.length > 0 ? summaryEntries.map((text2) => ({
            type: "summary_text",
            text: text2
          })) : [{
            type: "summary_text",
            text: ""
          }];
          const reasoningItem = {
            type: "reasoning",
            id: block.id ?? "",
            summary
          };
          if (block.reasoning) reasoningItem.content = [{
            type: "reasoning_text",
            text: block.reasoning
          }];
          return reasoningItem;
        };
        const convertFunctionCall = (block) => ({
          type: "function_call",
          name: block.name ?? "",
          call_id: block.id ?? "",
          arguments: toJsonString(block.args)
        });
        const convertFunctionCallOutput = (block) => {
          const output = toJsonString(block.output);
          const status = block.status === "success" ? "completed" : block.status === "error" ? "incomplete" : void 0;
          return {
            type: "function_call_output",
            call_id: block.toolCallId ?? "",
            output,
            ...status ? { status } : {}
          };
        };
        for (const block of message.contentBlocks) if (block.type === "text") pushMessageContent([{
          type: "input_text",
          text: block.text
        }]);
        else if (block.type === "invalid_tool_call") {
        } else if (block.type === "reasoning") {
          yield* flushMessage();
          yield convertReasoningBlock(block);
        } else if (block.type === "tool_call") {
          yield* flushMessage();
          const id = block.id ?? "";
          if (id) {
            functionCallIdsWithBlocks.add(id);
            pendingFunctionChunks.delete(id);
          }
          yield convertFunctionCall(block);
        } else if (block.type === "tool_call_chunk") {
          if (block.id) {
            const existing = pendingFunctionChunks.get(block.id) ?? {
              name: block.name,
              args: []
            };
            if (block.name) existing.name = block.name;
            if (block.args) existing.args.push(block.args);
            pendingFunctionChunks.set(block.id, existing);
          }
        } else if (block.type === "server_tool_call") {
          yield* flushMessage();
          const id = block.id ?? "";
          if (id) {
            serverFunctionCallIdsWithBlocks.add(id);
            pendingServerFunctionChunks.delete(id);
          }
          yield convertFunctionCall(block);
        } else if (block.type === "server_tool_call_chunk") {
          if (block.id) {
            const existing = pendingServerFunctionChunks.get(block.id) ?? {
              name: block.name,
              args: []
            };
            if (block.name) existing.name = block.name;
            if (block.args) existing.args.push(block.args);
            pendingServerFunctionChunks.set(block.id, existing);
          }
        } else if (block.type === "server_tool_call_result") {
          yield* flushMessage();
          yield convertFunctionCallOutput(block);
        } else if (block.type === "audio") {
        } else if (block.type === "file") {
          const fileItem = resolveFileItem(block);
          if (fileItem) pushMessageContent([fileItem]);
        } else if (block.type === "image") {
          const imageItem = resolveImageItem(block);
          if (imageItem) pushMessageContent([imageItem]);
        } else if (block.type === "video") {
          const videoItem = resolveFileItem(block);
          if (videoItem) pushMessageContent([videoItem]);
        } else if (block.type === "text-plain") {
          if (block.text) pushMessageContent([{
            type: "input_text",
            text: block.text
          }]);
        } else if (block.type === "non_standard" && isResponsesMessage) {
          yield* flushMessage();
          yield block.value;
        }
        yield* flushMessage();
        for (const [id, chunk] of pendingFunctionChunks) {
          if (!id || functionCallIdsWithBlocks.has(id)) continue;
          const args = chunk.args.join("");
          if (!chunk.name && !args) continue;
          yield {
            type: "function_call",
            call_id: id,
            name: chunk.name ?? "",
            arguments: args
          };
        }
        for (const [id, chunk] of pendingServerFunctionChunks) {
          if (!id || serverFunctionCallIdsWithBlocks.has(id)) continue;
          const args = chunk.args.join("");
          if (!chunk.name && !args) continue;
          yield {
            type: "function_call",
            call_id: id,
            name: chunk.name ?? "",
            arguments: args
          };
        }
      }
      return Array.from(iterateItems());
    };
    convertMessagesToResponsesInput = ({ messages, zdrEnabled, model }) => {
      return messages.flatMap((lcMsg) => {
        const responseMetadata = lcMsg.response_metadata;
        if (responseMetadata?.output_version === "v1") return convertStandardContentMessageToResponsesInput(lcMsg);
        const additional_kwargs = lcMsg.additional_kwargs;
        let role = messageToOpenAIRole(lcMsg);
        if (role === "system" && isReasoningModel(model)) role = "developer";
        if (role === "function") throw new Error("Function messages are not supported in Responses API");
        if (role === "tool") {
          const toolMessage = lcMsg;
          if (additional_kwargs?.type === "computer_call_output") {
            const output = (() => {
              if (typeof toolMessage.content === "string") return {
                type: "input_image",
                image_url: toolMessage.content
              };
              if (Array.isArray(toolMessage.content)) {
                const inputImage = toolMessage.content.find((i) => i.type === "input_image");
                if (inputImage) return inputImage;
                const oaiScreenshot = toolMessage.content.find((i) => i.type === "computer_screenshot");
                if (oaiScreenshot) return oaiScreenshot;
                const lcImage = toolMessage.content.find((i) => i.type === "image_url");
                if (lcImage) return {
                  type: "input_image",
                  image_url: typeof lcImage.image_url === "string" ? lcImage.image_url : lcImage.image_url.url
                };
              }
              throw new Error("Invalid computer call output");
            })();
            return {
              type: "computer_call_output",
              output,
              call_id: toolMessage.tool_call_id
            };
          }
          if (toolMessage.additional_kwargs?.customTool) return {
            type: "custom_tool_call_output",
            call_id: toolMessage.tool_call_id,
            output: toolMessage.content
          };
          const isProviderNativeContent = Array.isArray(toolMessage.content) && toolMessage.content.every((item) => typeof item === "object" && item !== null && "type" in item && (item.type === "input_file" || item.type === "input_image" || item.type === "input_text"));
          return {
            type: "function_call_output",
            call_id: toolMessage.tool_call_id,
            id: toolMessage.id?.startsWith("fc_") ? toolMessage.id : void 0,
            output: isProviderNativeContent ? toolMessage.content : typeof toolMessage.content !== "string" ? JSON.stringify(toolMessage.content) : toolMessage.content
          };
        }
        if (role === "assistant") {
          if (!zdrEnabled && responseMetadata?.output != null && Array.isArray(responseMetadata?.output) && responseMetadata?.output.length > 0 && responseMetadata?.output.every((item) => "type" in item)) return responseMetadata?.output;
          const input = [];
          if (additional_kwargs?.reasoning && !zdrEnabled) {
            const reasoningItem = convertReasoningSummaryToResponsesReasoningItem(additional_kwargs.reasoning);
            input.push(reasoningItem);
          }
          let { content } = lcMsg;
          if (additional_kwargs?.refusal) {
            if (typeof content === "string") content = [{
              type: "output_text",
              text: content,
              annotations: []
            }];
            content = [...content, {
              type: "refusal",
              refusal: additional_kwargs.refusal
            }];
          }
          if (typeof content === "string" || content.length > 0) input.push({
            type: "message",
            role: "assistant",
            ...lcMsg.id && !zdrEnabled && lcMsg.id.startsWith("msg_") ? { id: lcMsg.id } : {},
            content: iife$1(() => {
              if (typeof content === "string") return content;
              return content.flatMap((item) => {
                if (item.type === "text") return {
                  type: "output_text",
                  text: item.text,
                  annotations: item.annotations ?? []
                };
                if (item.type === "output_text" || item.type === "refusal") return item;
                return [];
              });
            })
          });
          const functionCallIds = additional_kwargs?.[_FUNCTION_CALL_IDS_MAP_KEY];
          if (AIMessage.isInstance(lcMsg) && !!lcMsg.tool_calls?.length) input.push(...lcMsg.tool_calls.map((toolCall) => {
            if (isCustomToolCall(toolCall)) return {
              type: "custom_tool_call",
              id: toolCall.call_id,
              call_id: toolCall.id ?? "",
              input: toolCall.args.input,
              name: toolCall.name
            };
            if (isComputerToolCall(toolCall)) return {
              type: "computer_call",
              id: toolCall.call_id,
              call_id: toolCall.id ?? "",
              action: toolCall.args.action
            };
            return {
              type: "function_call",
              name: toolCall.name,
              arguments: JSON.stringify(toolCall.args),
              call_id: toolCall.id,
              ...!zdrEnabled ? { id: functionCallIds?.[toolCall.id] } : {}
            };
          }));
          else if (additional_kwargs?.tool_calls) input.push(...additional_kwargs.tool_calls.map((toolCall) => ({
            type: "function_call",
            name: toolCall.function.name,
            call_id: toolCall.id,
            arguments: toolCall.function.arguments,
            ...!zdrEnabled ? { id: functionCallIds?.[toolCall.id] } : {}
          })));
          const toolOutputs = responseMetadata?.output?.length ? responseMetadata?.output : additional_kwargs.tool_outputs;
          const fallthroughCallTypes = [
            "computer_call",
            "mcp_call",
            "code_interpreter_call",
            "image_generation_call"
          ];
          if (toolOutputs != null) {
            const castToolOutputs = toolOutputs;
            const fallthroughCalls = castToolOutputs?.filter((item) => fallthroughCallTypes.includes(item.type));
            if (fallthroughCalls.length > 0) input.push(...fallthroughCalls);
          }
          return input;
        }
        if (role === "user" || role === "system" || role === "developer") {
          if (typeof lcMsg.content === "string") return {
            type: "message",
            role,
            content: lcMsg.content
          };
          const messages$1 = [];
          const content = lcMsg.content.flatMap((item) => {
            if (item.type === "mcp_approval_response") messages$1.push({
              type: "mcp_approval_response",
              approval_request_id: item.approval_request_id,
              approve: item.approve
            });
            if (isDataContentBlock(item)) return convertToProviderContentBlock(item, completionsApiContentBlockConverter);
            if (item.type === "text") return {
              type: "input_text",
              text: item.text
            };
            if (item.type === "image_url") {
              const imageUrl = iife$1(() => {
                if (typeof item.image_url === "string") return item.image_url;
                else if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url) return item.image_url.url;
                return void 0;
              });
              const detail = iife$1(() => {
                if (typeof item.image_url === "string") return "auto";
                else if (typeof item.image_url === "object" && item.image_url !== null && "detail" in item.image_url) return item.image_url.detail;
                return void 0;
              });
              return {
                type: "input_image",
                image_url: imageUrl,
                detail
              };
            }
            if (item.type === "input_text" || item.type === "input_image" || item.type === "input_file") return item;
            return [];
          });
          if (content.length > 0) messages$1.push({
            type: "message",
            role,
            content
          });
          return messages$1;
        }
        console.warn(`Unsupported role found when converting to OpenAI Responses API: ${role}`);
        return [];
      });
    };
  }
});

// node_modules/@langchain/openai/dist/chat_models/responses.js
var ChatOpenAIResponses;
var init_responses3 = __esm({
  "node_modules/@langchain/openai/dist/chat_models/responses.js"() {
    init_client3();
    init_tools4();
    init_base16();
    init_responses2();
    init_base8();
    ChatOpenAIResponses = class extends BaseChatOpenAI {
      invocationParams(options) {
        let strict;
        if (options?.strict !== void 0) strict = options.strict;
        if (strict === void 0 && this.supportsStrictToolCalling !== void 0) strict = this.supportsStrictToolCalling;
        const params = {
          model: this.model,
          temperature: this.temperature,
          top_p: this.topP,
          user: this.user,
          stream: this.streaming,
          previous_response_id: options?.previous_response_id,
          truncation: options?.truncation,
          include: options?.include,
          tools: options?.tools?.length ? this._reduceChatOpenAITools(options.tools, {
            stream: this.streaming,
            strict
          }) : void 0,
          tool_choice: isBuiltInToolChoice(options?.tool_choice) ? options?.tool_choice : (() => {
            const formatted = formatToOpenAIToolChoice(options?.tool_choice);
            if (typeof formatted === "object" && "type" in formatted) {
              if (formatted.type === "function") return {
                type: "function",
                name: formatted.function.name
              };
              else if (formatted.type === "allowed_tools") return {
                type: "allowed_tools",
                mode: formatted.allowed_tools.mode,
                tools: formatted.allowed_tools.tools
              };
              else if (formatted.type === "custom") return {
                type: "custom",
                name: formatted.custom.name
              };
            }
            return void 0;
          })(),
          text: (() => {
            if (options?.text) return options.text;
            const format2 = this._getResponseFormat(options?.response_format);
            if (format2?.type === "json_schema") {
              if (format2.json_schema.schema != null) return {
                format: {
                  type: "json_schema",
                  schema: format2.json_schema.schema,
                  description: format2.json_schema.description,
                  name: format2.json_schema.name,
                  strict: format2.json_schema.strict
                },
                verbosity: options?.verbosity
              };
              return void 0;
            }
            return {
              format: format2,
              verbosity: options?.verbosity
            };
          })(),
          parallel_tool_calls: options?.parallel_tool_calls,
          max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
          prompt_cache_key: options?.promptCacheKey ?? this.promptCacheKey,
          prompt_cache_retention: options?.promptCacheRetention ?? this.promptCacheRetention,
          ...this.zdrEnabled ? { store: false } : {},
          ...this.modelKwargs
        };
        const reasoning = this._getReasoningParams(options);
        if (reasoning !== void 0) params.reasoning = reasoning;
        return params;
      }
      async _generate(messages, options, runManager) {
        options.signal?.throwIfAborted();
        const invocationParams = this.invocationParams(options);
        if (invocationParams.stream) {
          const stream = this._streamResponseChunks(messages, options, runManager);
          let finalChunk;
          for await (const chunk of stream) {
            chunk.message.response_metadata = {
              ...chunk.generationInfo,
              ...chunk.message.response_metadata
            };
            finalChunk = finalChunk?.concat(chunk) ?? chunk;
          }
          return {
            generations: finalChunk ? [finalChunk] : [],
            llmOutput: { estimatedTokenUsage: finalChunk?.message?.usage_metadata }
          };
        } else {
          const data = await this.completionWithRetry({
            input: convertMessagesToResponsesInput({
              messages,
              zdrEnabled: this.zdrEnabled ?? false,
              model: this.model
            }),
            ...invocationParams,
            stream: false
          }, {
            signal: options?.signal,
            ...options?.options
          });
          return {
            generations: [{
              text: data.output_text,
              message: convertResponsesMessageToAIMessage(data)
            }],
            llmOutput: {
              id: data.id,
              estimatedTokenUsage: data.usage ? {
                promptTokens: data.usage.input_tokens,
                completionTokens: data.usage.output_tokens,
                totalTokens: data.usage.total_tokens
              } : void 0
            }
          };
        }
      }
      async *_streamResponseChunks(messages, options, runManager) {
        const streamIterable = await this.completionWithRetry({
          ...this.invocationParams(options),
          input: convertMessagesToResponsesInput({
            messages,
            zdrEnabled: this.zdrEnabled ?? false,
            model: this.model
          }),
          stream: true
        }, options);
        for await (const data of streamIterable) {
          if (options.signal?.aborted) return;
          const chunk = convertResponsesDeltaToChatGenerationChunk(data);
          if (chunk == null) continue;
          yield chunk;
          await runManager?.handleLLMNewToken(chunk.text || "", {
            prompt: options.promptIndex ?? 0,
            completion: 0
          }, void 0, void 0, void 0, { chunk });
        }
      }
      async completionWithRetry(request, requestOptions) {
        return this.caller.call(async () => {
          const clientOptions = this._getClientOptions(requestOptions);
          try {
            if (request.text?.format?.type === "json_schema" && !request.stream) return await this.client.responses.parse(request, clientOptions);
            return await this.client.responses.create(request, clientOptions);
          } catch (e) {
            const error40 = wrapOpenAIClientError(e);
            throw error40;
          }
        });
      }
      /** @internal */
      _reduceChatOpenAITools(tools2, fields) {
        const reducedTools = [];
        for (const tool2 of tools2) if (isBuiltInTool(tool2)) {
          if (tool2.type === "image_generation" && fields?.stream) tool2.partial_images = 1;
          reducedTools.push(tool2);
        } else if (isCustomTool(tool2)) {
          const customToolData = tool2.metadata.customTool;
          reducedTools.push({
            type: "custom",
            name: customToolData.name,
            description: customToolData.description,
            format: customToolData.format
          });
        } else if (isOpenAITool(tool2)) reducedTools.push({
          type: "function",
          name: tool2.function.name,
          parameters: tool2.function.parameters,
          description: tool2.function.description,
          strict: fields?.strict ?? null
        });
        else if (isOpenAICustomTool(tool2)) reducedTools.push(convertCompletionsCustomTool(tool2));
        return reducedTools;
      }
    };
  }
});

// node_modules/@langchain/openai/dist/azure/chat_models/responses.js
var init_responses4 = __esm({
  "node_modules/@langchain/openai/dist/azure/chat_models/responses.js"() {
    init_common();
    init_responses3();
  }
});

// node_modules/@langchain/openai/dist/chat_models/index.js
var ChatOpenAI;
var init_chat_models3 = __esm({
  "node_modules/@langchain/openai/dist/chat_models/index.js"() {
    init_tools4();
    init_misc();
    init_base16();
    init_completions5();
    init_responses3();
    ChatOpenAI = class ChatOpenAI2 extends BaseChatOpenAI {
      /**
      * Whether to use the responses API for all requests. If `false` the responses API will be used
      * only when required in order to fulfill the request.
      */
      useResponsesApi = false;
      responses;
      completions;
      get lc_serializable_keys() {
        return [...super.lc_serializable_keys, "useResponsesApi"];
      }
      get callKeys() {
        return [...super.callKeys, "useResponsesApi"];
      }
      constructor(fields) {
        super(fields);
        this.fields = fields;
        this.useResponsesApi = fields?.useResponsesApi ?? false;
        this.responses = fields?.responses ?? new ChatOpenAIResponses(fields);
        this.completions = fields?.completions ?? new ChatOpenAICompletions(fields);
      }
      _useResponsesApi(options) {
        const usesBuiltInTools = options?.tools?.some(isBuiltInTool);
        const hasResponsesOnlyKwargs = options?.previous_response_id != null || options?.text != null || options?.truncation != null || options?.include != null || options?.reasoning?.summary != null || this.reasoning?.summary != null;
        const hasCustomTools = options?.tools?.some(isOpenAICustomTool) || options?.tools?.some(isCustomTool);
        return this.useResponsesApi || usesBuiltInTools || hasResponsesOnlyKwargs || hasCustomTools || _modelPrefersResponsesAPI(this.model);
      }
      getLsParams(options) {
        const optionsWithDefaults = this._combineCallOptions(options);
        if (this._useResponsesApi(options)) return this.responses.getLsParams(optionsWithDefaults);
        return this.completions.getLsParams(optionsWithDefaults);
      }
      invocationParams(options) {
        const optionsWithDefaults = this._combineCallOptions(options);
        if (this._useResponsesApi(options)) return this.responses.invocationParams(optionsWithDefaults);
        return this.completions.invocationParams(optionsWithDefaults);
      }
      /** @ignore */
      async _generate(messages, options, runManager) {
        if (this._useResponsesApi(options)) return this.responses._generate(messages, options, runManager);
        return this.completions._generate(messages, options, runManager);
      }
      async *_streamResponseChunks(messages, options, runManager) {
        if (this._useResponsesApi(options)) {
          yield* this.responses._streamResponseChunks(messages, this._combineCallOptions(options), runManager);
          return;
        }
        yield* this.completions._streamResponseChunks(messages, this._combineCallOptions(options), runManager);
      }
      withConfig(config2) {
        const newModel = new ChatOpenAI2(this.fields);
        newModel.defaultOptions = {
          ...this.defaultOptions,
          ...config2
        };
        return newModel;
      }
    };
  }
});

// node_modules/@langchain/openai/dist/azure/chat_models/index.js
var init_chat_models4 = __esm({
  "node_modules/@langchain/openai/dist/azure/chat_models/index.js"() {
    init_common();
    init_completions6();
    init_responses4();
    init_chat_models3();
  }
});

// node_modules/@langchain/openai/dist/llms.js
var init_llms3 = __esm({
  "node_modules/@langchain/openai/dist/llms.js"() {
    init_client3();
    init_azure2();
    init_openai2();
    init_outputs();
    init_env();
    init_base8();
    init_llms();
    init_chunk_array();
  }
});

// node_modules/@langchain/openai/dist/azure/llms.js
var init_llms4 = __esm({
  "node_modules/@langchain/openai/dist/azure/llms.js"() {
    init_azure2();
    init_llms3();
    init_openai2();
    init_env();
  }
});

// node_modules/@langchain/openai/dist/embeddings.js
var init_embeddings4 = __esm({
  "node_modules/@langchain/openai/dist/embeddings.js"() {
    init_client3();
    init_azure2();
    init_openai2();
    init_env();
    init_chunk_array();
    init_embeddings();
  }
});

// node_modules/@langchain/openai/dist/azure/embeddings.js
var init_embeddings5 = __esm({
  "node_modules/@langchain/openai/dist/azure/embeddings.js"() {
    init_client3();
    init_azure2();
    init_embeddings4();
    init_openai2();
    init_env();
  }
});

// node_modules/@langchain/openai/dist/tools/dalle.js
var init_dalle = __esm({
  "node_modules/@langchain/openai/dist/tools/dalle.js"() {
    init_openai2();
    init_env();
    init_tools2();
  }
});

// node_modules/@langchain/openai/dist/tools/webSearch.js
var init_webSearch = __esm({
  "node_modules/@langchain/openai/dist/tools/webSearch.js"() {
  }
});

// node_modules/@langchain/openai/dist/tools/mcp.js
var init_mcp = __esm({
  "node_modules/@langchain/openai/dist/tools/mcp.js"() {
  }
});

// node_modules/@langchain/openai/dist/tools/codeInterpreter.js
var init_codeInterpreter = __esm({
  "node_modules/@langchain/openai/dist/tools/codeInterpreter.js"() {
  }
});

// node_modules/@langchain/openai/dist/tools/fileSearch.js
var init_fileSearch = __esm({
  "node_modules/@langchain/openai/dist/tools/fileSearch.js"() {
  }
});

// node_modules/@langchain/openai/dist/tools/imageGeneration.js
var init_imageGeneration = __esm({
  "node_modules/@langchain/openai/dist/tools/imageGeneration.js"() {
  }
});

// node_modules/@langchain/openai/dist/tools/computerUse.js
var ComputerUseScreenshotActionSchema, ComputerUseClickActionSchema, ComputerUseDoubleClickActionSchema, ComputerUseDragActionSchema, ComputerUseKeypressActionSchema, ComputerUseMoveActionSchema, ComputerUseScrollActionSchema, ComputerUseTypeActionSchema, ComputerUseWaitActionSchema, ComputerUseActionUnionSchema, ComputerUseActionSchema;
var init_computerUse = __esm({
  "node_modules/@langchain/openai/dist/tools/computerUse.js"() {
    init_messages2();
    init_tools2();
    init_v43();
    ComputerUseScreenshotActionSchema = external_exports2.object({ type: external_exports2.literal("screenshot") });
    ComputerUseClickActionSchema = external_exports2.object({
      type: external_exports2.literal("click"),
      x: external_exports2.number(),
      y: external_exports2.number(),
      button: external_exports2.enum([
        "left",
        "right",
        "wheel",
        "back",
        "forward"
      ]).default("left")
    });
    ComputerUseDoubleClickActionSchema = external_exports2.object({
      type: external_exports2.literal("double_click"),
      x: external_exports2.number(),
      y: external_exports2.number(),
      button: external_exports2.enum([
        "left",
        "right",
        "wheel",
        "back",
        "forward"
      ]).default("left")
    });
    ComputerUseDragActionSchema = external_exports2.object({
      type: external_exports2.literal("drag"),
      path: external_exports2.array(external_exports2.object({
        x: external_exports2.number(),
        y: external_exports2.number()
      }))
    });
    ComputerUseKeypressActionSchema = external_exports2.object({
      type: external_exports2.literal("keypress"),
      keys: external_exports2.array(external_exports2.string())
    });
    ComputerUseMoveActionSchema = external_exports2.object({
      type: external_exports2.literal("move"),
      x: external_exports2.number(),
      y: external_exports2.number()
    });
    ComputerUseScrollActionSchema = external_exports2.object({
      type: external_exports2.literal("scroll"),
      x: external_exports2.number(),
      y: external_exports2.number(),
      scroll_x: external_exports2.number(),
      scroll_y: external_exports2.number()
    });
    ComputerUseTypeActionSchema = external_exports2.object({
      type: external_exports2.literal("type"),
      text: external_exports2.string()
    });
    ComputerUseWaitActionSchema = external_exports2.object({
      type: external_exports2.literal("wait"),
      duration: external_exports2.number().optional()
    });
    ComputerUseActionUnionSchema = external_exports2.discriminatedUnion("type", [
      ComputerUseScreenshotActionSchema,
      ComputerUseClickActionSchema,
      ComputerUseDoubleClickActionSchema,
      ComputerUseDragActionSchema,
      ComputerUseKeypressActionSchema,
      ComputerUseMoveActionSchema,
      ComputerUseScrollActionSchema,
      ComputerUseTypeActionSchema,
      ComputerUseWaitActionSchema
    ]);
    ComputerUseActionSchema = external_exports2.object({ action: ComputerUseActionUnionSchema });
  }
});

// node_modules/@langchain/openai/dist/tools/localShell.js
var LocalShellExecActionSchema, LocalShellActionSchema;
var init_localShell = __esm({
  "node_modules/@langchain/openai/dist/tools/localShell.js"() {
    init_tools2();
    init_v43();
    LocalShellExecActionSchema = external_exports2.object({
      type: external_exports2.literal("exec"),
      command: external_exports2.array(external_exports2.string()),
      env: external_exports2.record(external_exports2.string(), external_exports2.string()).optional(),
      working_directory: external_exports2.string().optional(),
      timeout_ms: external_exports2.number().optional(),
      user: external_exports2.string().optional()
    });
    LocalShellActionSchema = external_exports2.discriminatedUnion("type", [LocalShellExecActionSchema]);
  }
});

// node_modules/@langchain/openai/dist/tools/shell.js
var ShellActionSchema;
var init_shell = __esm({
  "node_modules/@langchain/openai/dist/tools/shell.js"() {
    init_tools2();
    init_v43();
    ShellActionSchema = external_exports2.object({
      commands: external_exports2.array(external_exports2.string()).describe("Array of shell commands to execute"),
      timeout_ms: external_exports2.number().optional().describe("Optional timeout in milliseconds for the commands"),
      max_output_length: external_exports2.number().optional().describe("Optional maximum number of characters to return from each command")
    });
  }
});

// node_modules/@langchain/openai/dist/tools/applyPatch.js
var ApplyPatchCreateFileOperationSchema, ApplyPatchUpdateFileOperationSchema, ApplyPatchDeleteFileOperationSchema, ApplyPatchOperationSchema;
var init_applyPatch = __esm({
  "node_modules/@langchain/openai/dist/tools/applyPatch.js"() {
    init_tools2();
    init_v43();
    ApplyPatchCreateFileOperationSchema = external_exports2.object({
      type: external_exports2.literal("create_file"),
      path: external_exports2.string(),
      diff: external_exports2.string()
    });
    ApplyPatchUpdateFileOperationSchema = external_exports2.object({
      type: external_exports2.literal("update_file"),
      path: external_exports2.string(),
      diff: external_exports2.string()
    });
    ApplyPatchDeleteFileOperationSchema = external_exports2.object({
      type: external_exports2.literal("delete_file"),
      path: external_exports2.string()
    });
    ApplyPatchOperationSchema = external_exports2.discriminatedUnion("type", [
      ApplyPatchCreateFileOperationSchema,
      ApplyPatchUpdateFileOperationSchema,
      ApplyPatchDeleteFileOperationSchema
    ]);
  }
});

// node_modules/@langchain/openai/dist/tools/index.js
var init_tools5 = __esm({
  "node_modules/@langchain/openai/dist/tools/index.js"() {
    init_dalle();
    init_webSearch();
    init_mcp();
    init_codeInterpreter();
    init_fileSearch();
    init_imageGeneration();
    init_computerUse();
    init_localShell();
    init_shell();
    init_applyPatch();
  }
});

// node_modules/@langchain/openai/dist/tools/custom.js
var init_custom = __esm({
  "node_modules/@langchain/openai/dist/tools/custom.js"() {
    init_runnables();
    init_tools2();
    init_singletons();
  }
});

// node_modules/@langchain/openai/dist/utils/prompts.js
var init_prompts3 = __esm({
  "node_modules/@langchain/openai/dist/utils/prompts.js"() {
    init_completions4();
  }
});

// node_modules/@langchain/openai/dist/converters/index.js
var init_converters = __esm({
  "node_modules/@langchain/openai/dist/converters/index.js"() {
    init_completions4();
    init_responses2();
  }
});

// node_modules/@langchain/openai/dist/index.js
var init_dist5 = __esm({
  "node_modules/@langchain/openai/dist/index.js"() {
    init_client3();
    init_misc();
    init_azure2();
    init_base16();
    init_completions4();
    init_completions5();
    init_completions6();
    init_responses2();
    init_responses3();
    init_responses4();
    init_chat_models3();
    init_chat_models4();
    init_llms3();
    init_llms4();
    init_embeddings4();
    init_embeddings5();
    init_dalle();
    init_tools5();
    init_custom();
    init_prompts3();
    init_converters();
    init_openai2();
  }
});

// node_modules/fast-xml-parser/src/util.js
function getAllMatches(string4, regex2) {
  const matches = [];
  let match = regex2.exec(string4);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex2.lastIndex - match[0].length;
    const len = match.length;
    for (let index2 = 0; index2 < len; index2++) {
      allmatches.push(match[index2]);
    }
    matches.push(allmatches);
    match = regex2.exec(string4);
  }
  return matches;
}
function isExist(v) {
  return typeof v !== "undefined";
}
var nameStartChar, nameChar, nameRegexp, regexName, isName;
var init_util4 = __esm({
  "node_modules/fast-xml-parser/src/util.js"() {
    "use strict";
    nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    regexName = new RegExp("^" + nameRegexp + "$");
    isName = function(string4) {
      const match = regexName.exec(string4);
      return !(match === null || typeof match === "undefined");
    };
  }
});

// node_modules/fast-xml-parser/src/validator.js
function validate7(xmlData, options) {
  options = Object.assign({}, defaultOptions5, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err) return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid2 = validateAttributeString(attrStr, options);
          if (isValid2 === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid2 = validateAttributeString(attrStr, options);
          if (isValid2 !== true) {
            return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid2.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1) {
          } else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
}
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
      } else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
function validateAttributeString(attrStr, options) {
  const matches = getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return isName(attrName);
}
function validateTagName(tagname) {
  return isName(tagname);
}
function getLineNumberForPosition(xmlData, index2) {
  const lines = xmlData.substring(0, index2).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}
var defaultOptions5, doubleQuote, singleQuote, validAttrStrRegxp;
var init_validator2 = __esm({
  "node_modules/fast-xml-parser/src/validator.js"() {
    "use strict";
    init_util4();
    defaultOptions5 = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    doubleQuote = '"';
    singleQuote = "'";
    validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var defaultOptions6, buildOptions;
var init_OptionsBuilder = __esm({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"() {
    defaultOptions6 = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      },
      // skipEmptyListItem: false
      captureMetaData: false
    };
    buildOptions = function(options) {
      return Object.assign({}, defaultOptions6, options);
    };
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var METADATA_SYMBOL, XmlNode;
var init_xmlNode = __esm({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"() {
    "use strict";
    if (typeof Symbol !== "function") {
      METADATA_SYMBOL = "@@xmlMetadata";
    } else {
      METADATA_SYMBOL = Symbol("XML Node Metadata");
    }
    XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__") key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node, startIndex) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
        if (startIndex !== void 0) {
          this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };
        }
      }
      /** symbol used for metadata */
      static getMetaDataSymbol() {
        return METADATA_SYMBOL;
      }
    };
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
function readDocType(xmlData, i) {
  const entities = {};
  if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
    i = i + 9;
    let angleBracketsCount = 1;
    let hasBody = false, comment = false;
    let exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && !comment) {
        if (hasBody && hasSeq(xmlData, "!ENTITY", i)) {
          i += 7;
          let entityName, val;
          [entityName, val, i] = readEntityExp(xmlData, i + 1);
          if (val.indexOf("&") === -1)
            entities[entityName] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            };
        } else if (hasBody && hasSeq(xmlData, "!ELEMENT", i)) {
          i += 8;
          const { index: index2 } = readElementExp(xmlData, i + 1);
          i = index2;
        } else if (hasBody && hasSeq(xmlData, "!ATTLIST", i)) {
          i += 8;
        } else if (hasBody && hasSeq(xmlData, "!NOTATION", i)) {
          i += 9;
          const { index: index2 } = readNotationExp(xmlData, i + 1);
          i = index2;
        } else if (hasSeq(xmlData, "!--", i)) comment = true;
        else throw new Error(`Invalid DOCTYPE`);
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === ">") {
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === "[") {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error(`Unclosed DOCTYPE`);
    }
  } else {
    throw new Error(`Invalid Tag instead of DOCTYPE`);
  }
  return { entities, i };
}
function readEntityExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let entityName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i]) && xmlData[i] !== '"' && xmlData[i] !== "'") {
    entityName += xmlData[i];
    i++;
  }
  validateEntityName(entityName);
  i = skipWhitespace(xmlData, i);
  if (xmlData.substring(i, i + 6).toUpperCase() === "SYSTEM") {
    throw new Error("External entities are not supported");
  } else if (xmlData[i] === "%") {
    throw new Error("Parameter entities are not supported");
  }
  let entityValue = "";
  [i, entityValue] = readIdentifierVal(xmlData, i, "entity");
  i--;
  return [entityName, entityValue, i];
}
function readNotationExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let notationName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i])) {
    notationName += xmlData[i];
    i++;
  }
  validateEntityName(notationName);
  i = skipWhitespace(xmlData, i);
  const identifierType = xmlData.substring(i, i + 6).toUpperCase();
  if (identifierType !== "SYSTEM" && identifierType !== "PUBLIC") {
    throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
  }
  i += identifierType.length;
  i = skipWhitespace(xmlData, i);
  let publicIdentifier = null;
  let systemIdentifier = null;
  if (identifierType === "PUBLIC") {
    [i, publicIdentifier] = readIdentifierVal(xmlData, i, "publicIdentifier");
    i = skipWhitespace(xmlData, i);
    if (xmlData[i] === '"' || xmlData[i] === "'") {
      [i, systemIdentifier] = readIdentifierVal(xmlData, i, "systemIdentifier");
    }
  } else if (identifierType === "SYSTEM") {
    [i, systemIdentifier] = readIdentifierVal(xmlData, i, "systemIdentifier");
    if (!systemIdentifier) {
      throw new Error("Missing mandatory system identifier for SYSTEM notation");
    }
  }
  return { notationName, publicIdentifier, systemIdentifier, index: --i };
}
function readIdentifierVal(xmlData, i, type) {
  let identifierVal = "";
  const startChar = xmlData[i];
  if (startChar !== '"' && startChar !== "'") {
    throw new Error(`Expected quoted string, found "${startChar}"`);
  }
  i++;
  while (i < xmlData.length && xmlData[i] !== startChar) {
    identifierVal += xmlData[i];
    i++;
  }
  if (xmlData[i] !== startChar) {
    throw new Error(`Unterminated ${type} value`);
  }
  i++;
  return [i, identifierVal];
}
function readElementExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let elementName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i])) {
    elementName += xmlData[i];
    i++;
  }
  if (!validateEntityName(elementName)) {
    throw new Error(`Invalid element name: "${elementName}"`);
  }
  i = skipWhitespace(xmlData, i);
  let contentModel = "";
  if (xmlData[i] === "E" && hasSeq(xmlData, "MPTY", i)) i += 4;
  else if (xmlData[i] === "A" && hasSeq(xmlData, "NY", i)) i += 2;
  else if (xmlData[i] === "(") {
    i++;
    while (i < xmlData.length && xmlData[i] !== ")") {
      contentModel += xmlData[i];
      i++;
    }
    if (xmlData[i] !== ")") {
      throw new Error("Unterminated content model");
    }
  } else {
    throw new Error(`Invalid Element Expression, found "${xmlData[i]}"`);
  }
  return {
    elementName,
    contentModel: contentModel.trim(),
    index: i
  };
}
function hasSeq(data, seq, i) {
  for (let j = 0; j < seq.length; j++) {
    if (seq[j] !== data[i + j + 1]) return false;
  }
  return true;
}
function validateEntityName(name) {
  if (isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}
var skipWhitespace;
var init_DocTypeReader = __esm({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"() {
    init_util4();
    skipWhitespace = (data, index2) => {
      while (index2 < data.length && /\s/.test(data[index2])) {
        index2++;
      }
      return index2;
    };
  }
});

// node_modules/strnum/strnum.js
function toNumber(str2, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str2 || typeof str2 !== "string") return str2;
  let trimmedStr = str2.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str2;
  else if (str2 === "0") return 0;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return parse_int(trimmedStr, 16);
  } else if (trimmedStr.search(/.+[eE].+/) !== -1) {
    return resolveEnotation(str2, trimmedStr, options);
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign = match[1] || "";
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      const decimalAdjacentToLeadingZeros = sign ? (
        // 0., -00., 000.
        str2[leadingZeros.length + 1] === "."
      ) : str2[leadingZeros.length] === ".";
      if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {
        return str2;
      } else {
        const num = Number(trimmedStr);
        const parsedStr = String(num);
        if (num === 0) return num;
        if (parsedStr.search(/[eE]/) !== -1) {
          if (options.eNotation) return num;
          else return str2;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (parsedStr === "0") return num;
          else if (parsedStr === numTrimmedByZeros) return num;
          else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;
          else return str2;
        }
        let n2 = leadingZeros ? numTrimmedByZeros : trimmedStr;
        if (leadingZeros) {
          return n2 === parsedStr || sign + n2 === parsedStr ? num : str2;
        } else {
          return n2 === parsedStr || n2 === sign + parsedStr ? num : str2;
        }
      }
    } else {
      return str2;
    }
  }
}
function resolveEnotation(str2, trimmedStr, options) {
  if (!options.eNotation) return str2;
  const notation = trimmedStr.match(eNotationRegx);
  if (notation) {
    let sign = notation[1] || "";
    const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
    const leadingZeros = notation[2];
    const eAdjacentToLeadingZeros = sign ? (
      // 0E.
      str2[leadingZeros.length + 1] === eChar
    ) : str2[leadingZeros.length] === eChar;
    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str2;
    else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {
      return Number(trimmedStr);
    } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {
      trimmedStr = (notation[1] || "") + notation[3];
      return Number(trimmedStr);
    } else return str2;
  } else {
    return str2;
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".") numStr = "0";
    else if (numStr[0] === ".") numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
function parse_int(numStr, base) {
  if (parseInt) return parseInt(numStr, base);
  else if (Number.parseInt) return Number.parseInt(numStr, base);
  else if (window && window.parseInt) return window.parseInt(numStr, base);
  else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
var hexRegex, numRegex, consider, eNotationRegx;
var init_strnum = __esm({
  "node_modules/strnum/strnum.js"() {
    hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
    consider = {
      hex: true,
      // oct: false,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
  }
});

// node_modules/fast-xml-parser/src/ignoreAttributes.js
function getIgnoreAttributesFn(ignoreAttributes) {
  if (typeof ignoreAttributes === "function") {
    return ignoreAttributes;
  }
  if (Array.isArray(ignoreAttributes)) {
    return (attrName) => {
      for (const pattern of ignoreAttributes) {
        if (typeof pattern === "string" && attrName === pattern) {
          return true;
        }
        if (pattern instanceof RegExp && pattern.test(attrName)) {
          return true;
        }
      }
    };
  }
  return () => false;
}
var init_ignoreAttributes = __esm({
  "node_modules/fast-xml-parser/src/ignoreAttributes.js"() {
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if (val.length > 0) {
      if (!escapeEntities) val = this.replaceEntitiesValue(val);
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val;
      } else if (typeof newval !== typeof val || newval !== val) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val.trim();
        if (trimmedVal === val) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
    const matches = getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue;
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__") aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
function addChild(currentNode, childNode, jPath, startIndex) {
  if (!this.options.captureMetaData) startIndex = void 0;
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false) {
  } else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode, startIndex);
  } else {
    currentNode.addChild(childNode, startIndex);
  }
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index2 = i; index2 < xmlData.length; index2++) {
    let ch = xmlData[index2];
    if (attrBoundary) {
      if (ch === attrBoundary) attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index2 + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index: index2
          };
        }
      } else {
        return {
          data: tagExp,
          index: index2
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str2, i, errMsg) {
  const closingIndex = xmlData.indexOf(str2, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str2.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === "string") {
    const newval = val.trim();
    if (newval === "true") return true;
    else if (newval === "false") return false;
    else return toNumber(val, options);
  } else {
    if (isExist(val)) {
      return val;
    } else {
      return "";
    }
  }
}
var OrderedObjParser, attrsRegx, parseXml, replaceEntitiesValue;
var init_OrderedObjParser = __esm({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"() {
    "use strict";
    init_util4();
    init_xmlNode();
    init_DocTypeReader();
    init_strnum();
    init_ignoreAttributes();
    OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str2) => String.fromCodePoint(Number.parseInt(str2, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str2) => String.fromCodePoint(Number.parseInt(str2, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
      }
    };
    attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new XmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i = 0; i < xmlData.length; i++) {
        const ch = xmlData[i];
        if (ch === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            let tagData = readTagExp(xmlData, i, false, "?>");
            if (!tagData) throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new XmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath, i);
            }
            i = tagData.closeIndex + 1;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i = endIndex;
          } else if (xmlData.substr(i + 1, 2) === "!D") {
            const result = readDocType(xmlData, i);
            this.docTypeEntities = result.entities;
            i = result.i;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val == void 0) val = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val);
            }
            i = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            const startIndex = i;
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
                i = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new XmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath, startIndex);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new XmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath, startIndex);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new XmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath, startIndex);
                currentNode = childNode;
              }
              textData = "";
              i = closeIndex;
            }
          }
        } else {
          textData += xmlData[i];
        }
      }
      return xmlObj.child;
    };
    replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
function prettify(node, options) {
  return compress(node, options);
}
function compress(arr3, options, jPath) {
  let text2;
  const compressedObj = {};
  for (let i = 0; i < arr3.length; i++) {
    const tagObj = arr3[i];
    const property = propName(tagObj);
    let newJpath = "";
    if (jPath === void 0) newJpath = property;
    else newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text2 === void 0) text2 = tagObj[property];
      else text2 += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);
      if (tagObj[METADATA_SYMBOL2] !== void 0) {
        val[METADATA_SYMBOL2] = tagObj[METADATA_SYMBOL2];
      }
      if (tagObj[":@"]) {
        assignAttributes(val, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val = val[options.textNodeName];
      } else if (Object.keys(val).length === 0) {
        if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val);
      } else {
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val];
        } else {
          compressedObj[property] = val;
        }
      }
    }
  }
  if (typeof text2 === "string") {
    if (text2.length > 0) compressedObj[options.textNodeName] = text2;
  } else if (text2 !== void 0) compressedObj[options.textNodeName] = text2;
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (key !== ":@") return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}
var METADATA_SYMBOL2;
var init_node2json = __esm({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"() {
    "use strict";
    init_xmlNode();
    METADATA_SYMBOL2 = XmlNode.getMetaDataSymbol();
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var XMLParser;
var init_XMLParser = __esm({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"() {
    init_OptionsBuilder();
    init_OrderedObjParser();
    init_node2json();
    init_validator2();
    init_xmlNode();
    XMLParser = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true) validationOption = {};
          const result = validate7(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
        else return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
      /**
       * Returns a Symbol that can be used to access the metadata
       * property on a node.
       * 
       * If Symbol is not available in the environment, an ordinary property is used
       * and the name of the property is here returned.
       * 
       * The XMLMetaData property is only present when `captureMetaData`
       * is true in the options.
       */
      static getMetaDataSymbol() {
        return XmlNode.getMetaDataSymbol();
      }
    };
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var init_fxp = __esm({
  "node_modules/fast-xml-parser/src/fxp.js"() {
    "use strict";
    init_XMLParser();
  }
});

// server/services/arxiv.ts
var ArxivService;
var init_arxiv = __esm({
  "server/services/arxiv.ts"() {
    "use strict";
    init_fxp();
    ArxivService = class {
      baseUrl = "http://export.arxiv.org/api/query";
      parser = new XMLParser({
        ignoreAttributes: false,
        attributeNamePrefix: "@_"
      });
      async searchPapers(topic, keywords, subdomain, days = 7) {
        try {
          let searchQuery = `all:${topic}`;
          if (keywords) {
            const keywordArray = keywords.split(",").map((k) => k.trim());
            searchQuery += ` AND (${keywordArray.map((k) => `all:${k}`).join(" OR ")})`;
          }
          if (subdomain && subdomain !== "all") {
            searchQuery += ` AND cat:${subdomain}`;
          } else {
            searchQuery += ` AND (cat:cs.AI OR cat:cs.LG OR cat:cs.CL OR cat:cs.CV OR cat:cs.RO OR cat:cs.NE)`;
          }
          const cutoffDate = /* @__PURE__ */ new Date();
          cutoffDate.setDate(cutoffDate.getDate() - days);
          const dateFilter = cutoffDate.toISOString().split("T")[0].replace(/-/g, "");
          const params = new URLSearchParams({
            search_query: searchQuery,
            start: "0",
            max_results: "50",
            sortBy: "submittedDate",
            sortOrder: "descending"
          });
          const response = await fetch(`${this.baseUrl}?${params}`);
          if (!response.ok) {
            throw new Error(`ArXiv API error: ${response.status} ${response.statusText}`);
          }
          const xmlData = await response.text();
          const parsed = this.parser.parse(xmlData);
          const feed = parsed.feed;
          if (!feed || !feed.entry) {
            return [];
          }
          const entries = Array.isArray(feed.entry) ? feed.entry : [feed.entry];
          const papers = entries.filter((entry) => {
            const publishedDate = new Date(entry.published);
            return publishedDate >= cutoffDate;
          }).map((entry) => this.convertToPaper(entry)).slice(0, 10);
          return papers;
        } catch (error40) {
          console.error("Error fetching from ArXiv:", error40);
          throw new Error("Failed to fetch papers from ArXiv");
        }
      }
      convertToPaper(entry) {
        let authors = "";
        if (Array.isArray(entry.author)) {
          authors = entry.author.map((a) => a.name).join(", ");
        } else if (entry.author) {
          authors = entry.author.name || "Unknown";
        }
        let categories = [];
        if (Array.isArray(entry.category)) {
          categories = entry.category.map((c) => c["@_term"]);
        } else if (entry.category) {
          categories = [entry.category["@_term"]];
        }
        const arxivId = entry.id.split("/").pop() || entry.id;
        return {
          id: arxivId,
          title: entry.title.replace(/\n/g, " ").trim(),
          authors,
          abstract: entry.summary.replace(/\n/g, " ").trim(),
          arxivUrl: `https://arxiv.org/abs/${arxivId}`,
          publishedDate: entry.published,
          categories
        };
      }
    };
  }
});

// node_modules/@langchain/tavily/dist/utils.js
var TAVILY_BASE_URL, BaseTavilyAPIWrapper, TavilySearchAPIWrapper;
var init_utils12 = __esm({
  "node_modules/@langchain/tavily/dist/utils.js"() {
    init_env();
    TAVILY_BASE_URL = "https://api.tavily.com";
    BaseTavilyAPIWrapper = class {
      tavilyApiKey;
      apiBaseUrl;
      /**
      * Constructs a new instance of the BaseTavilyAPIWrapper.
      * @param fields The fields used to initialize the wrapper.
      */
      constructor(fields) {
        const apiKey = fields.tavilyApiKey ?? getEnvironmentVariable("TAVILY_API_KEY");
        if (!apiKey) throw new Error("Tavily API key not found. Please provide it as an argument or set the TAVILY_API_KEY environment variable.");
        this.tavilyApiKey = apiKey;
        this.apiBaseUrl = fields.apiBaseUrl ?? TAVILY_BASE_URL;
      }
      /**
      * Converts camelCase keys to snake_case for API compatibility
      * @param params The parameters with camelCase keys
      * @returns The parameters with snake_case keys only
      */
      convertCamelToSnakeCase(params) {
        const result = {};
        for (const [key, value] of Object.entries(params)) {
          if (value === void 0) continue;
          let newKey = key.replace(/^[A-Z]/, (letter) => letter.toLowerCase());
          newKey = newKey.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
          result[newKey] = value;
        }
        return result;
      }
    };
    TavilySearchAPIWrapper = class extends BaseTavilyAPIWrapper {
      async rawResults(params) {
        const headers = {
          Authorization: `Bearer ${this.tavilyApiKey}`,
          "Content-Type": "application/json"
        };
        const apiParams = this.convertCamelToSnakeCase(params);
        const response = await fetch(`${this.apiBaseUrl}/search`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            ...apiParams,
            client_source: "langchain-js"
          })
        });
        if (!response.ok) {
          console.log(response);
          const errorData = await response.json();
          const errorMessage = errorData.detail?.error || "Unknown error";
          throw new Error(`Error ${response.status}: ${errorMessage}`);
        }
        return response.json();
      }
    };
  }
});

// node_modules/@langchain/tavily/dist/tavily-extract.js
var inputSchema;
var init_tavily_extract = __esm({
  "node_modules/@langchain/tavily/dist/tavily-extract.js"() {
    init_utils12();
    init_tools2();
    init_v3();
    inputSchema = external_exports.object({
      urls: external_exports.array(external_exports.string()).describe("List of URLs to extract"),
      extractDepth: external_exports.enum(["basic", "advanced"]).optional().describe(`Controls the thoroughness of web content extraction.

Use "basic" for faster extraction of main text content.

Use "advanced" (default) to retrieve comprehensive content including 
tables and embedded elements. Always use "advanced" for LinkedIn 
and YouTube URLs for optimal results.

Better for complex websites but may increase response time.`),
      includeImages: external_exports.boolean().optional().describe(`Determines whether to extract and include images from the source URLs.

Set to True when visualizations are needed for better context or understanding.

Default is False (extracts text content only).`),
      query: external_exports.string().optional().describe("User intent query for reranking extracted content chunks.")
    });
  }
});

// node_modules/@langchain/tavily/dist/tavily-search.js
function generateSuggestions(params) {
  const suggestions = [];
  const { timeRange, includeDomains, excludeDomains, searchDepth, topic } = params;
  if (timeRange) suggestions.push("Remove time_range argument");
  if (includeDomains && Array.isArray(includeDomains) && includeDomains.length > 0) suggestions.push("Remove include_domains argument");
  if (excludeDomains && Array.isArray(excludeDomains) && excludeDomains.length > 0) suggestions.push("Remove exclude_domains argument");
  if (searchDepth === "basic") suggestions.push("Try a more detailed search using 'advanced' search_depth");
  if (topic && topic !== "general") suggestions.push("Try a general search using 'general' topic");
  return suggestions;
}
var inputSchema2, TavilySearch;
var init_tavily_search = __esm({
  "node_modules/@langchain/tavily/dist/tavily-search.js"() {
    init_utils12();
    init_tools2();
    init_v3();
    inputSchema2 = external_exports.object({
      query: external_exports.string().describe("Search query to look up"),
      includeDomains: external_exports.array(external_exports.string()).optional().describe(`A list of domains to restrict search results to.

Use this parameter when:
1. The user explicitly requests information from specific websites (e.g., "Find climate data from nasa.gov")
2. The user mentions an organization or company without specifying the domain (e.g., "Find information about iPhones from Apple")

In both cases, you should determine the appropriate domains (e.g., ["nasa.gov"] or ["apple.com"]) and set this parameter.

Results will ONLY come from the specified domains - no other sources will be included.
Default is None (no domain restriction).`),
      excludeDomains: external_exports.array(external_exports.string()).optional().describe(`A list of domains to exclude from search results.

Use this parameter when:
1. The user explicitly requests to avoid certain websites (e.g., "Find information about climate change but not from twitter.com")
2. The user mentions not wanting results from specific organizations without naming the domain (e.g., "Find phone reviews but nothing from Apple")

In both cases, you should determine the appropriate domains to exclude (e.g., ["twitter.com"] or ["apple.com"]) and set this parameter.

Results will filter out all content from the specified domains.
Default is None (no domain exclusion).`),
      searchDepth: external_exports.enum(["basic", "advanced"]).optional().describe(`Controls search thoroughness and result comprehensiveness.

Use "basic" (default) for simple queries requiring quick, straightforward answers.

Use "advanced" for complex queries, specialized topics, 
rare information, or when in-depth analysis is needed.`),
      includeImages: external_exports.boolean().optional().describe(`Determines if the search returns relevant images along with text results.

Set to True when the user explicitly requests visuals or when images would 
significantly enhance understanding (e.g., "Show me what black holes look like," 
"Find pictures of Renaissance art").

Leave as False (default) for most informational queries where text is sufficient.`),
      timeRange: external_exports.enum([
        "day",
        "week",
        "month",
        "year"
      ]).optional().describe(`Limits results to content published within a specific timeframe.

ONLY set this when the user explicitly mentions a time period 
(e.g., "latest AI news," "articles from last week").

For less popular or niche topics, use broader time ranges 
("month" or "year") to ensure sufficient relevant results.

Options: "day" (24h), "week" (7d), "month" (30d), "year" (365d).

Default is None.`),
      topic: external_exports.enum([
        "general",
        "news",
        "finance"
      ]).optional().describe(`Specifies search category for optimized results.

Use "general" (default) for most queries, INCLUDING those with terms like 
"latest," "newest," or "recent" when referring to general information.

Use "finance" for markets, investments, economic data, or financial news.

Use "news" ONLY for politics, sports, or major current events covered by 
mainstream media - NOT simply because a query asks for "new" information.`)
    });
    TavilySearch = class extends StructuredTool {
      static lc_name() {
        return "TavilySearch";
      }
      description = "A search engine optimized for comprehensive, accurate, and trusted results. Useful for when you need to answer questions about current events. Input should be a search query.";
      name = "tavily_search";
      schema = inputSchema2;
      apiBaseUrl;
      maxResults;
      includeImages;
      includeImageDescriptions;
      includeAnswer;
      includeRawContent;
      includeDomains;
      excludeDomains;
      searchDepth;
      topic;
      days;
      timeRange;
      chunksPerSource;
      country;
      autoParameters;
      includeFavicon;
      includeUsage;
      handleToolError = true;
      apiWrapper;
      /**
      * Constructs a new instance of the TavilySearch tool.
      * @param params Optional configuration parameters for the tool.
      *               Includes options like `maxResults`, `tavilyApiKey`,
      *               `includeImages`, `includeAnswer`, `searchDepth`, etc.
      *               See {@link TavilySearchAPIRetrieverFields} for details.
      */
      constructor(params = {}) {
        super(params);
        if (params.name) this.name = params.name;
        if (params.description) this.description = params.description;
        if (params.apiWrapper) this.apiWrapper = params.apiWrapper;
        else {
          const apiWrapperParams = {};
          if (params.tavilyApiKey) apiWrapperParams.tavilyApiKey = params.tavilyApiKey;
          if (params.apiBaseUrl) apiWrapperParams.apiBaseUrl = params.apiBaseUrl;
          this.apiWrapper = new TavilySearchAPIWrapper(apiWrapperParams);
        }
        this.includeDomains = params.includeDomains;
        this.excludeDomains = params.excludeDomains;
        this.searchDepth = params.searchDepth;
        this.includeImages = params.includeImages;
        this.timeRange = params.timeRange;
        this.maxResults = params.maxResults;
        this.topic = params.topic;
        this.includeAnswer = params.includeAnswer;
        this.includeRawContent = params.includeRawContent;
        this.includeImageDescriptions = params.includeImageDescriptions;
        this.chunksPerSource = params.chunksPerSource;
        this.country = params.country;
        this.autoParameters = params.autoParameters;
        this.includeFavicon = params.includeFavicon;
        this.includeUsage = params.includeUsage;
      }
      async _call(input, _runManager) {
        try {
          const { query, includeDomains, excludeDomains, searchDepth, includeImages, timeRange, topic } = input;
          const effectiveIncludeDomains = this.includeDomains ?? includeDomains;
          const effectiveExcludeDomains = this.excludeDomains ?? excludeDomains;
          const effectiveSearchDepth = this.searchDepth ?? searchDepth;
          const effectiveIncludeImages = this.includeImages ?? includeImages;
          const effectiveTimeRange = this.timeRange ?? timeRange;
          const effectiveTopic = this.topic ?? topic;
          const rawResults = await this.apiWrapper.rawResults({
            query,
            includeDomains: effectiveIncludeDomains,
            excludeDomains: effectiveExcludeDomains,
            searchDepth: effectiveSearchDepth,
            includeImages: effectiveIncludeImages,
            timeRange: effectiveTimeRange,
            topic: effectiveTopic,
            maxResults: this.maxResults,
            includeAnswer: this.includeAnswer,
            includeRawContent: this.includeRawContent,
            includeImageDescriptions: this.includeImageDescriptions,
            chunksPerSource: this.chunksPerSource,
            country: this.country,
            autoParameters: this.autoParameters,
            includeFavicon: this.includeFavicon,
            includeUsage: this.includeUsage
          });
          if (!rawResults || typeof rawResults !== "object" || !("results" in rawResults) || !Array.isArray(rawResults.results) || rawResults.results.length === 0) {
            const searchParams = {
              timeRange: effectiveTimeRange,
              includeDomains: effectiveIncludeDomains,
              excludeDomains: effectiveExcludeDomains,
              searchDepth: effectiveSearchDepth,
              topic: effectiveTopic
            };
            const suggestions = generateSuggestions(searchParams);
            const errorMessage = `No search results found for '${query}'. Suggestions: ${suggestions.join(", ")}. Try modifying your search parameters with one of these approaches.`;
            throw new Error(errorMessage);
          }
          return rawResults;
        } catch (e) {
          const errorMessage = e && typeof e === "object" && "message" in e ? e.message : String(e);
          return { error: errorMessage };
        }
      }
    };
  }
});

// node_modules/@langchain/tavily/dist/tavily-crawl.js
var inputSchema3;
var init_tavily_crawl = __esm({
  "node_modules/@langchain/tavily/dist/tavily-crawl.js"() {
    init_utils12();
    init_tools2();
    init_v3();
    inputSchema3 = external_exports.object({
      url: external_exports.string().describe("URL to crawl"),
      instructions: external_exports.string().optional().describe("Natural language instructions for the crawler. Example: 'Python SDK'"),
      selectPaths: external_exports.array(external_exports.string()).optional().describe("Regex patterns to select only URLs with specific path patterns. Example: ['/api/v1.*']"),
      selectDomains: external_exports.array(external_exports.string()).optional().describe("Regex patterns to select only URLs from specific domains or subdomains. Example: ['^docs\\.example\\.com$']"),
      excludePaths: external_exports.array(external_exports.string()).optional().describe("Regex patterns to exclude URLs with specific path patterns. Example: ['/private/.*', '/admin/.*']"),
      excludeDomains: external_exports.array(external_exports.string()).optional().describe("Regex patterns to exclude specific domains or subdomains from crawling. Example: ['^private\\.example\\.com$']"),
      allowExternal: external_exports.boolean().optional().describe("Whether to allow following links that go to external domains."),
      categories: external_exports.array(external_exports.enum([
        "Documentation",
        "Blog",
        "Blogs",
        "Community",
        "About",
        "Contact",
        "Privacy",
        "Terms",
        "Status",
        "Pricing",
        "Enterprise",
        "Careers",
        "E-Commerce",
        "Authentication",
        "Developer",
        "Developers",
        "Solutions",
        "Partners",
        "Downloads",
        "Media",
        "Events",
        "People"
      ])).optional().describe("Filter URLs using predefined categories like 'Documentation', 'Blogs', etc.")
    });
  }
});

// node_modules/@langchain/tavily/dist/tavily-map.js
var inputSchema4;
var init_tavily_map = __esm({
  "node_modules/@langchain/tavily/dist/tavily-map.js"() {
    init_utils12();
    init_tools2();
    init_v3();
    inputSchema4 = external_exports.object({
      url: external_exports.string().describe("URL to map"),
      instructions: external_exports.string().optional().describe("Natural language instructions for the crawler. Example: 'Python SDK'"),
      selectPaths: external_exports.array(external_exports.string()).optional().describe("Regex patterns to select only URLs with specific path patterns. Example: ['/api/v1.*']"),
      selectDomains: external_exports.array(external_exports.string()).optional().describe("Regex patterns to select only URLs from specific domains or subdomains. Example: ['^docs\\.example\\.com$']"),
      excludePaths: external_exports.array(external_exports.string()).optional().describe("Regex patterns to exclude URLs with specific path patterns. Example: ['/private/.*', '/admin/.*']"),
      excludeDomains: external_exports.array(external_exports.string()).optional().describe("Regex patterns to exclude specific domains or subdomains from crawling. Example: ['^private\\.example\\.com$']"),
      allowExternal: external_exports.boolean().optional().describe("Whether to allow following links that go to external domains."),
      categories: external_exports.array(external_exports.enum([
        "Documentation",
        "Blog",
        "Blogs",
        "Community",
        "About",
        "Contact",
        "Privacy",
        "Terms",
        "Status",
        "Pricing",
        "Enterprise",
        "Careers",
        "E-Commerce",
        "Authentication",
        "Developer",
        "Developers",
        "Solutions",
        "Partners",
        "Downloads",
        "Media",
        "Events",
        "People"
      ])).optional().describe("Filter URLs using predefined categories like 'Documentation', 'Blogs', etc.")
    });
  }
});

// node_modules/@langchain/tavily/dist/tavily-research.js
var outputSchemaPropertySchema, inputSchema5;
var init_tavily_research = __esm({
  "node_modules/@langchain/tavily/dist/tavily-research.js"() {
    init_utils12();
    init_tools2();
    init_v3();
    outputSchemaPropertySchema = external_exports.lazy(() => external_exports.object({
      type: external_exports.enum([
        "object",
        "string",
        "integer",
        "number",
        "array"
      ]).optional(),
      description: external_exports.string().optional(),
      properties: external_exports.record(outputSchemaPropertySchema).optional(),
      items: external_exports.object({ type: external_exports.enum([
        "object",
        "string",
        "integer",
        "number",
        "array"
      ]) }).optional()
    }));
    inputSchema5 = external_exports.object({
      input: external_exports.string().describe("The research task or question to investigate."),
      model: external_exports.enum([
        "mini",
        "pro",
        "auto"
      ]).optional().describe(`The model used by the research agent. 
      "mini" is optimized for targeted, efficient research and works best for narrow or well-scoped questions. 
      "pro" provides comprehensive, multi-angle research and is suited for complex topics that span multiple subtopics or domains.
      "auto" lets Tavily automatically determine the appropriate model based on the task complexity.
      Default is "auto".
      `),
      outputSchema: external_exports.object({
        properties: external_exports.record(outputSchemaPropertySchema),
        required: external_exports.array(external_exports.string()).optional()
      }).optional().describe(`
      A JSON Schema object that defines the structure of the research output. 
      When provided, the research response will be structured to match this schema, ensuring a predictable and validated output shape. 
      Must include a 'properties' field, and may optionally include 'required' field.
      `),
      stream: external_exports.boolean().optional().describe(`Whether to stream the research results as they are generated. 
      When 'true', returns a Server-Sent Events (SSE) stream.
      Default is false.
      `),
      citationFormat: external_exports.enum([
        "numbered",
        "mla",
        "apa",
        "chicago"
      ]).optional().describe(`The format for citations in the research report.
      Default is "numbered".`)
    });
  }
});

// node_modules/@langchain/tavily/dist/tavily-get-research.js
var inputSchema6;
var init_tavily_get_research = __esm({
  "node_modules/@langchain/tavily/dist/tavily-get-research.js"() {
    init_utils12();
    init_tools2();
    init_v3();
    inputSchema6 = external_exports.object({ requestId: external_exports.string().describe("The unique identifier of the research task.") });
  }
});

// node_modules/@langchain/tavily/dist/index.js
var init_dist6 = __esm({
  "node_modules/@langchain/tavily/dist/index.js"() {
    init_utils12();
    init_tavily_extract();
    init_tavily_search();
    init_tavily_crawl();
    init_tavily_map();
    init_tavily_research();
    init_tavily_get_research();
  }
});

// server/services/tavily.ts
var TavilyService, tavilyService;
var init_tavily = __esm({
  "server/services/tavily.ts"() {
    "use strict";
    init_dist6();
    TavilyService = class {
      searchTool;
      constructor() {
        if (!process.env.TAVILY_API_KEY) {
          console.warn("TAVILY_API_KEY not set - Tavily search will be unavailable");
        }
        this.searchTool = new TavilySearch({
          maxResults: 15,
          tavilyApiKey: process.env.TAVILY_API_KEY,
          includeRawContent: "markdown",
          searchDepth: "advanced",
          topic: "news"
        });
      }
      async searchArticles(topic, days, keywords) {
        try {
          const query = keywords ? `${topic} ${keywords}` : topic;
          let timeRange = "week";
          if (days <= 1) {
            timeRange = "day";
          } else if (days <= 7) {
            timeRange = "week";
          } else if (days <= 30) {
            timeRange = "month";
          } else {
            timeRange = "year";
          }
          console.log(`[Tavily] Searching for: "${query}" with timeRange: ${timeRange}`);
          const response = await this.searchTool.invoke({
            query,
            timeRange,
            topic: "news"
          });
          if (typeof response === "object" && "results" in response) {
            const results = response.results;
            return results.map((result) => this.transformToArticle(result));
          }
          console.log("[Tavily] Unexpected response format:", typeof response);
          return [];
        } catch (error40) {
          console.error("[Tavily] Search error:", error40);
          return [];
        }
      }
      transformToArticle(result) {
        let source = "Unknown";
        try {
          const url2 = new URL(result.url);
          source = url2.hostname.replace("www.", "");
        } catch {
          source = "Unknown";
        }
        return {
          id: crypto.randomUUID(),
          title: result.title,
          url: result.url,
          source,
          publishedDate: result.published_date,
          content: result.raw_content || result.content
        };
      }
      isAvailable() {
        return !!process.env.TAVILY_API_KEY;
      }
    };
    tavilyService = new TavilyService();
  }
});

// server/config.ts
function initializeLangSmith() {
  if (LANGCHAIN_TRACING_V2.toLowerCase() === "true" && LANGCHAIN_API_KEY) {
    process.env.LANGCHAIN_TRACING_V2 = "true";
    process.env.LANGCHAIN_API_KEY = LANGCHAIN_API_KEY;
    process.env.LANGCHAIN_PROJECT = LANGCHAIN_PROJECT;
    process.env.LANGCHAIN_ENDPOINT = LANGCHAIN_ENDPOINT;
    console.log(`[Config] LangSmith tracing enabled for project: ${LANGCHAIN_PROJECT}`);
    return true;
  }
  return false;
}
var GOOGLE_API_KEY, OPENAI_API_KEY, TAVILY_API_KEY, LANGCHAIN_TRACING_V2, LANGCHAIN_API_KEY, LANGCHAIN_PROJECT, LANGCHAIN_ENDPOINT, PORT, SESSION_SECRET, NODE_ENV, tracingEnabled, IS_TRACING_ENABLED;
var init_config3 = __esm({
  "server/config.ts"() {
    "use strict";
    GOOGLE_API_KEY = process.env.GOOGLE_API_KEY || "";
    OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
    TAVILY_API_KEY = process.env.TAVILY_API_KEY || "";
    LANGCHAIN_TRACING_V2 = process.env.LANGCHAIN_TRACING_V2 || "false";
    LANGCHAIN_API_KEY = process.env.LANGCHAIN_API_KEY || "";
    LANGCHAIN_PROJECT = process.env.LANGCHAIN_PROJECT || "research-lens";
    LANGCHAIN_ENDPOINT = process.env.LANGCHAIN_ENDPOINT || "https://api.smith.langchain.com";
    PORT = parseInt(process.env.PORT || "5000", 10);
    SESSION_SECRET = process.env.SESSION_SECRET || "dev-secret-change-in-production";
    NODE_ENV = process.env.NODE_ENV || "development";
    tracingEnabled = initializeLangSmith();
    IS_TRACING_ENABLED = tracingEnabled;
  }
});

// server/agents/research-agent.ts
var research_agent_exports = {};
__export(research_agent_exports, {
  runResearchAgent: () => runResearchAgent
});
function getModel(runName) {
  return new ChatOpenAI({
    model: "gpt-4o-mini",
    temperature: 0.1,
    apiKey: OPENAI_API_KEY
  }).withConfig({
    runName: runName || "openai-research",
    tags: ["research-lens", "openai"]
  });
}
async function fetchPapers(state) {
  console.log(`[ResearchAgent] Fetching papers for: ${state.topic}`);
  try {
    const rawPapers = await arxivService.searchPapers(
      state.topic,
      state.keywords,
      void 0,
      // no subdomain filter
      state.timeframeDays
    );
    const papers = rawPapers.map((paper) => ({
      id: paper.id,
      title: paper.title,
      authors: paper.authors,
      arxivUrl: paper.arxivUrl,
      publishedDate: paper.publishedDate,
      abstract: paper.abstract,
      categories: paper.categories,
      summary: {
        problemStatement: "",
        proposedSolution: "",
        challenges: ""
      }
    }));
    console.log(`[ResearchAgent] Found ${papers.length} papers`);
    return { papers };
  } catch (error40) {
    console.error("[ResearchAgent] Error fetching papers:", error40);
    return { papers: [], error: `Failed to fetch papers: ${error40}` };
  }
}
async function fetchArticles(state) {
  console.log(`[ResearchAgent] Fetching articles for: ${state.topic}`);
  try {
    const articles = await tavilyService.searchArticles(
      state.topic,
      state.timeframeDays,
      state.keywords
    );
    console.log(`[ResearchAgent] Found ${articles.length} articles`);
    return { articles };
  } catch (error40) {
    console.error("[ResearchAgent] Error fetching articles:", error40);
    return { articles: [], error: `Failed to fetch articles: ${error40}` };
  }
}
async function summarizePapers(state) {
  console.log(`[ResearchAgent] Summarizing ${state.papers.length} papers`);
  if (IS_TRACING_ENABLED) {
    console.log(`[ResearchAgent] LangSmith tracing active for paper summarization`);
  }
  if (state.papers.length === 0) {
    return { papers: [] };
  }
  const model = getModel("paper-summarizer");
  const summarizedPapers = [];
  for (const paper of state.papers) {
    try {
      const prompt = `Analyze this research paper and provide a structured summary.

Title: ${paper.title}
Authors: ${paper.authors}
Abstract: ${paper.abstract}

Provide a JSON response with exactly these three fields:
- problemStatement: What specific problem or challenge does this paper address? (1-2 sentences)
- proposedSolution: What is the main approach, method, or contribution proposed? (1-2 sentences)
- challenges: What limitations, challenges, or future work are mentioned? (1-2 sentences)

Only use information explicitly stated in the abstract. If something is not mentioned, say "Not specified in abstract."

Respond with ONLY valid JSON, no markdown formatting.`;
      const response = await model.invoke(prompt);
      const content = response.content.toString();
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        summarizedPapers.push({
          ...paper,
          summary: {
            problemStatement: parsed.problemStatement || "Not specified in abstract.",
            proposedSolution: parsed.proposedSolution || "Not specified in abstract.",
            challenges: parsed.challenges || "Not specified in abstract."
          }
        });
      } else {
        summarizedPapers.push(paper);
      }
      await new Promise((resolve) => setTimeout(resolve, 300));
    } catch (error40) {
      console.error(`[ResearchAgent] Error summarizing paper ${paper.id}:`, error40);
      summarizedPapers.push({
        ...paper,
        summary: {
          problemStatement: "Summary unavailable.",
          proposedSolution: "Summary unavailable.",
          challenges: "Summary unavailable."
        }
      });
    }
  }
  console.log(`[ResearchAgent] Summarized ${summarizedPapers.length} papers`);
  return { papers: summarizedPapers };
}
async function generatePaperExecutiveSummary(state) {
  console.log(`[ResearchAgent] Generating executive summary for papers`);
  if (state.papers.length === 0) {
    return { paperExecutiveSummary: "No papers found for this topic and timeframe." };
  }
  const model = getModel("paper-executive-summary");
  const papersList = state.papers.map((p, i) => `${i + 1}. "${p.title}" - ${p.summary.problemStatement}`).join("\n");
  const prompt = `You are a research analyst. Based on the following ${state.papers.length} academic papers about "${state.topic}", provide a concise executive summary (3-4 paragraphs) that:

1. Identifies the main themes and research directions
2. Highlights the most significant findings or contributions
3. Notes any emerging trends or patterns across the papers

Papers:
${papersList}

Write a clear, professional summary suitable for executives or researchers wanting a quick overview.`;
  try {
    const response = await model.invoke(prompt);
    return { paperExecutiveSummary: response.content.toString() };
  } catch (error40) {
    console.error("[ResearchAgent] Error generating paper executive summary:", error40);
    return { paperExecutiveSummary: "Executive summary generation failed. Please review individual paper summaries." };
  }
}
async function generateArticleExecutiveSummary(state) {
  console.log(`[ResearchAgent] Generating executive summary for articles`);
  if (state.articles.length === 0) {
    return { articleExecutiveSummary: "No articles found for this topic and timeframe." };
  }
  const model = getModel("article-executive-summary");
  const articlesList = state.articles.map((a, i) => `${i + 1}. "${a.title}" (${a.source})`).join("\n");
  const prompt = `You are a technology news analyst. Based on the following ${state.articles.length} articles about "${state.topic}", provide a concise executive summary (2-3 paragraphs) that:

1. Summarizes the key news and developments
2. Identifies any significant announcements or trends
3. Notes the overall industry sentiment or direction

Articles:
${articlesList}

Write a clear, professional summary suitable for executives or professionals wanting a quick industry overview.`;
  try {
    const response = await model.invoke(prompt);
    return { articleExecutiveSummary: response.content.toString() };
  } catch (error40) {
    console.error("[ResearchAgent] Error generating article executive summary:", error40);
    return { articleExecutiveSummary: "Executive summary generation failed. Please review individual articles." };
  }
}
function buildResearchGraph() {
  const workflow = new StateGraph(ResearchState).addNode("fetchPapers", fetchPapers).addNode("fetchArticles", fetchArticles).addNode("summarizePapers", summarizePapers).addNode("generatePaperSummary", generatePaperExecutiveSummary).addNode("generateArticleSummary", generateArticleExecutiveSummary).addEdge(START, "fetchPapers").addEdge(START, "fetchArticles").addEdge("fetchPapers", "summarizePapers").addEdge("summarizePapers", "generatePaperSummary").addEdge("fetchArticles", "generateArticleSummary").addEdge("generatePaperSummary", END).addEdge("generateArticleSummary", END);
  return workflow.compile();
}
async function runResearchAgent(topic, timeframeDays, keywords) {
  console.log(`[ResearchAgent] Starting research for topic: "${topic}"`);
  if (IS_TRACING_ENABLED) {
    console.log(`[ResearchAgent] LangSmith tracing enabled - traces visible at smith.langchain.com`);
  }
  const graph = buildResearchGraph();
  const initialState = {
    topic,
    keywords,
    timeframeDays,
    papers: [],
    articles: [],
    paperExecutiveSummary: "",
    articleExecutiveSummary: "",
    error: void 0
  };
  try {
    const result = await graph.invoke(initialState, {
      runName: `research-${topic.slice(0, 30)}`,
      tags: ["research-lens", "research-workflow"],
      metadata: {
        topic,
        timeframeDays,
        keywords: keywords || "none"
      }
    });
    const response = {
      topic: result.topic,
      timeframeDays: result.timeframeDays,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      papers: {
        executiveSummary: result.paperExecutiveSummary,
        count: result.papers.length,
        items: result.papers
      },
      articles: {
        executiveSummary: result.articleExecutiveSummary,
        count: result.articles.length,
        items: result.articles.map((article) => ({
          id: article.id,
          title: article.title,
          url: article.url,
          source: article.source,
          publishedDate: article.publishedDate
        }))
      },
      warning: result.error
    };
    console.log(`[ResearchAgent] Research complete. Papers: ${response.papers.count}, Articles: ${response.articles.count}`);
    return response;
  } catch (error40) {
    console.error("[ResearchAgent] Error running research agent:", error40);
    return {
      topic,
      timeframeDays,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      papers: {
        executiveSummary: "Research failed. Please try again.",
        count: 0,
        items: []
      },
      articles: {
        executiveSummary: "Research failed. Please try again.",
        count: 0,
        items: []
      },
      warning: `Error: ${error40 instanceof Error ? error40.message : "Unknown error"}`
    };
  }
}
var ResearchState, arxivService;
var init_research_agent = __esm({
  "server/agents/research-agent.ts"() {
    "use strict";
    init_dist4();
    init_dist5();
    init_arxiv();
    init_tavily();
    init_config3();
    ResearchState = Annotation.Root({
      topic: Annotation(),
      keywords: Annotation(),
      timeframeDays: Annotation(),
      papers: Annotation({
        default: () => [],
        reducer: (_, new_) => new_
      }),
      articles: Annotation({
        default: () => [],
        reducer: (_, new_) => new_
      }),
      paperExecutiveSummary: Annotation({
        default: () => "",
        reducer: (_, new_) => new_
      }),
      articleExecutiveSummary: Annotation({
        default: () => "",
        reducer: (_, new_) => new_
      }),
      error: Annotation()
    });
    arxivService = new ArxivService();
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  articleSchema: () => articleSchema,
  digestResponseSchema: () => digestResponseSchema,
  historyItemSchema: () => historyItemSchema,
  loginSchema: () => loginSchema,
  paperSummarySchema: () => paperSummarySchema,
  registerSchema: () => registerSchema,
  searchHistory: () => searchHistory,
  searchRequestSchema: () => searchRequestSchema,
  sessions: () => sessions,
  userSchema: () => userSchema,
  users: () => users
});
import { pgTable, text, uuid as uuid3, timestamp, integer as integer2, jsonb } from "drizzle-orm/pg-core";
var users, searchHistory, sessions, searchRequestSchema, paperSummarySchema, articleSchema, digestResponseSchema, userSchema, registerSchema, loginSchema, historyItemSchema;
var init_schema2 = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_zod();
    users = pgTable("users", {
      id: uuid3("id").primaryKey().defaultRandom(),
      email: text("email").unique().notNull(),
      passwordHash: text("password_hash").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    searchHistory = pgTable("search_history", {
      id: uuid3("id").primaryKey().defaultRandom(),
      userId: uuid3("user_id").references(() => users.id),
      sessionId: text("session_id"),
      // For anonymous users
      topic: text("topic").notNull(),
      keywords: text("keywords"),
      timeframeDays: integer2("timeframe_days").notNull(),
      paperCount: integer2("paper_count"),
      articleCount: integer2("article_count"),
      executiveSummary: jsonb("executive_summary"),
      results: jsonb("results"),
      // Full results for history replay
      createdAt: timestamp("created_at").defaultNow()
    });
    sessions = pgTable("sessions", {
      sid: text("sid").primaryKey(),
      sess: jsonb("sess").notNull(),
      expire: timestamp("expire").notNull()
    });
    searchRequestSchema = external_exports.object({
      topic: external_exports.string().min(1, "Topic is required"),
      keywords: external_exports.string().optional(),
      timeframeDays: external_exports.number().min(1).max(30).optional().default(7)
    });
    paperSummarySchema = external_exports.object({
      id: external_exports.string(),
      title: external_exports.string(),
      authors: external_exports.string(),
      arxivUrl: external_exports.string(),
      publishedDate: external_exports.string(),
      abstract: external_exports.string(),
      categories: external_exports.array(external_exports.string()),
      summary: external_exports.object({
        problemStatement: external_exports.string(),
        // What problem does the paper target?
        proposedSolution: external_exports.string(),
        // What solution does it propose?
        challenges: external_exports.string()
        // What challenges does it acknowledge?
      })
    });
    articleSchema = external_exports.object({
      id: external_exports.string(),
      title: external_exports.string(),
      url: external_exports.string(),
      source: external_exports.string(),
      // Domain/publication name
      publishedDate: external_exports.string().optional(),
      content: external_exports.string().optional()
      // Raw content for summarization
    });
    digestResponseSchema = external_exports.object({
      topic: external_exports.string(),
      timeframeDays: external_exports.number(),
      generatedAt: external_exports.string(),
      // Papers section
      papers: external_exports.object({
        executiveSummary: external_exports.string(),
        // AI overview of all papers
        count: external_exports.number(),
        items: external_exports.array(paperSummarySchema)
      }),
      // Articles section
      articles: external_exports.object({
        executiveSummary: external_exports.string(),
        // AI overview of all articles
        count: external_exports.number(),
        items: external_exports.array(external_exports.object({
          id: external_exports.string(),
          title: external_exports.string(),
          url: external_exports.string(),
          source: external_exports.string(),
          publishedDate: external_exports.string().optional()
        }))
      }),
      warning: external_exports.string().optional()
    });
    userSchema = external_exports.object({
      id: external_exports.string().uuid(),
      email: external_exports.string().email(),
      createdAt: external_exports.string()
    });
    registerSchema = external_exports.object({
      email: external_exports.string().email("Invalid email address"),
      password: external_exports.string().min(8, "Password must be at least 8 characters")
    });
    loginSchema = external_exports.object({
      email: external_exports.string().email("Invalid email address"),
      password: external_exports.string().min(1, "Password is required")
    });
    historyItemSchema = external_exports.object({
      id: external_exports.string().uuid(),
      topic: external_exports.string(),
      keywords: external_exports.string().nullable(),
      timeframeDays: external_exports.number(),
      paperCount: external_exports.number().nullable(),
      articleCount: external_exports.number().nullable(),
      createdAt: external_exports.string()
    });
  }
});

// src/api/research.ts
init_zod();
function checkEnvironment() {
  const issues = [];
  if (!process.env.OPENAI_API_KEY) {
    issues.push("OPENAI_API_KEY is not set");
  }
  if (!process.env.TAVILY_API_KEY) {
    issues.push("TAVILY_API_KEY is not set");
  }
  if (!process.env.DATABASE_URL) {
    issues.push("DATABASE_URL is not set (history will be disabled)");
  }
  console.log("[ENV CHECK] OPENAI_API_KEY:", process.env.OPENAI_API_KEY ? "SET" : "MISSING");
  console.log("[ENV CHECK] TAVILY_API_KEY:", process.env.TAVILY_API_KEY ? "SET" : "MISSING");
  console.log("[ENV CHECK] DATABASE_URL:", process.env.DATABASE_URL ? "SET" : "MISSING");
  console.log("[ENV CHECK] LANGCHAIN_TRACING_V2:", process.env.LANGCHAIN_TRACING_V2 || "not set");
  console.log("[ENV CHECK] NODE_ENV:", process.env.NODE_ENV || "not set");
  return {
    ok: !!process.env.OPENAI_API_KEY,
    issues
  };
}
var LANGCHAIN_TRACING = process.env.LANGCHAIN_TRACING_V2 === "true";
if (LANGCHAIN_TRACING && process.env.LANGCHAIN_API_KEY) {
  process.env.LANGCHAIN_TRACING_V2 = "true";
  process.env.LANGCHAIN_API_KEY = process.env.LANGCHAIN_API_KEY;
  process.env.LANGCHAIN_PROJECT = process.env.LANGCHAIN_PROJECT || "research-lens";
  console.log("[LANGSMITH] Tracing enabled for project:", process.env.LANGCHAIN_PROJECT);
}
var runResearchAgent2;
var searchRequestSchema2;
var digestResponseSchema2;
async function loadDependencies() {
  console.log("[INIT] Loading dependencies...");
  try {
    if (!runResearchAgent2) {
      console.log("[INIT] Importing research-agent module...");
      const agentModule = await Promise.resolve().then(() => (init_research_agent(), research_agent_exports));
      runResearchAgent2 = agentModule.runResearchAgent;
      console.log("[INIT] research-agent module loaded successfully");
    }
    if (!searchRequestSchema2) {
      console.log("[INIT] Importing schema module...");
      const schemaModule = await Promise.resolve().then(() => (init_schema2(), schema_exports));
      searchRequestSchema2 = schemaModule.searchRequestSchema;
      digestResponseSchema2 = schemaModule.digestResponseSchema;
      console.log("[INIT] schema module loaded successfully");
    }
    console.log("[INIT] All dependencies loaded");
  } catch (error40) {
    console.error("[INIT] Failed to load dependencies:", error40);
    throw error40;
  }
}
async function handler(req, res) {
  const startTime = Date.now();
  console.log(`[REQUEST] ${req.method} /api/research - Start`);
  if (req.method !== "POST") {
    console.log("[REQUEST] Method not allowed:", req.method);
    res.status(405).json({ error: "Method not allowed" });
    return;
  }
  const envCheck = checkEnvironment();
  if (!envCheck.ok) {
    console.error("[REQUEST] Environment check failed:", envCheck.issues);
    res.status(503).json({
      message: "Service configuration error. Please contact support.",
      issues: envCheck.issues
    });
    return;
  }
  try {
    console.log("[REQUEST] Loading dependencies...");
    await loadDependencies();
    console.log("[REQUEST] Validating request body:", JSON.stringify(req.body));
    const validatedData = searchRequestSchema2.parse(req.body);
    console.log(`[REQUEST] Validated - topic="${validatedData.topic}", days=${validatedData.timeframeDays}`);
    console.log("[REQUEST] Starting research agent...");
    const result = await runResearchAgent2(
      validatedData.topic,
      validatedData.timeframeDays,
      validatedData.keywords
    );
    console.log(`[REQUEST] Research complete - papers: ${result.papers?.count || 0}, articles: ${result.articles?.count || 0}`);
    const response = digestResponseSchema2.parse(result);
    const duration3 = Date.now() - startTime;
    console.log(`[REQUEST] Success - Duration: ${duration3}ms`);
    res.status(200).json(response);
  } catch (error40) {
    const duration3 = Date.now() - startTime;
    console.error(`[REQUEST] Error after ${duration3}ms:`, error40);
    if (error40 instanceof Error) {
      console.error("[ERROR] Name:", error40.name);
      console.error("[ERROR] Message:", error40.message);
      console.error("[ERROR] Stack:", error40.stack);
    }
    if (error40 instanceof external_exports.ZodError) {
      console.error("[ERROR] Zod validation errors:", JSON.stringify(error40.errors));
      res.status(400).json({
        message: "Please check your search parameters and try again.",
        errors: error40.errors
      });
      return;
    }
    res.status(500).json({
      message: "We encountered a temporary issue. Please try again in a moment.",
      error: error40 instanceof Error ? error40.message : "Unknown error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
}
export {
  handler as default
};
/*! Bundled license information:

@langchain/core/dist/utils/fast-json-patch/src/helpers.js:
  (*!
  * https://github.com/Starcounter-Jack/JSON-Patch
  * (c) 2017-2022 Joachim Wester
  * MIT licensed
  *)

@langchain/core/dist/utils/sax-js/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
